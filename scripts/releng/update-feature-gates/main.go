/*
Copyright 2025 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// update-feature-gates reads feature gate data from a JSON file (generated by
// genfeaturegates in kubernetes/kubernetes) and updates the corresponding
// markdown files in the website repository.
//
// Usage:
//
//	go run ./scripts/releng/update-feature-gates /path/to/feature-gates.json
//
// The tool preserves existing descriptions in the markdown files and only
// updates the YAML front matter with the latest stage information.
package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// FeatureGateJSON represents a feature gate from the JSON input
type FeatureGateJSON struct {
	Name         string      `json:"name"`
	Stages       []StageJSON `json:"stages"`
	Dependencies []string    `json:"dependencies,omitempty"`
}

// StageJSON represents a stage in the feature gate lifecycle
type StageJSON struct {
	Stage       string `json:"stage"`
	FromVersion string `json:"fromVersion"`
	ToVersion   string `json:"toVersion,omitempty"`
	Default     bool   `json:"defaultValue"`
	Locked      bool   `json:"locked,omitempty"`
}

const defaultFeatureGatesDir = "content/en/docs/reference/command-line-tools-reference/feature-gates"

func main() {
	var outputDir string
	flag.StringVar(&outputDir, "output-dir", defaultFeatureGatesDir, "Directory containing feature gate markdown files")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [flags] <feature-gates.json>\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Updates feature gate markdown files from JSON data.\n\n")
		fmt.Fprintf(os.Stderr, "Flags:\n")
		flag.PrintDefaults()
	}
	flag.Parse()

	if flag.NArg() != 1 {
		flag.Usage()
		os.Exit(1)
	}

	jsonPath := flag.Arg(0)

	// Read and parse JSON
	jsonData, err := os.ReadFile(jsonPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading JSON file: %v\n", err)
		os.Exit(1)
	}

	var features []FeatureGateJSON
	if err := json.Unmarshal(jsonData, &features); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing JSON: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Processing %d feature gates...\n", len(features))

	// Process each feature gate
	var created, updated, unchanged int
	for _, fg := range features {
		mdPath := filepath.Join(outputDir, fg.Name+".md")

		action, err := updateFeatureGateFile(mdPath, fg)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error processing %s: %v\n", fg.Name, err)
			continue
		}

		switch action {
		case "created":
			created++
		case "updated":
			updated++
		case "unchanged":
			unchanged++
		}
	}

	fmt.Printf("\nDone!\n")
	fmt.Printf("  Created: %d\n", created)
	fmt.Printf("  Updated: %d\n", updated)
	fmt.Printf("  Unchanged: %d\n", unchanged)
	fmt.Printf("  Files in: %s\n", outputDir)
}

// updateFeatureGateFile updates or creates a feature gate markdown file
// Returns the action taken: "created", "updated", or "unchanged"
func updateFeatureGateFile(path string, fg FeatureGateJSON) (string, error) {
	newFrontMatter := generateFrontMatter(fg)

	// Check if file exists
	existingContent, err := os.ReadFile(path)
	if os.IsNotExist(err) {
		// Create new file with TODO placeholder
		content := newFrontMatter + "---\n<!-- TODO: Add description for " + fg.Name + " feature gate -->\n"
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			return "", fmt.Errorf("failed to create file: %w", err)
		}
		return "created", nil
	} else if err != nil {
		return "", fmt.Errorf("failed to read file: %w", err)
	}

	// Parse existing file to extract comments, description
	existingFrontMatter, comments, description, err := parseMarkdownFile(string(existingContent))
	if err != nil {
		return "", fmt.Errorf("failed to parse file: %w", err)
	}

	// Build the new front matter with preserved comments
	finalFrontMatter := newFrontMatter
	if comments != "" {
		finalFrontMatter += "\n" + comments + "\n"
	}

	// Check if front matter changed (ignoring whitespace and comments for comparison)
	if normalizeFrontMatter(existingFrontMatter) == normalizeFrontMatter(finalFrontMatter) {
		return "unchanged", nil
	}

	// Write updated file preserving comments and description
	content := finalFrontMatter + "---\n" + description
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return "", fmt.Errorf("failed to write file: %w", err)
	}

	return "updated", nil
}

// generateFrontMatter creates the YAML front matter for a feature gate
func generateFrontMatter(fg FeatureGateJSON) string {
	var sb strings.Builder

	sb.WriteString("---\n")
	sb.WriteString("title: " + fg.Name + "\n")
	sb.WriteString("content_type: feature_gate\n")
	sb.WriteString("_build:\n")
	sb.WriteString("  list: never\n")
	sb.WriteString("  render: false\n")
	sb.WriteString("\n")
	sb.WriteString("stages:\n")

	for _, stage := range fg.Stages {
		sb.WriteString("  - stage: " + stage.Stage + "\n")
		sb.WriteString(fmt.Sprintf("    defaultValue: %t\n", stage.Default))
		sb.WriteString("    fromVersion: \"" + stage.FromVersion + "\"\n")
		if stage.ToVersion != "" {
			sb.WriteString("    toVersion: \"" + stage.ToVersion + "\"\n")
		}
		if stage.Locked {
			sb.WriteString("    locked: true\n")
		}
	}

	return sb.String()
}

// parseMarkdownFile extracts front matter, comments (lines starting with #),
// and description from a markdown file.
// Comments within the front matter (YAML comments starting with #) are extracted
// separately so they can be preserved when updating the stages.
func parseMarkdownFile(content string) (frontMatter, comments, description string, err error) {
	scanner := bufio.NewScanner(strings.NewReader(content))

	// Find first --- (must be exactly "---", no leading/trailing spaces)
	if !scanner.Scan() || strings.TrimRight(scanner.Text(), "\r") != "---" {
		return "", "", "", fmt.Errorf("file does not start with ---")
	}

	// Read front matter until closing ---
	// Separate YAML content from comments
	var fmLines []string
	var commentLines []string
	fmLines = append(fmLines, "---")
	foundEnd := false
	for scanner.Scan() {
		line := scanner.Text()
		// Closing delimiter must be exactly "---" (no leading whitespace)
		if strings.TrimRight(line, "\r") == "---" {
			foundEnd = true
			break
		}
		// Check if this is a YAML comment (starts with # after optional whitespace)
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "#") {
			commentLines = append(commentLines, line)
		} else {
			fmLines = append(fmLines, line)
		}
	}

	if !foundEnd {
		return "", "", "", fmt.Errorf("no closing --- found for front matter")
	}

	frontMatter = strings.Join(fmLines, "\n") + "\n"
	comments = strings.Join(commentLines, "\n")

	// Rest is description
	var descLines []string
	for scanner.Scan() {
		descLines = append(descLines, scanner.Text())
	}

	description = strings.Join(descLines, "\n")
	// Ensure description ends with newline if non-empty
	if description != "" && !strings.HasSuffix(description, "\n") {
		description += "\n"
	}

	return frontMatter, comments, description, nil
}

// normalizeFrontMatter normalizes front matter for comparison
// by removing trailing whitespace and normalizing line endings
func normalizeFrontMatter(fm string) string {
	var lines []string
	scanner := bufio.NewScanner(strings.NewReader(fm))
	for scanner.Scan() {
		line := strings.TrimRight(scanner.Text(), " \t")
		// Skip empty lines for comparison
		if line != "" {
			lines = append(lines, line)
		}
	}
	return strings.Join(lines, "\n")
}