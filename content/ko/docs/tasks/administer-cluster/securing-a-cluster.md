---
reviewers:
- smarterclayton
- liggitt
- enj
title: 클러스터 보안
content_type: task
weight: 320
---

<!-- overview -->

이 문서는 우발적이거나 악의적인 접근으로부터 클러스터를 보호하는 것과 관련된 주제를 다루며, 전반적인 보안에 대한 권장사항을 제공한다.

## {{% heading "prerequisites" %}}

* {{< include "task-tutorial-prereqs.md" >}} {{< version-check >}}

<!-- steps -->

## 쿠버네티스 API에 대한 접근 제어

쿠버네티스는 전적으로 API 기반이므로, 누가 클러스터에 접근할 수 있고 어떤 작업을 수행할 수 있는지를 제어하고 제한하는 것이 첫 번째 방어선이다.

### 모든 API 트래픽에 전송 계층 보안(TLS) 사용

쿠버네티스는 클러스터 내 모든 API 통신이 기본적으로 TLS로 암호화되기를 기대하며, 대부분의 설치 방법은 필요한 인증서를 생성하고 클러스터 컴포넌트에 배포할 수 있게 한다. 일부 컴포넌트와 설치 방법은 HTTP를 통해 로컬 포트를 활성화할 수 있으므로, 관리자는 각 컴포넌트의 세팅을 숙지하여 잠재적으로 보안되지 않은 트래픽을 식별해야 한다.

### API 인증

클러스터를 설치할 때 일반적인 접근 패턴과 일치하는 인증 메커니즘을 API 서버가 사용하도록 선택한다. 예를 들어, 소규모 단일 사용자 클러스터는 간단한 인증서나 정적 베어러 토큰 방식을 사용할 수 있다. 대규모 클러스터는 사용자를 그룹으로 세분화할 수 있는 기존 OIDC 또는 LDAP 서버를 통합하길 원할 수 있다.

노드, 프록시, 스케줄러, 볼륨 플러그인과 같이 인프라의 일부인 클라이언트를 포함하여 모든 API 클라이언트가 인증되어야 한다. 이러한 클라이언트는 일반적으로 [서비스어카운트](/docs/reference/access-authn-authz/service-accounts-admin/)이거나 x509 클라이언트 인증서를 사용하며, 클러스터 시작 시 자동으로 생성되거나 클러스터 설치의 일부로 설정된다.

자세한 정보는 [인증 레퍼런스 문서](/docs/reference/access-authn-authz/authentication/)를 참조한다.

### API 인가

인증이 완료되면, 모든 API 호출은 인가 검사도 통과해야 한다. 쿠버네티스는 통합된 [롤 기반 접근 제어(RBAC)](/docs/reference/access-authn-authz/rbac/) 컴포넌트를 제공하며, 이는 들어오는 사용자나 그룹을 롤로 묶인 권한 집합과 매칭한다. 이러한 권한은 동사(get, create, delete)와 리소스(파드, 서비스, 노드)를 결합하며, 네임스페이스 범위 또는 클러스터 범위로 지정될 수 있다. 클라이언트가 수행하고자 하는 작업에 따라 합리적인 기본 책임 분리를 제공하는 일련의 기본 제공 롤이 제공된다. [노드](/docs/reference/access-authn-authz/node/) 및 [RBAC](/docs/reference/access-authn-authz/rbac/) 인가자를 [NodeRestriction](/docs/reference/access-authn-authz/admission-controllers/#noderestriction) 어드미션 플러그인과 함께 사용하는 것이 권장된다.

인증과 마찬가지로, 간단하고 광범위한 롤은 소규모 클러스터에 적합할 수 있지만, 더 많은 사용자가 클러스터와 상호작용함에 따라 팀을 더 제한된 롤을 가진 별도의 네임스페이스로 분리하는 것이 필요할 수 있다.

인가의 경우, 한 오브젝트에 대한 업데이트가 다른 곳에서 어떻게 작업을 유발할 수 있는지 이해하는 것이 중요하다. 예를 들어, 사용자가 파드를 직접 생성할 수 없더라도, 파드를 대신 생성하는 디플로이먼트를 생성하도록 허용하면 간접적으로 해당 파드를 생성할 수 있다. 마찬가지로, API에서 노드를 삭제하면 해당 노드에 스케줄된 파드가 종료되고 다른 노드에서 재생성된다. 기본 제공 롤은 유연성과 일반적인 유스케이스 간의 균형을 나타내지만, 더 제한적인 롤은 우발적인 권한 상승을 방지하기 위해 신중하게 검토해야 한다. 기본 제공 롤이 요구 사항을 충족하지 못하는 경우 유스케이스에 맞는 롤을 만들 수 있다.

자세한 정보는 [인가 레퍼런스 섹션](/docs/reference/access-authn-authz/authorization/)을 참조한다.

## Kubelet에 대한 접근 제어

Kubelet은 노드와 컨테이너에 대한 강력한 제어를 부여하는 HTTPS 엔드포인트를 노출한다. 기본적으로 Kubelet은 이 API에 대한 인증되지 않은 접근을 허용한다.

프로덕션 클러스터는 Kubelet 인증과 인가를 활성화해야 한다.

자세한 정보는 [Kubelet 인증/인가 레퍼런스](/docs/reference/access-authn-authz/kubelet-authn-authz/)를 참조한다.

## 런타임 시 워크로드 또는 사용자의 기능 제어

쿠버네티스의 인가는 의도적으로 높은 수준이며, 리소스에 대한 대략적인 작업에 초점을 맞춘다. 해당 오브젝트가 클러스터, 자기 자신 및 다른 리소스에 대해 어떻게 작동하는지를 유스케이스별로 제한하기 위한 더 강력한 제어가 **정책**으로 존재한다.

### 클러스터의 리소스 사용량 제한

[리소스쿼터](/docs/concepts/policy/resource-quotas/)는 네임스페이스에 부여된 리소스의 수나 용량을 제한한다. 이는 네임스페이스가 할당할 수 있는 CPU, 메모리 또는 퍼시스턴트 디스크의 양을 제한하는 데 가장 자주 사용되지만, 각 네임스페이스에 존재할 수 있는 파드, 서비스 또는 볼륨의 수도 제어할 수 있다.

[리밋레인지](/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/)는 위의 일부 리소스의 최대 또는 최소 크기를 제한하여, 사용자가 메모리와 같이 일반적으로 예약된 리소스에 대해 비합리적으로 높거나 낮은 값을 요청하는 것을 방지하거나, 지정되지 않은 경우 기본 한도를 제공한다.

### 컨테이너가 실행되는 권한 제어

파드 정의에는 [시큐리티 컨텍스트](/docs/tasks/configure-pod-container/security-context/)가 포함되어 있어, 노드에서 특정 리눅스 사용자(예: root)로 실행되도록 접근을 요청하거나, 특권을 가지고 실행하거나 호스트 네트워크에 접근하도록 하는 등 호스팅 노드에서 제한 없이 실행할 수 있게 하는 기타 제어를 요청할 수 있다.

네임스페이스에서 특정 [파드 시큐리티 표준](/docs/concepts/security/pod-security-standards/)의 사용을 강제하거나 위반을 탐지하기 위해 [파드 시큐리티 어드미션](/docs/concepts/security/pod-security-admission/)을 구성할 수 있다.

일반적으로 대부분의 애플리케이션 워크로드는 호스트 정보에 대한 접근 없이 루트 프로세스(uid 0)로 성공적으로 실행하기 위해 호스트 리소스에 대한 제한된 접근만 필요하다. 그러나 루트 사용자와 관련된 권한을 고려하여, 애플리케이션 컨테이너를 루트가 아닌 사용자로 실행되도록 작성해야 한다. 마찬가지로, 클라이언트 애플리케이션이 컨테이너에서 탈출하는 것을 방지하고자 하는 관리자는 **Baseline** 또는 **Restricted** 파드 시큐리티 표준을 적용해야 한다.

### 컨테이너가 원치 않는 커널 모듈을 로드하는 것 방지

리눅스 커널은 하드웨어가 연결되거나 파일시스템이 마운트되는 등 특정 상황에서 필요한 경우 디스크에서 커널 모듈을 자동으로 로드한다. 쿠버네티스와 특히 관련이 있는 것은, 특권을 가지지 않은 프로세스도 적절한 타입의 소켓을 생성하는 것만으로 특정 네트워크 프로토콜 관련 커널 모듈이 로드되도록 할 수 있다는 점이다. 이는 공격자가 관리자가 사용되지 않는다고 가정한 커널 모듈의 보안 취약점을 악용할 수 있게 할 수 있다.

특정 모듈이 자동으로 로드되는 것을 방지하려면, 노드에서 해당 모듈을 제거하거나 차단 규칙을 추가할 수 있다. 대부분의 리눅스 배포판에서는 다음과 같은 내용으로 `/etc/modprobe.d/kubernetes-blacklist.conf`와 같은 파일을 생성하여 이를 수행할 수 있다:

```
# DCCP는 필요하지 않을 가능성이 높고, 여러 심각한
# 취약점이 있었으며, 잘 관리되지 않는다.
blacklist dccp

# SCTP는 대부분의 쿠버네티스 클러스터에서 사용되지 않으며,
# 과거에 취약점도 있었다.
blacklist sctp
```

모듈 로딩을 보다 일반적으로 차단하려면, 리눅스 시큐리티 모듈(예: SELinux)을 사용하여 컨테이너에 대한 `module_request` 권한을 완전히 거부하여, 어떤 상황에서도 커널이 컨테이너용 모듈을 로드하는 것을 방지할 수 있다. (파드는 여전히 수동으로 로드된 모듈이나 더 많은 권한을 가진 프로세스를 대신하여 커널이 로드한 모듈을 사용할 수 있다.)

### 네트워크 접근 제한

네임스페이스에 대한 [네트워크폴리시](/docs/tasks/administer-cluster/declare-network-policy/)는 애플리케이션 작성자가 다른 네임스페이스의 어떤 파드가 자신의 네임스페이스 내의 파드와 포트에 접근할 수 있는지 제한할 수 있게 한다. 현재 지원되는 많은 [쿠버네티스 네트워킹 공급자](/docs/concepts/cluster-administration/networking/)가 네트워크폴리시를 준수한다.

쿼터와 리밋레인지는 사용자가 노드 포트나 로드 밸런싱된 서비스를 요청할 수 있는지 여부를 제어하는 데에도 사용될 수 있으며, 많은 클러스터에서 이는 해당 사용자의 애플리케이션이 클러스터 외부에서 보이는지 여부를 제어할 수 있다.

플러그인별 또는 환경별로 네트워크 규칙을 제어하는 추가 보호 기능을 사용할 수 있다. 예를 들어 노드별 방화벽, 크로스토크를 방지하기 위한 클러스터 노드의 물리적 분리 또는 고급 네트워킹 정책 등이 있다.

### 클라우드 메타데이터 API 접근 제한

클라우드 플랫폼(AWS, Azure, GCE 등)은 종종 인스턴스에 메타데이터 서비스를 로컬로 노출한다. 기본적으로 이러한 API는 인스턴스에서 실행되는 파드가 접근할 수 있으며, 해당 노드에 대한 클라우드 자격증명이나 Kubelet 자격증명과 같은 프로비저닝 데이터를 포함할 수 있다. 이러한 자격증명은 클러스터 내에서 또는 동일한 계정 하의 다른 클라우드 서비스로 권한을 상승시키는 데 사용될 수 있다.

클라우드 플랫폼에서 쿠버네티스를 실행할 때는 인스턴스 자격증명에 부여된 권한을 제한하고, [네트워크폴리시](/docs/tasks/administer-cluster/declare-network-policy/)를 사용하여 메타데이터 API에 대한 파드 접근을 제한하며, 시크릿을 전달하기 위해 프로비저닝 데이터를 사용하지 않는다.

### 파드가 접근할 수 있는 노드 제어

기본적으로 어떤 노드가 파드를 실행할 수 있는지에 대한 제한은 없다. 쿠버네티스는 [노드에 파드 배치를 제어하기 위한 풍부한 정책 집합](/docs/concepts/scheduling-eviction/assign-pod-node/)과 최종 사용자가 사용할 수 있는 [테인트 기반 파드 배치 및 축출](/docs/concepts/scheduling-eviction/taint-and-toleration/)을 제공한다. 많은 클러스터의 경우 이러한 정책을 사용하여 워크로드를 분리하는 것이 작성자가 채택하거나 도구를 통해 강제하는 관례가 될 수 있다.

관리자는 베타 어드미션 플러그인 `PodNodeSelector`를 사용하여 네임스페이스 내의 파드가 특정 노드 셀렉터를 기본값으로 하거나 요구하도록 강제할 수 있으며, 최종 사용자가 네임스페이스를 변경할 수 없다면, 이는 특정 워크로드의 모든 파드 배치를 강력하게 제한할 수 있다.

## 침해로부터 클러스터 컴포넌트 보호

이 섹션에서는 침해로부터 클러스터를 보호하기 위한 몇 가지 일반적인 패턴을 설명한다.

### etcd에 대한 접근 제한

API의 etcd 백엔드에 대한 쓰기 접근은 전체 클러스터에 대한 루트 권한 획득과 동등하며, 읽기 접근은 상당히 빠르게 권한을 상승시키는 데 사용될 수 있다. 관리자는 항상 TLS 클라이언트 인증서를 통한 상호 인증과 같이 API 서버에서 etcd 서버로의 강력한 자격증명을 사용해야 하며, API 서버만 접근할 수 있는 방화벽 뒤에 etcd 서버를 격리하는 것이 권장된다.

{{< caution >}}
클러스터 내의 다른 컴포넌트가 전체 키스페이스에 대한 읽기 또는 쓰기 접근으로 마스터 etcd 인스턴스에 접근하도록 허용하는 것은 cluster-admin 접근을 부여하는 것과 동등하다. 마스터가 아닌 컴포넌트에 대해 별도의 etcd 인스턴스를 사용하거나 etcd ACL을 사용하여 키스페이스의 하위 집합에 대한 읽기 및 쓰기 접근을 제한하는 것이 강력히 권장된다.
{{< /caution >}}

### 감사 로깅 활성화

[감사 로거](/docs/tasks/debug/debug-cluster/audit/)는 침해 발생 시 나중에 분석하기 위해 API가 수행한 작업을 기록하는 베타 기능이다. 감사 로깅을 활성화하고 감사 파일을 보안 서버에 아카이브하는 것이 권장된다.

### 알파 또는 베타 기능에 대한 접근 제한

알파 및 베타 쿠버네티스 기능은 활발한 개발 중이며 보안 취약점을 초래할 수 있는 제한 사항이나 버그가 있을 수 있다. 알파 또는 베타 기능이 제공할 수 있는 가치를 보안 태세에 대한 가능한 위험과 항상 비교 평가한다. 의심스러울 때는 사용하지 않는 기능을 비활성화한다.

### 인프라 자격증명을 자주 교체

시크릿이나 자격증명의 수명이 짧을수록 공격자가 해당 자격증명을 사용하기 어렵다. 인증서에 짧은 수명을 설정하고 교체를 자동화한다. 발급된 토큰을 얼마나 오래 사용할 수 있는지 제어할 수 있는 인증 공급자를 사용하고 가능한 경우 짧은 수명을 사용한다. 외부 통합에서 서비스어카운트 토큰을 사용하는 경우 해당 토큰을 자주 교체할 계획을 세운다. 예를 들어, 부트스트랩 단계가 완료되면 노드 설정에 사용된 부트스트랩 토큰을 취소하거나 인가를 제거해야 한다.

### 활성화하기 전에 타사 통합 검토

쿠버네티스에 대한 많은 타사 통합은 클러스터의 보안 프로필을 변경할 수 있다. 통합을 활성화할 때는 항상 익스텐션이 요청하는 권한을 검토한 후 접근을 부여한다. 예를 들어, 많은 보안 통합은 클러스터의 모든 시크릿을 볼 수 있는 접근을 요청할 수 있으며, 이는 사실상 해당 컴포넌트를 cluster-admin으로 만드는 것이다. 의심스러울 때는 가능한 경우 통합이 단일 네임스페이스에서 작동하도록 제한한다.

파드를 생성하는 컴포넌트는 `kube-system` 네임스페이스와 같은 네임스페이스 내에서 생성할 수 있는 경우 예상치 못하게 강력할 수 있다. 왜냐하면 해당 파드는 서비스어카운트 시크릿에 접근하거나 해당 서비스어카운트가 관대한 [PodSecurityPolicies](/docs/concepts/security/pod-security-policy/)에 대한 접근 권한을 부여받은 경우 상승된 권한으로 실행될 수 있기 때문이다.

[파드 시큐리티 어드미션](/docs/concepts/security/pod-security-admission/)을 사용하고 모든 컴포넌트가 특권을 가진 파드를 허용하는 네임스페이스 내에서 파드를 생성하도록 허용하는 경우, 해당 파드는 컨테이너에서 탈출하여 이 확장된 접근을 사용하여 권한을 상승시킬 수 있다.

신뢰할 수 없는 컴포넌트가 시스템 네임스페이스(`kube-`로 시작하는 이름)나 해당 접근 권한이 권한 상승 가능성을 허용하는 네임스페이스에서 파드를 생성하도록 허용해서는 안 된다.

### 저장 중인 시크릿 암호화

일반적으로 etcd 데이터베이스는 쿠버네티스 API를 통해 접근할 수 있는 모든 정보를 포함하며, 공격자에게 클러스터 상태에 대한 상당한 가시성을 부여할 수 있다. 잘 검토된 백업 및 암호화 솔루션을 사용하여 항상 백업을 암호화하고, 가능한 경우 전체 디스크 암호화 사용을 고려한다.

쿠버네티스는 쿠버네티스 API의 정보에 대한 선택적 [저장 중 암호화](/docs/tasks/administer-cluster/encrypt-data/)를 지원한다. 이를 통해 쿠버네티스가 오브젝트(예: `Secret` 또는 `ConfigMap` 오브젝트)에 대한 데이터를 저장할 때 API 서버가 오브젝트의 암호화된 표현을 작성하도록 할 수 있다. 이러한 암호화는 etcd 백업 데이터에 접근할 수 있는 사람도 해당 오브젝트의 내용을 볼 수 없음을 의미한다. 쿠버네티스 {{< skew currentVersion >}}에서는 사용자 정의 리소스도 암호화할 수 있다. CustomResourceDefinitions에 정의된 익스텐션 API에 대한 저장 중 암호화는 v1.26 릴리스의 일부로 쿠버네티스에 추가되었다.

### 보안 업데이트에 대한 알림 수신 및 취약점 보고

보안 공지에 대한 이메일을 받으려면 [kubernetes-announce](https://groups.google.com/forum/#!forum/kubernetes-announce) 그룹에 가입한다. 취약점 보고 방법에 대한 자세한 내용은 [보안 보고](/docs/reference/issues-security/security/) 페이지를 참조한다.

## 다음 내용

- 추가 쿠버네티스 보안 가이드는 [시큐리티 체크리스트](/docs/concepts/security/security-checklist/)를 참조한다.
- [Seccomp 노드 레퍼런스](/docs/reference/node/seccomp/)