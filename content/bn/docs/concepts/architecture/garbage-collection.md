---
title: গার্বেজ কালেকশন
content_type: concept
weight: 70
---

<!-- overview -->
{{<glossary_definition term_id="garbage-collection" length="short">}}
গার্বেজ কালেকশন সিস্টেমকে নিম্নলিখিত রিসোর্সগুলি পরিষ্কার করতে দেয়:

* [সমাপ্ত পডগুলি](/bn/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)
* [সম্পন্ন হওয়া জবগুলি](/bn/docs/concepts/workloads/controllers/ttlafterfinished/)
* [মালিক রেফারেন্স ছাড়া অবজেক্ট](#owners-dependents)
* [অব্যবহৃত কন্টেইনার এবং কন্টেইনার ইমেজগুলি](#containers-images)
* [ডায়নামিকভাবে প্রস্তুতকৃত, StorageClass এর জন্য পুনরুদ্ধার নীতির সাথে Delete করা PV](/bn/docs/concepts/storage/persistent-volumes/#delete)
* [ব্যর্থ অথবা মেয়াদ উত্তীর্ণ সার্টিফিকেট সাইনিং রিকোয়েস্ট (CSR)](/bn/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process)
* {{<glossary_tooltip text="নোড" term_id="node">}} নিম্নলিখিত পরিস্থিতিতে মুছে ফেলা :
  * যখন ক্লাস্টারটি [ক্লাউড কন্ট্রোলার ম্যানেজার](/bn/docs/concepts/architecture/cloud-controller/) এর মাধ্যমে ক্লাউডে চালানো হয়।
  * যখন ক্লাস্টারটি ক্লাউড কন্ট্রোলার ম্যানেজারের মতো প্লাগইন ব্যবহার করে লোকাল পরিবেশে চলে।
* [নোড লিজ অবজেক্ট](/bn/docs/concepts/architecture/nodes/#heartbeats)

## মালিক ও নির্ভরশীল {#owners-dependents}

Kubernetes এ অনেক অবজেক্ট একে অপরের সাথে [**মালিকানাধীন রেফারেন্স**](/bn/docs/concepts/overview/working-with-objects/owners-dependents/) এর মাধ্যমে সংযুক্ত থাকে। মালিকানাধীন রেফারেন্স (Owner Reference) কন্ট্রোল প্লেনকে জানায় কোন অবজেক্ট অন্য অবজেক্টের উপর নির্ভরশীল। Kubernetes মালিকানাধীন রেফারেন্স ব্যবহার করে কন্ট্রোল প্লেন এবং অন্যান্য API ক্লায়েন্টদের একটি অবজেক্ট মুছে ফেলার সময় সংশ্লিষ্ট রিসোর্সগুলি পরিষ্কার করার একটি সুযোগ প্রদান করে। বেশিরভাগ পরিস্থিতিতে Kubernetes স্বয়ংক্রিয়ভাবে মালিকানাধীন রেফারেন্স পরিচালনা করে।

মালিকানাধীন সম্পর্ক এবং কিছু রিসোর্সের জন্য ব্যবহার করা [ট্যাগ এবং সিলেক্টর](/bn/docs/concepts/overview/working-with-objects/labels/) এর মধ্যে পার্থক্য রয়েছে। উদাহরণস্বরূপ, একটি `EndpointSlice` অবজেক্ট তৈরি করা একটি {{<glossary_tooltip text="সার্ভিস" term_id="service">}} কল্পনা করুন। সার্ভিস ট্যাগগুলি ব্যবহার করে কন্ট্রোল প্লেনকে অনুমোদিত `EndpointSlice` অবজেক্টগুলি সনাক্ত করতে দেয়। ট্যাগের পাশাপাশি, প্রতিটি সার্ভিস দ্বারা পরিচালিত `EndpointSlice` অবজেক্টের একটি মালিকানাধীন রেফারেন্স থাকবে যা সংশ্লিষ্ট সার্ভিসের সাথে সম্পর্কিত।

{{< note >}}
ক্রস-নেমস্পেস মালিকানা রেফারেন্স ডিজাইন দ্বারা নিষিদ্ধ। নেমস্পেস নির্ভরশীলরা ক্লাস্টার-স্কোপড অথবা নেমস্পেসড মালিকদের নির্দিষ্ট করতে পারে। একটি নেমস্পেসড মালিক **অবশ্যই** নির্ভরশীলের সাথে একই নেমস্পেসে থাকতে হবে। যদি এটি না থাকে, তবে মালিকানা রেফারেন্সটি অনুপস্থিত হিসেবে বিবেচিত হয়, এবং মালিকদের সমস্ত অবস্থিতি যাচাই করা হলে নির্ভরশীলটি মুছে ফেলা হবে। 

ক্লাস্টার-স্কোপড নির্ভরশীলরা শুধুমাত্র ক্লাস্টার-স্কোপড মালিকদের উল্লেখ করতে পারে। v1.20+ এ, যদি একটি ক্লাস্টার-স্কোপড নির্ভরশীল একটি নেমস্পেসড প্রকারকে মালিক হিসেবে নির্দিষ্ট করে, তবে এটি একটি অযোগ্য মালিকানা রেফারেন্স হিসেবে বিবেচিত হয়, এবং এটি গার্বেজ কালেক্ট করা যাবে না।

v1.20+ এ, যদি গার্বেজ কালেক্টর একটি অবৈধ ক্রস-নেমস্পেস `ownerReference` সনাক্ত করে, অথবা একটি ক্লাস্টার-স্কোপড নির্ভরশীল একটি নেমস্পেসড প্রকারের মালিককে রেফারেন্স করে, তবে একটি সতর্কতা ইভেন্ট যার কারণে `OwnerRefInvalidNamespace` এবং একটি `involvedObject` থাকে যা অবৈধ নির্ভরশীল হিসেবে রিপোর্ট হয়। এধরনের ইভেন্ট দেখতে আপনি চালাতে পারেন kubectl get events `kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace`।
{{< /note >}}

## ক্যাসকেডিং ডিলিশন {#cascading-deletion}

Kubernetes  সেসব অবজেক্ট পরীক্ষা করে এবং মুছে ফেলে, যেগুলোর আর মালিকানা রেফারেন্স নেই, যেমন `ReplicaSet` মুছে ফেললে বাকি থাকা পডগুলো। যখন আপনি একটি অবজেক্ট মুছে ফেলেন, তখন আপনি নিয়ন্ত্রণ করতে পারেন যে কুবার্নেটিস ঐ অবজেক্টের ডিপেনডেন্টসগুলো স্বয়ংক্রিয়ভাবে মুছে ফেলবে কিনা, এই প্রক্রিয়াকে বলা হয় *কাসকেডিং ডিলিশন*। কাসকেডিং ডিলিশনের দুটি ধরনের থাকে, যা নিচে ব্যাখ্যা করা হয়েছে:

* ফরগ্রাউন্ড ক্যাসকেডিং ডিলিশন
* ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশন

আপনি গার্বেজ কালেকশন কিভাবে এবং কখন মালিকানা রেফারেন্সসমূহের মাধ্যমে রিসোর্স মুছে ফেলে Kubernetes {{<glossary_tooltip text="Finalizers" term_id="finalizer">}} ব্যবহার করে নিয়ন্ত্রণ করতে পারেন।


### ফরগ্রাউন্ড ক্যাসকেডিং ডিলিশন {#foreground-deletion}

ফরগ্রাউন্ড ক্যাসকেডিং ডিলিশনে, আপনি যে মালিকানা অবজেক্টটি মুছে ফেলছেন সেটি প্রথমে একটি *ডিলিশন ইন প্রগ্রেস* অবস্থায় চলে যায়। এই অবস্থায়, মালিকানা অবজেক্টের সাথে নিম্নলিখিত ঘটনা ঘটে:

* Kubernetes API সার্ভার অবজেক্টের `metadata.deletionTimestamp` ক্ষেত্রটিকে সেই সময়ে সেট করে যখন অবজেক্টটি মুছে ফেলার জন্য চিহ্নিত করা হয়।
* Kubernetes API সার্ভার এছাড়াও `metadata.finalizers` ক্ষেত্রটিকে `foregroundDeletion` এ সেট করে।
* অবজেক্টটি Kubernetes API-এর মাধ্যমে দৃশ্যমান থাকে যতক্ষণ না মুছে ফেলার প্রক্রিয়া সম্পূর্ণ হয়।

মালিকানা অবজেক্টটি ডিলিশন ইন প্রগ্রেস অবস্থায় চলে গেলে, কন্ট্রোলার নির্ভরশীল অবজেক্টগুলি মুছে ফেলে। সমস্ত নির্ভরশীল অবজেক্ট মুছে ফেলার পর কন্ট্রোলার মালিকানা অবজেক্টটি মুছে ফেলবে। এই মুহূর্তে, অবজেক্টটি Kubernetes API-এ আর দৃশ্যমান থাকে না।

ফরগ্রাউন্ড ক্যাসকেডিং ডিলিশন চলাকালীন, একমাত্র নির্ভরশীলরা যারা মালিক মুছে ফেলার প্রতিবন্ধকতা সৃষ্টি করে তা হল যাদের `ownerReference.blockOwnerDeletion=true` ক্ষেত্র রয়েছে। আরো জানার জন্য [ফরগ্রাউন্ড ক্যাসকেডিং ডিলিশন ব্যবহার করুন।](/bn/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion)

### ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশন {#background-deletion}

ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশনে, Kubernetes API সার্ভার অবজেক্টটি অবিলম্বে মুছে ফেলে এবং কন্ট্রোলার ব্যাকগ্রাউন্ডে নির্ভরশীল অবজেক্টগুলি পরিষ্কার করে। স্বাভাবিকভাবে, Kubernetes ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশন ব্যবহার করে যতক্ষণ না আপনি ম্যানুয়ালি ফরগ্রাউন্ড ডিলিশন ব্যবহার করেন বা নির্ভরশীল অবজেক্টগুলি অরফান না করেন।

আরো জানার জন্য [ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশন ব্যবহার করুন।](/bn/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion)
to learn more.

### অরফানড ডিপেনডেন্টস  {#orphaned-dependents}

যখন কুবার্নেটিস একটি মালিক অবজেক্ট মুছে ফেলে, তখন বাকি থাকা ডিপেনডেন্টসগুলোকে অরফান অবজেক্ট বলা হয়। ডিফল্টভাবে, কুবার্নেটিস ডিপেনডেন্ট অবজেক্টগুলো মুছে ফেলে। এই আচরণটি কিভাবে ওভাররাইড করবেন তা জানতে, দেখুন [মালিক অবজেক্ট মুছে ফেলুন এবং অরফান ডিপেনডেন্টস](/bn/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy)

## অব্যবহৃত কনটেইনার এবং চিত্রগুলির গার্বেজ কালেকশন {#containers-images}

{{<glossary_tooltip text="kubelet" term_id="kubelet">}} প্রতি দুই মিনিটে অব্যবহৃত চিত্রগুলির গার্বেজ কালেকশন এবং প্রতি মিনিটে অব্যবহৃত কনটেইনারগুলির গার্বেজ কালেকশন করে। বাহ্যিক গার্বেজ কালেকশন টুলস ব্যবহার থেকে বিরত থাকুন, কারণ এটি কিউবিলেটের আচরণ ভেঙে ফেলতে পারে এবং এমন কনটেইনারগুলি মুছে ফেলতে পারে যা থাকার উচিত।
অব্যবহৃত কনটেইনার এবং চিত্রগুলির গার্বেজ কালেকশন জন্য বিকল্প কনফিগার করতে, কিউবিলেটটি একটি [কনফিগারেশন ফাইল](/bn/docs/tasks/administer-cluster/kubelet-config-file/) ব্যবহার করে কনফিগার করুন এবং গার্বেজ কালেকশন সম্পর্কিত প্যারামিটারগুলি পরিবর্তন করুন [`KubeletConfiguration`](/bn/docs/reference/config-api/kubelet-config.v1beta1/)
রিসোর্সটি ব্যবহার করে।

### কনটেইনার চিত্রের জীবনচক্র {#container-image-lifecycle}

কুবেরনেটিস তার *চিত্র ম্যানেজার（Image Manager)* এর মাধ্যমে সমস্ত চিত্রের জীবনচক্র পরিচালনা করে, যা কিউবিলেটের অংশ এবং {{< glossary_tooltip text="cadvisor" term_id="cadvisor" >}}এর সহযোগিতায়. Kubelet
গার্বেজ কালেকশন সিদ্ধান্ত নেবার সময় নিম্নলিখিত ডিস্ক ব্যবহার সীমা বিবেচনা করে:

* `HighThresholdPercent`
* `LowThresholdPercent`

ডিস্ক ব্যবহারের পরিমাণ নির্ধারিত `HighThresholdPercent` মানের চেয়ে বেশি হলে গার্বেজ কালেকশন ট্রিগার হয়, যা চিত্র (ইমেজ) মুছে ফেলে। এটি সর্বশেষ ব্যবহারের সময়ের ভিত্তিতে প্রাচীনতম চিত্র থেকে শুরু করে মুছে ফেলা হয়। Kubelet চিত্র মুছতে থাকে যতক্ষণ না ডিস্ক ব্যবহারের পরিমাণ `LowThresholdPercent` মানে নেমে আসে।

#### অব্যবহৃত কন্টেইনার ইমেজগুলোর জন্য গারবেজ কালেকশন {#image-maximum-age-gc}

{{< feature-state feature_gate_name="ImageMaximumGCAge" >}}

একটি বিটা ফিচার হিসেবে, আপনি নির্দিষ্ট করতে পারেন যে একটি স্থানীয় ইমেজ সর্বাধিক কতক্ষণ অব্যবহৃত থাকতে পারবে, ডিস্ক ব্যবহারের পরিমাণ নির্বিশেষে। এটি একটি  kubelet সেটিং, যা প্রতিটি নোডের জন্য কনফিগার করা যায়।

এই সেটিং কনফিগার করতে, কুবলেটের জন্য `ImageMaximumGCAge`
[ফিচার গেট](/bn/docs/reference/command-line-tools-reference/feature-gates/) সক্ষম করুন এবং kubelet কনফিগারেশন ফাইলে `imageMaximumGCAge` ফিল্ডের জন্য একটি মান সেট করুন।

মানটি কুবার্নেটিসের সময়কাল (duration) হিসেবে নির্ধারিত হয়। Kubelet কনফিগারেশন ফাইলে `imageMaximumGCAge` ফিল্ডের জন্য বৈধ সময় এককগুলি হলো:

- "ns" ন্যানোসেকেন্ডের জন্য
- "us" বা "µs" মাইক্রোসেকেন্ডের জন্য
- "ms" মিলিসেকেন্ডের জন্য
- "s" সেকেন্ডের জন্য
- "m" মিনিটের জন্য
- "h" ঘন্টার জন্য

উদাহরণস্বরূপ, আপনি যদি `imageMaximumGCAge` ফিল্ডের মান `12h 45m` সেট করেন, তাহলে এর অর্থ হবে ১২ ঘন্টা এবং ৪৫ মিনিট।

{{< note >}}
এই ফিচারটি কিউবিলেট (kubelet) পুনরায় চালু হওয়ার (restart) পরেও ইমেজ ব্যবহারের তথ্য সংরক্ষণ করে না। যদি কিউবিলেট রিস্টার্ট হয়, তাহলে ট্র্যাক করা ইমেজের বয়স পুনরায় শূন্যে সেট হয়, যার ফলে কিউবিলেটকে সম্পূর্ণ `imageMaximumGCAge` সময় অপেক্ষা করতে হয়, এরপর ইমেজের বয়সের ভিত্তিতে গারবেজ কালেকশনের জন্য যোগ্যতা নির্ধারণ করা হয়।
{{< /note>}}

### কন্টেইনার গারবেজ কালেকশন {#container-image-garbage-collection}

কিউবিলেট (kubelet) অব্যবহৃত কন্টেইনারগুলো গারবেজ কালেকশন করে নিম্নলিখিত ভ্যারিয়েবলগুলির ভিত্তিতে, যেগুলো আপনি সংজ্ঞায়িত করতে পারেন:

* MinAge: এটি হল সেই ন্যূনতম বয়স, যার পরে কিউবিলেট একটি কন্টেইনার গারবেজ কালেক্ট করতে পারে। এটি নিষ্ক্রিয় করতে `0` এ সেট করতে হবে।
* MaxPerPodContainer: প্রতিটি পডের জন্য মৃত কন্টেইনারের সর্বাধিক সংখ্যা। এটি নিষ্ক্রিয় করতে  ` 0` এ সেট করতে হবে।
* MaxContainers: ক্লাস্টারের জন্য মৃত কন্টেইনারের সর্বাধিক সংখ্যা। এটি নিষ্ক্রিয় করতে কম ` 0` এ সেট করতে হবে।

এই ভ্যারিয়েবলগুলির পাশাপাশি, কিউবিলেট অজানা এবং মুছে ফেলা কন্টেইনারগুলিকেও গারবেজ কালেক্ট করে, সাধারণত সবচেয়ে পুরনো কন্টেইনারগুলো প্রথমে মুছে ফেলে।

`MaxPerPodContaine`r এবং `MaxContainers` একে অপরের সাথে সংঘর্ষে পড়তে পারে এমন পরিস্থিতিতে, যেখানে একটি পডে সর্বাধিক কন্টেইনার সংখ্যা (MaxPerPodContainer) ক্লাস্টারের অনুমোদিত মোট মৃত কন্টেইনারের সংখ্যা (MaxContainers) থেকে বেশি হতে পারে। এই পরিস্থিতিতে, কিউবিলেট সংঘর্ষ সমাধান করতে MaxPerPodContainer এর মান সমন্বয় করে। একটি খারাপ পরিস্থিতি হতে পারে MaxPerPodContainer কে `1` এ নামিয়ে আনা এবং সবচেয়ে পুরনো কন্টেইনারগুলো মুছে ফেলা। এছাড়াও, যে পডগুলি মুছে ফেলা হয়েছে, তাদের মালিকানাধীন কন্টেইনারগুলো MinAge এর চেয়ে পুরনো হলে মুছে ফেলা হয়।

{{<note>}}
কিউবিলেট (kubelet) শুধুমাত্র সেই কন্টেইনারগুলো গারবেজ কালেকশন করে, যেগুলোর এটি পরিচালনা করে।
{{</note>}}

## গারবেজ কালেকশন কনফিগার করা {#configuring-gc}

আপনি যেসব কন্ট্রোলার রিসোর্স পরিচালনা করছে, তাদের জন্য নির্দিষ্ট অপশন কনফিগার করে রিসোর্সের গারবেজ কালেকশন টিউন করতে পারেন। নিম্নলিখিত পৃষ্ঠাগুলো আপনাকে গারবেজ কালেকশন কনফিগার করতে সাহায্য করবে:

* [কুবার্নেটিস অবজেক্টের কাসকেডিং ডিলিশন কনফিগার করা](/bn/docs/tasks/administer-cluster/use-cascading-deletion/)
* [শেষ হওয়া জবগুলোর ক্লিনআপ কনফিগার করা](/bn/docs/concepts/workloads/controllers/ttlafterfinished/)
  
## {{% heading "whatsnext" %}}

* কুবার্নেটিস অবজেক্টের [মালিকানা সম্পর্কে আরও জানুন.](/bn/docs/concepts/overview/working-with-objects/owners-dependents/).
* কুবার্নেটিসের [ফাইনালাইজার সম্পর্কে আরও জানুন.](/bn/docs/concepts/overview/working-with-objects/finalizers/).
* শেষ হওয়া জবগুলো ক্লিনআপ করার জন্য [TTL কন্ট্রোলার](/bn/docs/concepts/workloads/controllers/ttlafterfinished/) সম্পর্কে জানুন।
