---
title: গার্বেজ কালেকশন
content_type: concept
weight: 70
---

<!-- overview -->
{{<glossary_definition term_id="garbage-collection" length="short">}}
গার্বেজ কালেকশন সিস্টেমকে নিম্নলিখিত রিসোর্সগুলি পরিষ্কার করতে দেয়:

* [সমাপ্ত পডগুলি](/en/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)
* [সম্পন্ন হওয়া জবগুলি](/en/docs/concepts/workloads/controllers/ttlafterfinished/)
* [মালিক রেফারেন্স ছাড়া অবজেক্ট](#owners-dependents)
* [অব্যবহৃত কন্টেইনার এবং কন্টেইনার ইমেজগুলি](#containers-images)
* [ডায়নামিকভাবে প্রস্তুতকৃত, StorageClass এর জন্য পুনরুদ্ধার নীতির সাথে Delete করা PV](/en/docs/concepts/storage/persistent-volumes/#delete)
* [ব্যর্থ অথবা মেয়াদ উত্তীর্ণ সার্টিফিকেট সাইনিং রিকোয়েস্ট (CSR)](/en/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process)
* {{<glossary_tooltip text="নোড" term_id="node">}} নিম্নলিখিত পরিস্থিতিতে মুছে ফেলা :
  * যখন ক্লাস্টারটি [ক্লাউড কন্ট্রোলার ম্যানেজার](/en/docs/concepts/architecture/cloud-controller/) এর মাধ্যমে ক্লাউডে চালানো হয়।
  * যখন ক্লাস্টারটি ক্লাউড কন্ট্রোলার ম্যানেজারের মতো প্লাগইন ব্যবহার করে লোকাল পরিবেশে
    চলে।
* [নোড লিজ অবজেক্ট](/en/docs/concepts/architecture/nodes/#heartbeats)

## মালিক ও নির্ভরশীল {#owners-dependents}

Kubernetes এ অনেক অবজেক্ট একে অপরের সাথে [**মালিকানাধীন রেফারেন্স**](/en/docs/concepts/overview/working-with-objects/owners-dependents/) এর মাধ্যমে সংযুক্ত থাকে। 
মালিকানাধীন রেফারেন্স (Owner Reference) কন্ট্রোল প্লেনকে জানায় কোন অবজেক্ট অন্য অবজেক্টের উপর নির্ভরশীল।
Kubernetes মালিকানাধীন রেফারেন্স ব্যবহার করে কন্ট্রোল প্লেন এবং অন্যান্য API ক্লায়েন্টদের একটি অবজেক্ট মুছে ফেলার 
সময় সংশ্লিষ্ট রিসোর্সগুলি পরিষ্কার করার একটি সুযোগ প্রদান করে। বেশিরভাগ পরিস্থিতিতে Kubernetes স্বয়ংক্রিয়ভাবে 
মালিকানাধীন রেফারেন্স পরিচালনা করে।

মালিকানাধীন সম্পর্ক এবং কিছু রিসোর্সের জন্য ব্যবহার করা 
[ট্যাগ এবং সিলেক্টর](/en/docs/concepts/overview/working-with-objects/labels/) এর মধ্যে পার্থক্য রয়েছে।
উদাহরণস্বরূপ, একটি `EndpointSlice` অবজেক্ট তৈরি করা একটি {{<glossary_tooltip text="সার্ভিস" term_id="service">}}
কল্পনা করুন। সার্ভিস ট্যাগগুলি ব্যবহার করে কন্ট্রোল প্লেনকে অনুমোদিত `EndpointSlice` অবজেক্টগুলি সনাক্ত করতে দেয়।
ট্যাগের পাশাপাশি, প্রতিটি সার্ভিস দ্বারা পরিচালিত `EndpointSlice` অবজেক্টের একটি মালিকানাধীন রেফারেন্স থাকবে যা
সংশ্লিষ্ট সার্ভিসের সাথে সম্পর্কিত।



{{< note >}}
ক্রস-নেমস্পেস মালিকানা রেফারেন্স ডিজাইন দ্বারা নিষিদ্ধ।
নেমস্পেস নির্ভরশীলরা ক্লাস্টার-স্কোপড অথবা নেমস্পেসড মালিকদের নির্দিষ্ট করতে পারে।
একটি নেমস্পেসড মালিক **অবশ্যই** নির্ভরশীলের সাথে একই নেমস্পেসে থাকতে হবে।
যদি এটি না থাকে, তবে মালিকানা রেফারেন্সটি অনুপস্থিত হিসেবে বিবেচিত হয়, এবং মালিকদের সমস্ত
অবস্থিতি যাচাই করা হলে নির্ভরশীলটি মুছে ফেলা হবে।

ক্লাস্টার-স্কোপড নির্ভরশীলরা শুধুমাত্র ক্লাস্টার-স্কোপড মালিকদের উল্লেখ করতে পারে। v1.20+ এ, 
যদি একটি ক্লাস্টার-স্কোপড নির্ভরশীল একটি নেমস্পেসড প্রকারকে মালিক হিসেবে নির্দিষ্ট করে, 
তবে এটি একটি অযোগ্য মালিকানা রেফারেন্স হিসেবে বিবেচিত হয়, এবং এটি গার্বেজ কালেক্ট করা যাবে না।

v1.20+ এ, যদি গার্বেজ কালেক্টর একটি অবৈধ ক্রস-নেমস্পেস `ownerReference` সনাক্ত করে, 
অথবা একটি ক্লাস্টার-স্কোপড নির্ভরশীল একটি নেমস্পেসড প্রকারের মালিককে রেফারেন্স করে, তবে একটি সতর্কতা ইভেন্ট
যার কারণে `OwnerRefInvalidNamespace` এবং একটি `involvedObject` থাকে যা অবৈধ নির্ভরশীল হিসেবে রিপোর্ট হয়। 
এধরনের ইভেন্ট দেখতে আপনি চালাতে পারেন 
kubectl get events `kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace`।
{{< /note >}}

## ক্যাসকেডিং ডিলিশন {#cascading-deletion}

Kubernetes  সেসব অবজেক্ট পরীক্ষা করে এবং মুছে ফেলে, যেগুলোর আর মালিকানা রেফারেন্স নেই,
যেমন `ReplicaSet` মুছে ফেললে বাকি থাকা পডগুলো। যখন আপনি একটি অবজেক্ট মুছে ফেলেন,
তখন আপনি নিয়ন্ত্রণ করতে পারেন যে কুবার্নেটিস ঐ অবজেক্টের ডিপেনডেন্টসগুলো স্বয়ংক্রিয়ভাবে
মুছে ফেলবে কিনা, এই প্রক্রিয়াকে বলা হয় *কাসকেডিং ডিলিশন*। 
কাসকেডিং ডিলিশনের দুটি ধরনের থাকে, যা নিচে ব্যাখ্যা করা হয়েছে:

* ফরগ্রাউন্ড ক্যাসকেডিং ডিলিশন
* ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশন

আপনি গার্বেজ কালেকশন কিভাবে এবং কখন মালিকানা রেফারেন্সসমূহের মাধ্যমে রিসোর্স মুছে ফেল
ে Kubernetes {{<glossary_tooltip text="Finalizers" term_id="finalizer">}} ব্যবহার করে নিয়ন্ত্রণ করতে পারেন।

### ফরগ্রাউন্ড ক্যাসকেডিং ডিলিশন {#foreground-deletion}

ফরগ্রাউন্ড ক্যাসকেডিং ডিলিশনে, আপনি যে মালিকানা অবজেক্টটি মুছে ফেলছেন সেটি প্রথমে
একটি *ডিলিশন ইন প্রগ্রেস* অবস্থায় চলে যায়। এই অবস্থায়, মালিকানা অবজেক্টের সাথে 
নিম্নলিখিত ঘটনা ঘটে:

* Kubernetes API সার্ভার অবজেক্টের `metadata.deletionTimestamp` ক্ষেত্রটিকে সেই সময়ে সেট করে যখন
  অবজেক্টটি মুছে ফেলার জন্য চিহ্নিত করা হয়।
* Kubernetes API সার্ভার এছাড়াও `metadata.finalizers` ক্ষেত্রটিকে
  `foregroundDeletion` এ সেট করে।
* অবজেক্টটি Kubernetes API-এর মাধ্যমে দৃশ্যমান থাকে যতক্ষণ না মুছে ফেলার প্রক্রিয়া
  সম্পূর্ণ হয়।

মালিকানা অবজেক্টটি ডিলিশন ইন প্রগ্রেস অবস্থায় চলে গেলে, কন্ট্রোলার নির্ভরশীল অবজেক্টগুলি মুছে ফেলে। 
সমস্ত নির্ভরশীল অবজেক্ট মুছে ফেলার পর কন্ট্রোলার মালিকানা অবজেক্টটি মুছে ফেলবে।
এই মুহূর্তে, অবজেক্টটি 
Kubernetes API-এ আর দৃশ্যমান থাকে না।

ফোরগ্রাউন্ড ক্যাসকেডিং ডিলিশনের সময়, শুধুমাত্র সেই ডিপেনডেন্ট অবজেক্টগুলো
মালিক (Owner) ডিলিশন ব্লক করে, যেগুলোর
`ownerReference.blockOwnerDeletion=true` ফিল্ড সেট করা আছে এবং যেগুলো
গারবেজ কালেকশন কন্ট্রোলারের ক্যাশে সংরক্ষিত রয়েছে। গারবেজ কালেকশন
কন্ট্রোলারের ক্যাশে এমন অবজেক্ট থাকতে নাও পারে, যেগুলোর রিসোর্স টাইপ
সফলভাবে তালিকাভুক্ত (listed) বা পর্যবেক্ষণ (watched) করা যায় না, অথবা যেগুলো
মালিক অবজেক্ট মুছে ফেলার সঙ্গে সঙ্গে তৈরি হয়। বিস্তারিত জানতে দেখুন: [ফরগ্রাউন্ড ক্যাসকেডিং ডিলিশন ব্যবহার করুন।](/en/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion)

### ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশন {#background-deletion}

ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশনের ক্ষেত্রে, কুবার্নেটিস API সার্ভার মালিক (Owner)
অবজেক্টটি সঙ্গে সঙ্গে মুছে ফেলে এবং গারবেজ কালেকশন কন্ট্রোলার (ডিফল্ট বা কাস্টম) ব্যাকগ্রাউন্ডে ডিপেনডেন্ট অবজেক্টগুলোর পরিষ্কার-পরিচ্ছন্নতার কাজ সম্পন্ন করে। 
যদি একটি ফাইনালাইজার (Finalizer) থাকে, তবে এটি নিশ্চিত করে যে সমস্ত 
প্রয়োজনীয় ক্লিন-আপ কাজ শেষ না হওয়া পর্যন্ত অবজেক্টগুলো মুছে ফেলা হবে না।
ডিফল্টভাবে, কুবার্নেটিস ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশন ব্যবহার করে, যদি না আপনি ম্যানুয়ালি 
ফোরগ্রাউন্ড ডিলিশন ব্যবহার করেন বা ডিপেনডেন্ট অবজেক্টগুলোকে অনাথ (Orphan) করে রাখার সিদ্ধান্ত নেন।

আরও জানতে [ব্যাকগ্রাউন্ড ক্যাসকেডিং ডিলিশন ব্যবহার করুন।](/en/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion)
দেখুন।

### অরফানড ডিপেনডেন্টস  {#orphaned-dependents}

যখন কুবার্নেটিস একটি মালিক অবজেক্ট মুছে ফেলে, তখন বাকি থাকা ডিপেনডেন্টসগুলোকে অরফান অবজেক্ট বলা হয়।
ডিফল্টভাবে, কুবার্নেটিস ডিপেনডেন্ট অবজেক্টগুলো মুছে ফেলে।
এই আচরণটি কিভাবে ওভাররাইড করবেন তা জানতে, দেখুন [মালিক অবজেক্ট মুছে ফেলুন এবং অরফান ডিপেনডেন্টস](/en/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy)

## অব্যবহৃত কনটেইনার এবং চিত্রগুলির গার্বেজ কালেকশন {#containers-images}

{{<glossary_tooltip text="kubelet" term_id="kubelet">}} প্রতি দুই মিনিটে অব্যবহৃত চিত্রগুলির
গার্বেজ কালেকশনএবং প্রতি মিনিটে অব্যবহৃত কনটেইনারগুলির গার্বেজ কালেকশন করে। বাহ্যিক গার্বেজ 
কালেকশন টুলস ব্যবহার থেকে বিরতথাকুন,কারণ এটি কিউবিলেটের আচরণ ভেঙে ফেলতে পারে এবং এমন 
কনটেইনারগুলি মুছে ফেলতে পারে যা থাকার উচিত।

অব্যবহৃত কনটেইনার এবং চিত্রগুলির গার্বেজ কালেকশন জন্য বিকল্প কনফিগার করতে,
কিউবিলেটটি একটি [কনফিগারেশন ফাইল](/en/docs/tasks/administer-cluster/kubelet-config-file/) 
ব্যবহার করে কনফিগার করুন এবং গার্বেজ কালেকশন সম্পর্কিত প্যারামিটারগুলি পরিবর্তন করুন
[`KubeletConfiguration`](/en/docs/reference/config-api/kubelet-config.v1beta1/)
রিসোর্সটি ব্যবহার করে।

### কনটেইনার চিত্রের জীবনচক্র {#container-image-lifecycle}

কুবেরনেটিস তার *চিত্র ম্যানেজার（Image Manager)*
এর মাধ্যমে সমস্ত চিত্রের জীবনচক্র পরিচালনা করে,
যা কিউবিলেটের অংশ এবং {{< glossary_tooltip text="cadvisor" term_id="cadvisor" >}} 
এর সহযোগিতায়. Kubelet গার্বেজ কালেকশন সিদ্ধান্ত নেবার সময় নিম্নলিখিত ডিস্ক ব্যবহার সীমা 
বিবেচনা করে:

* `HighThresholdPercent`
* `LowThresholdPercent`

নির্ধারিত `HighThresholdPercent` মানের চেয়ে ডিস্ক ব্যবহারের পরিমাণ বেশি হলে
গারবেজ কালেকশন প্রক্রিয়া শুরু হয়, যা সর্বশেষ ব্যবহারের সময় অনুযায়ী
ইমেজগুলো মুছে ফেলে, প্রাচীনতম থেকে শুরু করে। কিউবলেট (kubelet) ইমেজ 
মুছতে থাকে যতক্ষণ না ডিস্ক ব্যবহারের পরিমাণ `LowThresholdPercent` মানে পৌঁছে।

#### অব্যবহৃত কন্টেইনার ইমেজগুলোর জন্য গারবেজ কালেকশন {#image-maximum-age-gc}

{{< feature-state feature_gate_name="ImageMaximumGCAge" >}}

একটি বিটা ফিচার হিসেবে, আপনি নির্দিষ্ট করতে পারেন যে একটি স্থানীয় ইমেজ সর্বাধিক কতক্ষণ অব্যবহৃত থাকতে পারবে, 
ডিস্ক ব্যবহারের পরিমাণ নির্বিশেষে। এটি একটি kubelet সেটিং, যা প্রতিটি নোডের জন্য কনফিগার করা যায়।

এই সেটিং কনফিগার করতে হলে, কিউবলেট কনফিগারেশন ফাইলে
`imageMaximumGCAge` ফিল্ডের জন্য একটি মান নির্ধারণ করতে হবে।

মানটি Kubernetes-এর {{< glossary_tooltip text="সময়কাল" term_id="duration" >}} হিসেবে নির্ধারিত হয়।
আরও বিস্তারিত জানতে [সময়কাল](/docs/reference/glossary/?all=true#term-duration) 
glossary দেখুন।

উদাহরণস্বরূপ, আপনি যদি `imageMaximumGCAge` ফিল্ডের মান `12h 45m` সেট করেন,
তাহলে এর অর্থ হবে ১২ ঘন্টা এবং ৪৫ মিনিট।

{{< note >}}
এই ফিচারটি কিউবিলেট (kubelet) পুনরায় চালু হওয়ার (restart) পরেও ইমেজ ব্যবহারের তথ্য সংরক্ষণ করে না। 
যদি কিউবিলেট রিস্টার্ট হয়, তাহলে ট্র্যাক করা ইমেজের বয়স পুনরায় শূন্যে সেট হয়, যার ফলে কিউবিলেটকে সম্পূর্ণ
`imageMaximumGCAge` সময় অপেক্ষা করতে হয়, এরপর ইমেজের বয়সের ভিত্তিতে গারবেজ কালেকশনের জন্য 
যোগ্যতা নির্ধারণ করা হয়।
{{< /note>}}

### কন্টেইনার গারবেজ কালেকশন {#container-image-garbage-collection}

কিউবিলেট (kubelet) অব্যবহৃত কন্টেইনারগুলো গারবেজ কালেকশন করে নিম্নলিখিত ভ্যারিয়েবলগুলির ভিত্তিতে, 
যেগুলো আপনি সংজ্ঞায়িত করতে পারেন:

* `MinAge`: এটি হল সেই ন্যূনতম বয়স, যার পরে কিউবিলেট একটি কন্টেইনার গারবেজ কালেক্ট করতে পারে। এটি নিষ্ক্রিয় করতে `0`
  সেট করতে হবে।
* `MaxPerPodContainer`: প্রতিটি পডের জন্য মৃত কন্টেইনারের সর্বাধিক সংখ্যা।
  এটি নিষ্ক্রিয় করতে  `0` এ সেট করতে হবে।
* `MaxContainers`: ক্লাস্টারের জন্য মৃত কন্টেইনারের সর্বাধিক সংখ্যা।
  এটি নিষ্ক্রিয় করতে কম ` 0` এ সেট করতে হবে।

এই ভ্যারিয়েবলগুলির পাশাপাশি, কিউবিলেট অজানা এবং মুছে ফেলা কন্টেইনারগুলিকেও গারবেজ কালেক্ট করে, 
সাধারণত সবচেয়ে পুরনো কন্টেইনারগুলো প্রথমে মুছে ফেলে।

`MaxPerPodContaine`r এবং `MaxContainers` একে অপরের সাথে সংঘর্ষে পড়তে পারে এমন পরিস্থিতিতে,
যেখানে একটি পডে সর্বাধিক কন্টেইনার সংখ্যা (`MaxPerPodContainer`) ক্লাস্টারের অনুমোদিত মোট মৃত 
কন্টেইনারের সংখ্যা (`MaxContainers`) অতিক্রম করতে পারে।
এই পরিস্থিতিতে, কিউবিলেট সংঘর্ষ সমাধান করতে `MaxPerPodContainer` এর মান সামঞ্জস্য করে।
সবচেয়ে খারাপ পরিস্থিতিতে, `MaxPerPodContainer`-এর মান `1`
পর্যন্ত কমিয়ে দিয়ে সবচেয়ে পুরনো কন্টেইনার মুছে ফেলা হতে পারে।
এছাড়াও, যেসব কন্টেইনার এখন আর কোনো পডের মালিকানায় নেই (অর্থাৎ, সংশ্লিষ্ট পড মুছে ফেলা
হয়েছে), সেগুলো `MinAge` অতিক্রম করার পর স্বয়ংক্রিয়ভাবে মুছে ফেলা হয়।

{{<note>}}
কিউবিলেট (kubelet) শুধুমাত্র সেই কন্টেইনারগুলো গারবেজ কালেকশন করে, যেগুলোর এটি পরিচালনা করে।
{{</note>}}

## গারবেজ কালেকশন কনফিগার করা {#configuring-gc}

আপনি যেসব কন্ট্রোলার রিসোর্স পরিচালনা করছে, তাদের জন্য নির্দিষ্ট অপশন 
কনফিগার করে রিসোর্সের গারবেজ কালেকশন টিউন করতে পারেন। নিম্নলিখিত 
পৃষ্ঠাগুলো আপনাকে গারবেজ কালেকশন কনফিগার করতে সাহায্য করবে:

* [কুবার্নেটিস অবজেক্টের কাসকেডিং ডিলিশন কনফিগার করা](/en/docs/tasks/administer-cluster/use-cascading-deletion/)
* [শেষ হওয়া জবগুলোর ক্লিনআপ কনফিগার করা](/en/docs/concepts/workloads/controllers/ttlafterfinished/)
  
## {{% heading "whatsnext" %}}

* কুবার্নেটিস অবজেক্টের [মালিকানা সম্পর্কে আরও জানুন.](/en/docs/concepts/overview/working-with-objects/owners-dependents/).
* কুবার্নেটিসের [ফাইনালাইজার সম্পর্কে আরও জানুন.](/en/docs/concepts/overview/working-with-objects/finalizers/).
* শেষ হওয়া জবগুলো ক্লিনআপ করার জন্য [TTL কন্ট্রোলার](/en/docs/concepts/workloads/controllers/ttlafterfinished/) সম্পর্কে জানুন।
