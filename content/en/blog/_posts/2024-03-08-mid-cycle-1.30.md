---
layout: blog
title: 'Kubernetes Removals and Major Changes in Kubernetes 1.30'
date: 2024-03-08
slug: kubernetes-1-30-upcoming-changes
---

**Authors:** Amit Dsouza, Frederick Kautz, Kristin Martin, Abigail McCarthy, Natali Vlatko 

As Kubernetes grows and matures, features may be deprecated, removed, or replaced with improvements for the health of the project. Kubernetes v1.30 includes several major changes and one removal.

## The Kubernetes API Removal and Deprecation process

The Kubernetes project has a [well-documented deprecation policy](/docs/reference/using-api/deprecation-policy/) for features. This policy states that stable APIs may only be deprecated when a newer, stable version of that same API is available and that APIs have a minimum lifetime for each stability level. A deprecated API is one that has been marked for removal in a future Kubernetes release; it will continue to function until removal (at least one year from the deprecation), but usage will result in a warning being displayed. Removed APIs are no longer available in the current version, at which point you must migrate to using the replacement.

* Generally available (GA) or stable API versions may be marked as deprecated, but must not be removed within a major version of Kubernetes.
* Beta or pre-release API versions must be supported for 3 releases after deprecation.
* Alpha or experimental API versions may be removed in any release without prior deprecation notice.

Whether an API is removed as a result of a feature graduating from beta to stable or because that API simply did not succeed, all removals comply with this deprecation policy. Whenever an API is removed, migration options are communicated in the documentation.

## Removal for Kubernetes v1.30

### Removal of `SecurityContextDeny` admission plugin

The `SecurityContextDeny` admission plugin, deprecated since v1.27, is being [removed in v1.30](https://github.com/kubernetes/kubernetes/pull/122612). The `PodSecurity` admission plugin, [available since v1.25](/docs/concepts/security/pod-security-admission/), is recommended instead. See [Admission Controllers reference](/docs/reference/access-authn-authz/admission-controllers/#securitycontextdeny) for more information. 

## Major Changes for Kubernetes v1.30

### Structured Parameters for dynamic resource allocation ([KEP-4381](https://kep.k8s.io/4381))

[Dynamic resource allocation](/docs/concepts/scheduling-eviction/dynamic-resource-allocation/) was added to Kubernetes as an alpha feature in v1.26. It defines an alternative to the traditional device-plugin API for requesting access to third-party resources. By design, dynamic resource allocation uses parameters for resources that are completely opaque to core Kubernetes. This approach poses a problem for the Cluster Autoscaler (CA) or for any higher level controller that needs to make decisions for a group of pods (e.g. a job scheduler). It cannot simulate the effect of allocating or deallocating claims over time. Only the third-party DRA drivers have the information available to do this.

​​Structured Parameters for dynamic resource allocation an extension to the original implementation that addresses this problem by building a framework to support making these claim parameters less opaque. Instead of handling the semantics of all claim parameters themselves, drivers could manage resources and describe them using a specific "structured model" pre-defined by Kubernetes. This would allow components aware of this "structured model" to make decisions about these resources without outsourcing them to some third-party controller. For example, the scheduler would be able to allocate claims rapidly, without back-and-forth communication with dynamic resource allocation drivers. Work done for this release centers on defining the framework necessary to enable different "structured models" and to implement the "named resources" model. This model allows listing individual resource instances and, compared to the traditional device plugin API, adds the ability to select those instances individually via attributes.

### Node memory swap support ([KEP-2400](https://kep.k8s.io/2400))

In Kubernetes v1.30, node memory swap support graduates to `Beta2` with a strong emphasis on system stability. In previous Kubernetes versions, the `NodeSwap` feature gate was disabled by default and, when enabled, it used `UnlimitedSwap` behavior as the default behavior. To achieve better stability, `UnlimitedSwap` behavior which might compromise node stability will be removed in v1.30. In the Beta2 version, the `NodeSwap` is enabled by default with a new setting `NoSwap` being the default behavior. `NoSwap` turns off swap, giving administrators the opportunity to explicitly turn on swap for the desired nodes. Additional changes include updating implementation [best practices guidelines](https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md#best-practices) for `NodeSwap` with critical findings around keeping your system stable. For more details on node swap support in Kubernetes, read previous the [blog post](/blog/2023/08/24/swap-linux-beta/) or the [node swap documentation](/docs/concepts/architecture/nodes/#swap-memory).

### Support User Namespaces in pods ([KEP-127](https://kep.k8s.io/127))

[User namespaces](/docs/concepts/workloads/pods/user-namespaces) is a feature to better isolate pods to prevent or mitigate several CVEs rated high/critical, including the just published [CVE-2024-21626](https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv). In Kubernetes 1.30, support for user namespaces is migrating to beta, and now supports pods with and without volumes, custom UID/GID ranges and more!

### Structured Authorization Configuration ([KEP-3221](https://kep.k8s.io/3221))

The Kubernetes API server's authorizer chain can now be configured using a configuration file. This [feature](https://github.com/kubernetes/enhancements/tree/master/keps/sig-auth/3221-structured-authorization-configuration) enables the creation of authorization chains with multiple webhooks with well-defined parameters that validate requests in a particular order and allows fine-grained control – such as explicit Deny on failures. The configuration file allows one to specify CEL rules to pre-filter requests before they are dispatched to webhooks to prevent unnecessary invocations. API Server will also automatically reload the authorizer chain when the configuration file is modified.

An example configuration with all possible values is provided in the [Authorization docs](/docs/reference/access-authn-authz/authorization/#configuring-the-api-server-using-an-authorization-config-file). You must specify the path to that authorization configuration using the `--authorization-config` command line argument. While the feature is in the Alpha or Beta stage, there is no change if you want to keep on using command line flags instead of using a configuration file. From Kubernetes 1.30, the feature would be turned on by default. For more details, read the [Authorization docs](/docs/reference/access-authn-authz/authorization/#configuring-the-api-server-using-an-authorization-config-file).

### CEL for Admission Control ([KEP-3488](https://kep.k8s.io/3488))

Integrating Common Expression Language (CEL) for admission control in Kubernetes introduces a more dynamic and expressive way of evaluating admission requests. This feature allows complex, fine-grained policies to be defined and enforced directly through the Kubernetes API, enhancing security and governance capabilities without compromising performance or flexibility.

CEL's addition to Kubernetes admission control empowers cluster administrators to craft intricate rules that can evaluate the content of API requests against the desired state and policies of the cluster without resorting to Webhook-based access controllers. This level of control is crucial for maintaining the integrity, security, and efficiency of cluster operations, making Kubernetes environments more robust and adaptable to various use cases and requirements.

### Container Resource based Pod Autoscaling ([KEP-1610](https://kep.k8s.io/1610))

HPA ContainerResource type metric graduates to stable in v1.30. It allows us to configure Autoscaling based on resource usage of individual containers. 
See [our previous blog](/blog/2023/05/02/hpa-container-resource-metric/) for further details.

## Want to know more?

Deprecations are announced in the Kubernetes release notes. You can see the announcements of pending deprecations in the release notes for:

* [Kubernetes v1.26](https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.26.md#deprecation)
* [Kubernetes v1.27](https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.27.md#deprecation)
* [Kubernetes v1.28](https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.28.md#deprecation)
* [Kubernetes v1.29](https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.29.md#deprecation)


We will formally announce the deprecations that come with [Kubernetes v1.30](https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.30.md#deprecation) as part of the CHANGELOG for that release.

For information on the deprecation and removal process, refer to the official Kubernetes [deprecation policy](/docs/reference/using-api/deprecation-policy/#deprecating-parts-of-the-api) document.
