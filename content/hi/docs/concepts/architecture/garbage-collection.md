---
title: कचरा संग्रहण
content_type: concept
weight: 70
---

<!-- overview -->
{{<glossary_definition term_id="garbage-collection" length="short">}} यह
निम्नलिखित जैसे संसाधनों की सफाई की अनुमति देता है:

  * [टर्मिनेटेड पॉड](/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)
  * [पूर्ण कार्य](/docs/concepts/workloads/controllers/ttlafterfinished/)
  * [स्वामी के संदर्भ के बिना वस्तुएं](#स्वामी-आश्रित)
  * [अप्रयुक्त कंटेनर और कंटेनर चित्र](#containers-images)
  * [डिलीट की स्टोरेजक्लास रीक्लेम पॉलिसी के साथ डायनामिक रूप से प्रावधानित परसिस्टेंट वॉल्यूम](/docs/concepts/storage/persistent-volumes/#delete)
  * [बासी या समाप्त हो चुके सर्टिफिकेट साइनिंग अनुरोध (सीएसआर)](/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process)
  * {{<glossary_tooltip text="Nodes" term_id="node">}} निम्नलिखित परिदृश्यों में हटाया गया:
    * क्लाउड पर जब क्लस्टर [क्लाउड कंट्रोलर मैनेजर](/docs/concepts/architecture/cloud-controller/)
 का इस्तेमाल करता है
    * ऑन-प्रिमाइसेस जब क्लस्टर क्लाउड कंट्रोलर के समान ऐडऑन का उपयोग करता है
      प्रबंधक
  * [नोड लीज ऑब्जेक्ट्स](/docs/concepts/architecture/nodes/#heartbeats)

## स्वामी और आश्रित {#स्वामी-आश्रित}

कुबेरनेट्स में कई वस्तुएं [*स्वामी संदर्भ*](/docs/concepts/overview/working-with-objects/owners-dependents/) के माध्यम से एक दूसरे से जुड़ती हैं।
स्वामी के संदर्भ नियंत्रण तल को बताते हैं कि कौन सी वस्तुएं दूसरों पर निर्भर हैं।
कुबेरनेट्स नियंत्रण विमान और अन्य एपीआई देने के लिए मालिक संदर्भों का उपयोग करता है
ग्राहकों, हटाने से पहले संबंधित संसाधनों को साफ करने का अवसर
वस्तु। ज्यादातर मामलों में, कुबेरनेट्स स्वचालित रूप से मालिक के संदर्भों का प्रबंधन करता है।

स्वामित्व [लेबल और चयनकर्ता](/docs/concepts/overview/working-with-objects/labels/) से अलग है
तंत्र जिसका कुछ संसाधन भी उपयोग करते हैं। उदाहरण के लिए, ए पर विचार करें
{{<glossary_tooltip text="Service" term_id="service">}} जो बनाता है
'एंडपॉइंटस्लाइस' ऑब्जेक्ट्स। सेवा नियंत्रण विमान को अनुमति देने के लिए *लेबल* का उपयोग करती है
निर्धारित करें कि उस सेवा के लिए कौन से 'एंडपॉइंटस्लाइस' ऑब्जेक्ट का उपयोग किया जाता है। इसके साथ ही
लेबल के लिए, प्रत्येक `EndpointSlice` जिसे किसी सेवा की ओर से प्रबंधित किया जाता है
एक मालिक संदर्भ। मालिक के संदर्भ कुबेरनेट्स के विभिन्न भागों से बचने में मदद करते हैं
उन वस्तुओं के साथ हस्तक्षेप करना जिन्हें वे नियंत्रित नहीं करते हैं।

{{< नोट >}}
क्रॉस-नेमस्पेस स्वामी संदर्भ डिज़ाइन द्वारा अस्वीकृत हैं।
नेमस्पेस्ड आश्रित क्लस्टर-स्कोप्ड या नेमस्पेस्ड मालिकों को निर्दिष्ट कर सकते हैं।
नामस्थान स्वामी **आवश्यक** उसी नामस्थान में आश्रित के रूप में मौजूद होना चाहिए।
यदि ऐसा नहीं होता है, तो स्वामी संदर्भ को अनुपस्थित और आश्रित के रूप में माना जाता है
एक बार सभी स्वामियों के अनुपस्थित होने की पुष्टि हो जाने के बाद उसे हटाया जा सकता है।

क्लस्टर-दायरे वाले आश्रित केवल क्लस्टर-दायरे वाले स्वामियों को निर्दिष्ट कर सकते हैं।
v1.20+ में, यदि एक क्लस्टर-दायरे वाला निर्भर एक स्वामी के रूप में एक नामस्थान प्रकार निर्दिष्ट करता है,
इसे एक अनसुलझे मालिक संदर्भ के रूप में माना जाता है, और यह कचरा एकत्र करने में सक्षम नहीं है।

v1.20+ में, अगर गारबेज संग्राहक एक अमान्य क्रॉस-नेमस्पेस `ओनर रेफरेंस` का पता लगाता है,
या एक क्लस्टर-स्कोप्ड निर्भर एक `ओनर रेफरेंस` के साथ एक नेमस्पेस्ड प्रकार, एक चेतावनी ईवेंट को संदर्भित करता है
'OwnerRefInvalidNamespace' के कारण और अमान्य आश्रित के 'शामिल ऑब्जेक्ट' की सूचना दी गई है।
आप उस तरह के इवेंट को चलाकर चेक कर सकते हैं
`kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace`।
{{< /नोट >}}

## कैस्केडिंग विलोपन {#कैस्केडिंग-डिलीशन}

कुबेरनेट्स उन वस्तुओं की जांच करता है और हटा देता है जिनके पास अब मालिक नहीं है
संदर्भ, जैसे कि जब आप प्रतिकृति को हटाते हैं तो पॉड्स पीछे रह जाते हैं। जब आप
किसी वस्तु को हटाएं, आप नियंत्रित कर सकते हैं कि कुबेरनेट्स वस्तु को हटाता है या नहीं
*कैस्केडिंग विलोपन* नामक प्रक्रिया में आश्रित स्वचालित रूप से। वहाँ हैं
दो प्रकार के कैस्केडिंग विलोपन, इस प्रकार है:

  * अग्रभूमि कैस्केडिंग विलोपन
  * पृष्ठभूमि कैस्केडिंग विलोपन

आप यह भी नियंत्रित कर सकते हैं कि कचरा संग्रह कैसे और कब संसाधनों को हटाता है
Kubernetes का उपयोग करते हुए स्वामी संदर्भ {{<glossary_tooltip text="finalizers" term_id="finalizer">}}. 

### अग्रभूमि कैस्केडिंग विलोपन {#अग्रभूमि-विलोपन}

फोरग्राउंड कैस्केडिंग विलोपन में, आप जिस स्वामी वस्तु को हटा रहे हैं, वह पहले प्रवेश करती है
a *हटाना जारी है* स्थिति। इस अवस्था में निम्नलिखित होता है
स्वामी वस्तु:

  * Kubernetes API सर्वर ऑब्जेक्ट का `metadata.deletionTimestamp` सेट करता है
    फ़ील्ड उस समय तक जब ऑब्जेक्ट को हटाने के लिए चिह्नित किया गया था।
  * Kubernetes API सर्वर `metadata. finalizers` फ़ील्ड को भी सेट करता है
    `अग्रभूमि हटाना`।
  * ऑब्जेक्ट कुबेरनेट्स एपीआई के माध्यम से विलोपन तक दृश्यमान रहता है
    प्रक्रिया पूरी हो गई है।

स्वामी वस्तु के विलोपन की प्रगति की स्थिति में प्रवेश करने के बाद, नियंत्रक
आश्रितों को हटाता है। सभी आश्रित वस्तुओं को हटाने के बाद, नियंत्रक
स्वामी वस्तु को हटाता है। इस बिंदु पर, वस्तु अब में दिखाई नहीं दे रही है
कुबेरनेट्स एपीआई।

अग्रभूमि कैस्केडिंग विलोपन के दौरान, एकमात्र आश्रित जो स्वामी को ब्लॉक करते हैं
विलोपन वे हैं जिनके पास `ownerReference.blockOwnerDeletion=true` फ़ील्ड है।
[अग्रभूमि कैस्केडिंग विलोपन का उपयोग करें](/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion) देखें
अधिक जानने के लिए।

### बैकग्राउंड कैस्केडिंग डिलीट {#बैकग्राउंड-डिलीशन}

बैकग्राउंड कैस्केडिंग विलोपन में, Kubernetes API सर्वर स्वामी को हटा देता है
वस्तु तुरंत और नियंत्रक आश्रित वस्तुओं को साफ करता है
पृष्ठभूमि। डिफ़ॉल्ट रूप से, कुबेरनेट पृष्ठभूमि कैस्केडिंग विलोपन का उपयोग करता है जब तक कि
आप मैन्युअल रूप से अग्रभूमि विलोपन का उपयोग करते हैं या आश्रित वस्तुओं को अनाथ करना चुनते हैं।

देखें [बैकग्राउंड कैस्केडिंग डिलीट का उपयोग करें](/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion) अधिक जानने के लिए।

### अनाथ आश्रित

जब कुबेरनेट्स किसी स्वामी वस्तु को हटाते हैं, तो पीछे रह गए आश्रितों को बुलाया जाता है
*अनाथ* वस्तुएं। डिफ़ॉल्ट रूप से, कुबेरनेट्स आश्रित वस्तुओं को हटा देता है। जानने के लिए कैसे
इस व्यवहार को ओवरराइड करने के लिए, [स्वामी वस्तुओं और अनाथ आश्रितों को हटाएं] (/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy) देखें।

## अप्रयुक्त कंटेनरों और छवियों का कचरा संग्रह {#containers-images}

{{<glossary_tooltip text="kubelet" term_id="kubelet">}} कचरा करता है
प्रत्येक पांच मिनट में अप्रयुक्त छवियों पर संग्रह और अप्रयुक्त कंटेनरों पर प्रत्येक
मिनट। आपको बाहरी कचरा संग्रह उपकरण का उपयोग करने से बचना चाहिए, क्योंकि ये कर सकते हैं
क्यूबलेट व्यवहार को तोड़ें और मौजूद कंटेनरों को हटा दें।

अप्रयुक्त कंटेनर और छवि कचरा संग्रह के लिए विकल्पों को कॉन्फ़िगर करने के लिए, ट्यून करें
[कॉन्फ़िगरेशन फ़ाइल](/docs/tasks/administer-cluster/kubelet-config-file/) का उपयोग करके क्यूबलेट
और कचरा संग्रहण से संबंधित मापदंडों को उपयोग करके बदलें
[`KubletConfiguration`](/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubletConfiguration)
resource type.

### कंटेनर छवि जीवनचक्र

कुबेरनेट्स अपने *छवि प्रबंधक* के माध्यम से सभी छवियों के जीवनचक्र का प्रबंधन करता है,
जो क्यूबलेट का हिस्सा है, के सहयोग से
{{< glosary_tooltip text="cadvisor" term_id="cadvisor" >}}. क्यूबलेट
कचरा संग्रह करते समय निम्नलिखित डिस्क उपयोग सीमा पर विचार करता है
निर्णय:

  * `हाई थ्रेशोल्ड प्रतिशत`
  * `लो थ्रेसहोल्ड प्रतिशत`

कॉन्फ़िगर किए गए `HighThresholdPercent` मान के ऊपर डिस्क का उपयोग कचरा ट्रिगर करता है
संग्रह, जो पिछली बार उपयोग किए जाने के आधार पर छवियों को हटा देता है,
सबसे पुराने पहले से शुरू। क्यूबलेट छवियों को हटा देता है
जब तक डिस्क का उपयोग `LowThresholdPercent` मान तक नहीं पहुंच जाता।

### कंटेनर कचरा संग्रहण {#container-image-garbage-collection}

क्यूबलेट कचरा अप्रयुक्त कंटेनरों को निम्नलिखित चर के आधार पर एकत्र करता है,
जिसे आप परिभाषित कर सकते हैं:

  * `MinAge`: वह न्यूनतम आयु जिस पर क्यूबलेट कचरा एकत्रित कर सकता है a
    कंटेनर। `0` पर सेट करके अक्षम करें।
  * `MaxPerPodContainer`: प्रत्येक पॉड में मृत कंटेनरों की अधिकतम संख्या
    हो सकता है। `0` से कम पर सेट करके अक्षम करें।
  * `MaxContainers`: क्लस्टर में मृत कंटेनरों की अधिकतम संख्या हो सकती है।
    `0` से कम पर सेट करके अक्षम करें।

इन चरों के अलावा, क्यूबलेट कचरा अज्ञात और एकत्र करता है
हटाए गए कंटेनर, आमतौर पर सबसे पुराने पहले से शुरू होते हैं।

`MaxPerPodContainer` और `MaxContainers` संभावित रूप से एक दूसरे के साथ संघर्ष कर सकते हैं
उन स्थितियों में जहां प्रति पॉड अधिकतम संख्या में कंटेनर बनाए रखना
(`MaxPerPodContainer`) वैश्विक मृतकों की स्वीकार्य संख्या से बाहर हो जाएगा
कंटेनर (`MaxContainers`)। इस स्थिति में, क्यूबलेट एडजस्ट हो जाता है
संघर्ष को संबोधित करने के लिए `MaxPerPodContainer`। सबसे खराब स्थिति होगी
`MaxPerPodContainer` को डाउनग्रेड करके `1` करें और सबसे पुराने कंटेनरों को बेदखल करें।
इसके अतिरिक्त, हटाए गए पॉड्स के स्वामित्व वाले कंटेनरों को एक बार हटा दिया जाता है
वे `MinAge` से पुराने हैं।

{{<नोट>}}
क्यूबलेट केवल उन कंटेनरों को इकट्ठा करता है जिन्हें वह प्रबंधित करता है।
{{</नोट>}}

## कचरा संग्रहण का विन्यास {#configuring-gc}

आप विशिष्ट विकल्पों को कॉन्फ़िगर करके संसाधनों के कचरा संग्रह को ट्यून कर सकते हैं
नियंत्रक उन संसाधनों का प्रबंधन करते हैं। निम्नलिखित पृष्ठ आपको दिखाते हैं कि कैसे करें
कचरा संग्रह कॉन्फ़िगर करें:

  * [कुबेरनेट्स ऑब्जेक्ट्स के कैस्केडिंग विलोपन को कॉन्फ़िगर करना](/docs/tasks/administer-cluster/use-cascading-deletion/)
  * [समाप्त नौकरियों की सफाई को कॉन्फ़िगर करना](/docs/concepts/workloads/controllers/ttlafterfinished/)
  
<!-- * [अप्रयुक्त कंटेनर और छवि कचरा संग्रह को कॉन्फ़िगर करना](/docs/tasks/administer-cluster/reconfigure-kubelet/)  -->

## {{% heading "whatsnext" %}}

* [कुबेरनेट्स वस्तुओं के स्वामित्व](/docs/concepts/overview/working-with-objects/owners-dependents/) के बारे में अधिक जानें।
* कुबेरनेट्स [फाइनलाइज़र्स](/docs/concepts/overview/working-with-objects/finalizers/) के बारे में अधिक जानें।
* [TTL कंट्रोलर](/docs/concepts/workloads/controllers/ttlafterfinished/) (बीटा) के बारे में जानें जो तैयार जॉब्स को साफ करता है।
