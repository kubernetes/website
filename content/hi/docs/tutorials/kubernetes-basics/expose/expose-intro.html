---
title: अपने ऐप को एक्सपोज़ करने के लिए किसी सर्विस का उपयोग करना
weight: 10
---

<!DOCTYPE html>

<html lang="hi">

<body>

<link href="/docs/tutorials/kubernetes-basics/public/css/styles.css" rel="stylesheet">

<div class="layout" id="top">

	<main class="content">

		<div class="row">
			<div class="col-md-8">
                <h3>उद्देश्य</h3>
				<ul>
					<li>कुबेरनेट्स में सर्विस के बारे में जानें</li>
					<li>समझें कि लेबल और लेबल चयनकर्ता ऑब्जेक्ट किसी सर्विस से कैसे संबंधित हैं</li>
					<li>सर्विस का उपयोग करके कुबेरनेट्स क्लस्टर के बाहर किसी एप्लिकेशन को एक्सपोज़ करें</li>
				</ul>
			</div>

        <div class="col-md-8">
            <h3>कुबेरनेट्स सर्विसों का अवलोकन</h3>

			<p>कुबेरनेट्स <a href="/docs/concepts/workloads/pods/">पॉड्स</a> नश्वर हैं। पॉड में वास्तव में एक <a href="/docs/concepts/workloads/pods/pod-lifecycle/">जीवनचक्र</a> होता है। जब एक कार्यकर्ता नोड बंद हो जाता है, तो नोड पर चलने वाले पॉड भी खो जाते हैं। एक <a href="/docs/concepts/workloads/controllers/replicaset/">रेप्लिकासेट</a> तब आपके एप्लिकेशन को चालू रखने के लिए नए पॉड्स के निर्माण करके क्लस्टर को वांछित स्थिति में वापस चला सकता है। एक अन्य उदाहरण के रूप में, 3 रेप्लिका के साथ एक इमेज प्रोसेसिंग बैकएंड पर विचार करें। वे रेप्लिका विनिमेय हैं; फ्रंट-एंड सिस्टम को बैकएंड रेप्लिका की परवाह नहीं करनी चाहिए या भले ही पॉड खो जाए और फिर से बनाया जाए। कुबेरनेट्स क्लस्टर में प्रत्येक पॉड का एक अद्वितीय IP पता होता है, यहां तक कि एक ही नोड पर पॉड्स के भी, इसलिए पॉड्स के बीच परिवर्तनों को स्वचालित रूप से समेटने का एक तरीका होना चाहिए ताकि आपके एप्लिकेशन कार्य करना जारी रखें।</p>

            <p>कुबेरनेट्स में सर्विस एक अमूर्त है जो पॉड्स के तार्किक सेट और उन्हें एक्सेस करने के लिए एक निति परिभाषित करता है। सर्विस निर्भर पॉड्स के बीच एक युग्मन को सक्षम करती है। सभी कुबेरनेट्स ऑब्जेक्ट्स की तरह YAML <a href="/docs/concepts/configuration/overview/#general-configuration-tips">(अधिमानित)</a> या JSON का उपयोग करके एक सर्विस को परिभाषित किया जाता है। सर्विस द्वारा लक्षित पॉड्स का सेट आमतौर पर एक <i>लेबल सेलेक्टर</i> द्वारा निर्धारित किया जाता है (नीचे देखें कि आप <code>selector</code> शामिल किए बिना सर्विस क्यों उपयोग करना चाहेंगे।)</p>

            <p>यद्यपि प्रत्येक पॉड का एक विशिष्ट आईपी पता होता है, लेकिन उन आईपी को सर्विस के बिना क्लस्टर के बाहर उजागर नहीं किया जाता है। सर्विस आपके एप्लिकेशन को ट्रैफ़िक प्राप्त करने देती हैं। ServiceSpec: में <code>type</code> निर्दिष्ट करके सर्विसों को अलग-अलग तरीकों से उजागर किया जा सकता है:</p>
			
			<ul>
				<li><is>क्लस्टर IP</in> (डिफ़ॉल्ट) - क्लस्टर में किसी आंतरिक IP पर सर्विस को एक्सपोज़ करें। यह प्रकार सर्विस को केवल क्लस्टर के भीतर से ही पहुंच योग्य बनाता है।</li>
                
                <li><i>नोडपोर्ट</i> - NAT का उपयोग करके क्लस्टर में प्रत्येक चयनित नोड के एक ही पोर्ट पर सेवा को प्रदर्शित करता है। <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> का उपयोग करके किसी सेवा को क्लस्टर के बाहर से एक्सेस योग्य बनाता है। क्लस्टरआईपी का सुपरसेट।</li>
                
				<li><i>लोड बैलेंसर</i> - मौजूदा क्लाउड (यदि समर्थित हो) में एक बाहरी लोड बैलेंसर बनाता है और सर्विस को एक निश्चित, बाहरी आईपी असाइन करता है। नोडपोर्ट का सुपरसेट।</li>
				
                <li><i>एक्सटर्नल-नाम</i> - सेवा को <code>externalName</code> फ़ील्ड (जैसे <code>foo.bar.example.com</code>) की सामग्री से मैप करता है, एक लौटाकर <code>CNAME</code> अपने मान के साथ रिकॉर्ड करें। किसी भी प्रकार का कोई प्रॉक्सी सेट अप नहीं किया गया है। इस प्रकार के लिए v1.7 या उच्चतर <code>kube-dns</code>, या कोरडीएनएस संस्करण 0.0.8 या उच्चतर की आवश्यकता होती है।</li>
                
			</ul>

            <p>विभिन्न प्रकार की सर्विसओं के बारे में अधिक जानकारी <a href="/docs/tutorials/services/source-ip/">स्रोत आईपी का उपयोग करना</a> ट्यूटोरियल में मिल सकती है। <a href="/docs/concepts/services-networking/connect-applications-service">एप्लिकेशन को सर्विसओं से जोड़ना</a> भी देखें।</p>
			
            <p>इसके अतिरिक्त, ध्यान दें कि सर्विसओं के साथ कुछ उपयोग के मामले हैं जिनमें विनिर्देश में <code>selector</code> को परिभाषित नहीं करना शामिल है। <code>selector</code> के बिना बनाई गई सर्विस भी अनुरूप एंडपॉइन्ट ऑब्जेक्ट नहीं बनाएगी। यह उपयोगकर्ताओं को विशिष्ट एंडपॉइन्ट के लिए किसी सर्विस को मैन्युअल रूप से मैप करने की अनुमति देता है। एक और संभावना है कि कोई सलेक्टर क्यों नहीं हो सकता है, कि आप सख्ती से <code>type: ExternalName</code> का उपयोग कर रहे हैं।</p>
        	
        </div>
			<div class="col-md-4">
				<div class="content__box content__box_lined">
					<h3>सारांश</h3>
					<ul>
						<li>पॉड्स को बाहरी ट्रैफ़िक में एक्सपोज़ करना</li>
                        <li>एकाधिक पॉड्स में संतुलन ट्रैफ़िक लोड करें</li>
                        <li>लेबल का उपयोग</li>
                    </ul>
				</div>
				<div class="content__box content__box_fill">
                    <p><i>कुबेरनेट्स सर्विस एक अमूर्त परत है जो पॉड्स के तार्किक सेट को परिभाषित करती है और उन पॉड्स के लिए बाहरी ट्रैफ़िक एक्सपोज़र, लोड बैलेंसिंग और सर्विस डिस्कवरी को सक्षम बनाती है।</i></p>
				</div>
			</div>
		</div>
		<br>

		<div class="row">
			<div class="col-md-8">
                <h3>सेवाएं और लेबल</h3>
			</div>
		</div>
		
		<div class="row">
			<div class="col-md-8">
				<p>सेवा पॉड्स के एक सेट पर ट्रैफ़िक को रूट करती है। सेवाएँ अमूर्त हैं जो आपके एप्लिकेशन को प्रभावित किए बिना पॉड्स को कुबेरनेट्स में मरने और दोहराने की अनुमति देती हैं। निर्भर पॉड्स के बीच डिस्कवरी और रूटिंग (जैसे कि किसी एप्लिकेशन में फ्रंटएंड और बैकएंड कंपोनेंट्स) को कुबेरनेट्स सर्विसेज द्वारा नियंत्रित किया जाता है।</p>
				
                <p>सर्विस <a href="/docs/concepts/overview/working-with-objects/labels">लेबल और चयनकर्ताओं</a> का उपयोग करके पॉड्स के एक सेट से मेल खाती हैं, एक समूहबद्ध आदिम जो Kubernetes में ऑब्जेक्ट पर तार्किक संचालन की अनुमति देता है . लेबल वस्तुओं से जुड़े कुंजी/मूल्य जोड़े होते हैं और इन्हें किसी भी तरह से उपयोग किया जा सकता है:</p>
                
				<ul>
					<li>डिप्लॉयमेंट,परीक्षण और प्रोडक्शन के लिए वस्तुओं को नामित करें</li>
					<li>संस्करण टैग जोड़ें</li>
                    <li>टैग का उपयोग करके ऑब्जेक्ट्स को वर्गीकृत करें</li>
                </ul>
			</div>
			
		</div>

		<br>

		<div class="row">
			<div class="col-md-8">
				<p><img src="/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg"></p>
			</div>
		</div>
		<br>
		<div class="row">
			<div class="col-md-8">
				<p>लेबल को निर्माण के समय या बाद में ऑब्जेक्ट्स से जोड़ा जा सकता है। उन्हें किसी भी समय परिवर्तित किया जा सकता है। आइए अब सर्विस का उपयोग करके हमारे ऐप को एक्सपोज़ करें और कुछ लेबल लागू करें।</p>
			</div>
		</div>
		<div class='row'>
			<div class='col-md-12'>
			<h3>एक नई सेवा बनाएं</h3>
			<p>आइए सत्यापित करें कि हमारा एप्लिकेशन चल रहा है। हम <code>kubectl get</code> कमांड का उपयोग करेंगे और मौजूदा पॉड्स की तलाश करेंगे:</p>
			<p><code><b>kubectl get pods</b></code></p>
			<p>यदि कोई पॉड्स नहीं चल रहा है तो इसका मतलब है कि पिछले ट्यूटोरियल के ऑब्जेक्ट साफ़ कर दिए गए हैं। इस मामले में, वापस जाएं और परिनियोजन बनाने के लिए kubectl का उपयोग करके <a href="/hi/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro#deploy-an-app">परिनियोजन को फिर से बनाएं।</a> 
					   कृपया कुछ सेकंड प्रतीक्षा करें और पॉड्स को फिर से सूचीबद्ध करें। एक बार जब आप एक पॉड को चलता हुआ देख लें तो आप जारी रख सकते हैं।</p>
			<p>इसके बाद, आइए अपने क्लस्टर से वर्तमान सेवाओं को सूचीबद्ध करें:</p>
			<p><code><b>kubectl get services</b></code></p>
			<p>हमारे पास <tt>kubernetes</tt> नामक एक सेवा है जो मिनीक्यूब के क्लस्टर शुरू करने पर डिफ़ॉल्ट रूप से बनाई जाती है।
			एक नई सेवा बनाने और उसे बाहरी ट्रैफ़िक में उजागर करने के लिए हम पैरामीटर के रूप में नोडपोर्ट के साथ एक्सपोज़ कमांड का उपयोग करेंगे।</p>
			<p><code><b>kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --पोर्ट 8080</b></code></p>
			<p>आइए फिर से <code>get services</code> उपकमांड चलाएँ:</p>
			<p><code><b>kubectl get services</b></code></p>
			<p>अब हमारे पास कुबेरनेट्स-बूटकैंप नामक एक चालू सेवा है। यहां हम देखते हैं कि सेवा को एक अद्वितीय क्लस्टर-आईपी, एक आंतरिक पोर्ट और एक बाहरी-आईपी (नोड का आईपी) प्राप्त हुआ।</p>
			<p>यह पता लगाने के लिए कि कौन सा पोर्ट बाहरी रूप से खोला गया था (<tt>प्रकार: NodePort</tt> सेवा के लिए) हम <code>describe service</code> उपकमांड चलाएंगे:</p>
			<p><code><b>kubectl describe services/kubernetes-bootcamp</b></code></p>
			<p> <tt>NODE_PORT</tt> नामक एक पर्यावरण चर बनाएं जिसमें निर्दिष्ट नोड पोर्ट का मान हो:</p>
			<p><code><b>export NODE_PORT='$(kubectl getservices/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')'</b> </code><br />
			<code><b>echo "NODE_PORT=$NODE_PORT"</b></code></p>
			<p>अब हम <code>curl</code>, नोड के आईपी पते और बाहरी रूप से उजागर पोर्ट का उपयोग करके परीक्षण कर सकते हैं कि ऐप क्लस्टर के बाहर प्रदर्शित है:</p>
			<p><code><b>कर्ल http://'$(minikube ip):$NODE_PORT'</b></code></p>
					 {{< note >}}<p>यदि आप कंटेनर ड्राइवर के रूप में डॉकर डेस्कटॉप के साथ मिनीक्यूब चला रहे हैं, तो एक मिनीक्यूब सुरंग की आवश्यकता है। ऐसा इसलिए है क्योंकि डॉकर डेस्कटॉप के अंदर के कंटेनर आपके होस्ट कंप्यूटर से अलग होते हैं।<br>
			<p>एक अलग टर्मिनल विंडो में, निष्पादित करें:<br>
			<code><b>minikube services kubernetes-bootcamp --url</b></code></p>
			<p>आउटपुट इस तरह दिखता है:
			<pre><b>http://127.0.0.1:51082<br>! क्योंकि आप डार्विन पर डॉकर ड्राइवर का उपयोग कर रहे हैं, इसे चलाने के लिए टर्मिनल का खुला होना आवश्यक है।</b></pre></p>
			<p>फिर ऐप तक पहुंचने के लिए दिए गए यूआरएल का उपयोग करें:<br>
			<code><b>कर्ल 127.0.0.1:51082</b></code></p>
			{{< /note >}}
			<p>और हमें सर्वर से प्रतिक्रिया मिलती है। सेवा उजागर हो गई है.</p>
			</div>
		</div>

		<div class="row">
			<div class="col-md-12">
				<h3>लेबल का उपयोग करना</h3>
				<p>परिनियोजन ने स्वचालित रूप से हमारे पॉड के लिए एक लेबल बनाया। <कोड>परिनियोजन का वर्णन करें</कोड> उपकमांड के साथ आप उस लेबल का नाम (<em>कुंजी</em>) देख सकते हैं:</p>
				<p><code><b>kubectl describe deployments</b></code></p>
				<p>आइए पॉड्स की हमारी सूची के बारे में पूछताछ करने के लिए इस लेबल का उपयोग करें। हम एक पैरामीटर के रूप में <code>kubectl get pods</code> कमांड का उपयोग <tt>-l</tt> के साथ करेंगे, जिसके बाद लेबल मान होंगे:</p>
				<p><code><b>kubectl get pods -l app=kubernetes-bootcamp</b></code></p>
				<p>मौजूदा सेवाओं को सूचीबद्ध करने के लिए आप ऐसा ही कर सकते हैं:</p>
				<p><code><b>kubectl get services -l app=kubernetes-bootcamp</b></code></p>
				<p>पॉड का नाम प्राप्त करें और इसे <tt>POD_NAME</tt> पर्यावरण चर में संग्रहीत करें:</p>
				<p><code><b>export POD_NAME='$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{'\n'}} {{end}}')"</b></code><br />
				<code><b>echo "Name of Pod: $POD_NAME"</b></code></p>
				<p>नया लेबल लागू करने के लिए हम <code>label</code> उपकमांड का उपयोग करते हैं, जिसके बाद ऑब्जेक्ट प्रकार, ऑब्जेक्ट का नाम और नया लेबल आता है:</p>
				<p><code><b>kubectl label pods "$POD_NAME" version=v1</b></code></p>
				<p>यह हमारे पॉड पर एक नया लेबल लागू करेगा (हमने एप्लिकेशन संस्करण को पॉड पर पिन किया है), और हम इसे डिस्क्रिप्शन पॉड कमांड के साथ जांच सकते हैं:</p>
				<p><code><b>kubectl describe pods "$POD_NAME"</b></code></p>
				<p>हम यहां देखते हैं कि लेबल अब हमारे पॉड से जुड़ा हुआ है। और अब हम नए लेबल का उपयोग करके पॉड्स की सूची क्वेरी कर सकते हैं:</p>
				<p><code><b>kubectl get pods -l version=v1</b></code></p>
				<p>और हम पॉड देखते हैं।</p>
			</div>
		</div>

		<div class="row">
			<div class="col-md-12">
				<h3>किसी सेवा को हटाना</h3>
				<p>सेवाओं को हटाने के लिए आप <code>delete service</code> उपकमांड का उपयोग कर सकते हैं। लेबल का उपयोग यहां भी किया जा सकता है:</p>
				<p><code><b>kubectl delete service -l app=kubernetes-bootcamp</b></code></p>
				<p>पुष्टि करें कि सेवा समाप्त हो गई है:</p>
				<p><code><b>kubectl get services</b></code></p>
				<p>यह पुष्टि करता है कि हमारी सेवा हटा दी गई थी। यह पुष्टि करने के लिए कि मार्ग अब उजागर नहीं हुआ है, आप पहले से उजागर आईपी और पोर्ट को <tt>curl</tt> कर सकते हैं:</p>
				<p><code><b>curl http://'$(minikube ip):$NODE_PORT'</b></code></p>
				<p>यह साबित करता है कि एप्लिकेशन अब क्लस्टर के बाहर से पहुंच योग्य नहीं है।
				आप पुष्टि कर सकते हैं कि ऐप अभी भी पॉड के अंदर से <tt>curl</tt> के साथ चल रहा है:</p>
				<p><code><b>kubectl exec -ti $POD_NAME -- curl http://localhost:8080</b></code></p>
				<p>हम यहां देखते हैं कि एप्लिकेशन चालू है। ऐसा इसलिए है क्योंकि परिनियोजन एप्लिकेशन का प्रबंधन कर रहा है। एप्लिकेशन को बंद करने के लिए, आपको परिनियोजन को भी हटाना होगा।</p>
			</div>
		</div>

		<div class="row">
			<p>
				एक बार जब आप तैयार हो जाएं, तो आगे बढ़ें <a href='/hi/docs/tutorials/kubernetes-basics/scale/scale-intro/' title='Running Multiple Instances of Your App'>अपने ऐप के कई इंस्टेंस को चलाना</a >
			</p>
		</div>
	</main>
</div>

</body>
</html>

