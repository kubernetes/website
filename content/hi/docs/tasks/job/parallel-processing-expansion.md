---
title: समानांतर प्रसंस्करण विस्तार
content_type: task
min-kubernetes-server-version: v1.21
weight: 50
---

<!-- overview -->

इस उदाहरण में, आप एक जॉब चलाएंगे जो कई समानांतर वर्कर प्रोसेस का उपयोग करता है। प्रत्येक वर्कर अपने स्वयं के पॉड में चलने वाला एक अलग कंटेनर है।

इस उदाहरण में, जैसे-जैसे प्रत्येक पॉड बनाया जाता है, यह कार्य कतार से एक कार्य इकाई लेता है, इसे प्रोसेस करता है, और बाहर निकल जाता है।

यहाँ इस उदाहरण में चरणों का एक सिंहावलोकन है:

1. **एक मैसेज क्यू सेवा शुरू करें।** इस उदाहरण में, आप RabbitMQ का उपयोग करते हैं, लेकिन आप कोई अन्य भी उपयोग कर सकते हैं। व्यवहार में आप एक मैसेज क्यू सेवा एक बार सेट करेंगे और इसका उपयोग कई जॉब्स के लिए करेंगे।
1. **एक क्यू बनाएं, और इसे संदेशों से भरें।** प्रत्येक संदेश एक कार्य का प्रतिनिधित्व करता है जो किया जाना है। इस उदाहरण में, एक संदेश एक पूर्णांक है जिस पर हम एक लंबी गणना करेंगे।
1. **क्यू से कार्यों पर काम करने वाला एक जॉब शुरू करें**। जॉब कई पॉड शुरू करता है। प्रत्येक पॉड मैसेज क्यू से एक कार्य लेता है, इसे संसाधित करता है, और बाहर निकल जाता है।

## {{% heading "prerequisites" %}}

आपको पहले से ही [Job](/docs/concepts/workloads/controllers/job/) के बुनियादी, गैर-समानांतर उपयोग से परिचित होना चाहिए।

{{< include "task-tutorial-prereqs.md" >}}

आपको एक कंटेनर इमेज रजिस्ट्री की आवश्यकता होगी जहां आप अपने क्लस्टर में चलाने के लिए इमेज अपलोड कर सकते हैं।

यह कार्य उदाहरण यह भी मानता है कि आपने Docker को स्थानीय रूप से स्थापित किया है।

<!-- steps -->

## मैसेज क्यू सेवा शुरू करना

यह उदाहरण RabbitMQ का उपयोग करता है, हालांकि, आप उदाहरण को किसी अन्य AMQP-प्रकार की मैसेज सेवा का उपयोग करने के लिए अनुकूलित कर सकते हैं।

व्यवहार में आप एक क्लस्टर में एक बार मैसेज क्यू सेवा सेट कर सकते हैं और इसका पुन: उपयोग कई जॉब्स के साथ-साथ लंबे समय तक चलने वाली सेवाओं के लिए कर सकते हैं।

RabbitMQ को निम्नानुसार शुरू करें:

```shell
# StatefulSet के उपयोग के लिए एक सेवा बनाएं
kubectl create -f https://kubernetes.io/examples/application/job/rabbitmq/rabbitmq-service.yaml
```
```
service "rabbitmq-service" created
```

```shell
kubectl create -f https://kubernetes.io/examples/application/job/rabbitmq/rabbitmq-statefulset.yaml
```
```
statefulset "rabbitmq" created
```

## मैसेज क्यू सेवा का परीक्षण

अब, हम मैसेज क्यू तक पहुंचने का प्रयोग कर सकते हैं। हम एक अस्थायी इंटरैक्टिव पॉड बनाएंगे, इस पर कुछ टूल स्थापित करेंगे, और क्यू के साथ प्रयोग करेंगे।

पहले एक अस्थायी इंटरैक्टिव पॉड बनाएं।

```shell
# एक अस्थायी इंटरैक्टिव कंटेनर बनाएं
kubectl run -i --tty temp --image ubuntu:22.04
```
```
Waiting for pod default/temp-loe07 to be running, status is Pending, pod ready: false
... [ पिछली लाइन कई बार दोहराई जाती है .. जब यह रुक जाए तो रिटर्न दबाएं ] ...
```

ध्यान दें कि आपका पॉड नाम और कमांड प्रॉम्प्ट अलग होंगे।

अगला `amqp-tools` स्थापित करें ताकि आप मैसेज क्यू के साथ काम कर सकें।
अगले कमांड दिखाते हैं कि आपको उस पॉड में इंटरैक्टिव शेल के अंदर क्या चलाने की आवश्यकता है:

```shell
apt-get update && apt-get install -y curl ca-certificates amqp-tools python3 dnsutils
```

बाद में, आप एक कंटेनर इमेज बनाएंगे जिसमें ये पैकेज शामिल हैं।

अगला, आप जांचेंगे कि आप RabbitMQ के लिए सेवा का पता लगा सकते हैं:

```
# इन कमांड को पॉड के अंदर चलाएं
# ध्यान दें कि rabbitmq-service में एक DNS नाम है, जो Kubernetes द्वारा प्रदान किया गया है:
nslookup rabbitmq-service
```
```
Server:        10.0.0.10
Address:    10.0.0.10#53

Name:    rabbitmq-service.default.svc.cluster.local
Address: 10.0.147.152
```
(IP पते अलग-अलग होंगे)

यदि kube-dns एडऑन सही ढंग से सेट नहीं किया गया है, तो पिछला चरण आपके लिए काम नहीं कर सकता है।
आप उस सेवा के लिए IP पता एक पर्यावरण चर में भी पा सकते हैं:

```shell
# यह जांच पॉड के अंदर चलाएं
env | grep RABBITMQ_SERVICE | grep HOST
```
```
RABBITMQ_SERVICE_SERVICE_HOST=10.0.147.152
```
(IP पता अलग होगा)

अगला आप सत्यापित करेंगे कि आप एक क्यू बना सकते हैं, और संदेशों को प्रकाशित और उपभोग कर सकते हैं।

```shell
# इन कमांड को पॉड के अंदर चलाएं
# अगली लाइन में, rabbitmq-service वह होस्टनाम है जहां rabbitmq-service
# तक पहुंचा जा सकता है। 5672 rabbitmq के लिए मानक पोर्ट है।
export BROKER_URL=amqp://guest:guest@rabbitmq-service:5672
# यदि आप पिछले चरण में "rabbitmq-service" को रिज़ॉल्व नहीं कर सके,
# तो इसके बजाय इस कमांड का उपयोग करें:
BROKER_URL=amqp://guest:guest@$RABBITMQ_SERVICE_SERVICE_HOST:5672

# अब एक क्यू बनाएं:

/usr/bin/amqp-declare-queue --url=$BROKER_URL -q foo -d
```
```
foo
```

क्यू में एक संदेश प्रकाशित करें:
```shell
/usr/bin/amqp-publish --url=$BROKER_URL -r foo -p -b Hello

# और इसे वापस प्राप्त करें।

/usr/bin/amqp-consume --url=$BROKER_URL -q foo -c 1 cat && echo 1>&2
```
```
Hello
```

अंतिम कमांड में, `amqp-consume` टूल ने क्यू से एक संदेश (`-c 1`) लिया,
और उस संदेश को एक मनमाने कमांड के मानक इनपुट में पास किया।
इस मामले में, प्रोग्राम `cat` मानक इनपुट से पढ़े गए अक्षरों को प्रिंट करता है, और
echo एक कैरिज रिटर्न जोड़ता है ताकि उदाहरण पढ़ने योग्य हो।

## क्यू को कार्यों से भरें

अब, क्यू को कुछ सिमुलेटेड कार्यों से भरें। इस उदाहरण में, कार्य प्रिंट किए जाने वाले स्ट्रिंग्स हैं।

अभ्यास में, संदेशों की सामग्री हो सकती है:

- फ़ाइलों के नाम जिन्हें संसाधित करने की आवश्यकता है
- प्रोग्राम के लिए अतिरिक्त फ्लैग
- डेटाबेस टेबल में कुंजियों की सीमाएं
- सिमुलेशन के लिए कॉन्फ़िगरेशन पैरामीटर
- रेंडर किए जाने वाले दृश्य के फ्रेम नंबर

यदि बड़ा डेटा है जिसे जॉब के सभी पॉड द्वारा केवल पढ़ने के मोड में आवश्यकता है,
तो आप आमतौर पर उसे NFS जैसी साझा फ़ाइल सिस्टम में डालते हैं और उसे सभी पॉड पर केवल पढ़ने के लिए माउंट करते हैं,
या पॉड में प्रोग्राम को इस तरह लिखते हैं कि यह क्लस्टर फ़ाइल सिस्टम से डेटा को मूल रूप से पढ़ सके (उदाहरण के लिए: HDFS)।

इस उदाहरण के लिए, आप AMQP कमांड लाइन टूल का उपयोग करके क्यू बनाएंगे और इसे भरेंगे।
व्यवहार में, आप AMQP क्लाइंट लाइब्रेरी का उपयोग करके क्यू को भरने के लिए एक प्रोग्राम लिख सकते हैं।

```shell
# इसे अपने कंप्यूटर पर चलाएं, पॉड में नहीं
/usr/bin/amqp-declare-queue --url=$BROKER_URL -q job1  -d
```
```
job1
```
क्यू में आइटम जोड़ें:
```shell
for f in apple banana cherry date fig grape lemon melon
do
  /usr/bin/amqp-publish --url=$BROKER_URL -r job1 -p -b $f
done
```

आपने क्यू में 8 संदेश जोड़े हैं।

## एक कंटेनर इमेज बनाएं

अब आप एक इमेज बनाने के लिए तैयार हैं जिसे आप एक जॉब के रूप में चलाएंगे।

जॉब क्यू से संदेश पढ़ने और वास्तविक कार्य करने के लिए `amqp-consume` उपयोगिता का उपयोग करेगा।
यहाँ एक बहुत ही सरल उदाहरण प्रोग्राम है: 