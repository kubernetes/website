---
title: 使用啓動引導令牌（Bootstrap Tokens）認證
weight: 20
---

<!--
reviewers:
- jbeda
title: Authenticating with Bootstrap Tokens
content_type: concept
weight: 20
-->

<!-- overview -->

{{< feature-state for_k8s_version="v1.18" state="stable" >}}

<!--
Bootstrap tokens are a simple bearer token that is meant to be used when
creating new clusters or joining new nodes to an existing cluster.
It was built to support [kubeadm](/docs/reference/setup-tools/kubeadm/), but can be used in other contexts
for users that wish to start clusters without `kubeadm`. It is also built to
work, via RBAC policy, with the
[kubelet TLS Bootstrapping](/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/) system.
-->
啓動引導令牌是一種簡單的持有者令牌（Bearer Token），這種令牌是在新建叢集
或者在現有叢集中添加新節點時使用的。
它被設計成能夠支持 [`kubeadm`](/zh-cn/docs/reference/setup-tools/kubeadm/)，
但是也可以被用在其他的案例中以便使用者在不使用 `kubeadm` 的情況下啓動叢集。
它也被設計成可以通過 RBAC 策略，結合
[kubelet TLS 啓動引導](/zh-cn/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/)
系統進行工作。

<!-- body -->
<!--
## Bootstrap Tokens Overview

Bootstrap Tokens are defined with a specific type
(`bootstrap.kubernetes.io/token`) of secrets that lives in the `kube-system`
namespace. These Secrets are then read by the Bootstrap Authenticator in the
API Server. Expired tokens are removed with the TokenCleaner controller in the
Controller Manager. The tokens are also used to create a signature for a
specific ConfigMap used in a "discovery" process through a BootstrapSigner
controller.
-->
啓動引導令牌被定義成一個特定類型的 Secret（`bootstrap.kubernetes.io/token`），
並存在於 `kube-system` 名字空間中。
這些 Secret 會被 API 伺服器上的啓動引導認證組件（Bootstrap Authenticator）讀取。
控制器管理器中的控制器 TokenCleaner 能夠刪除過期的令牌。
這些令牌也被用來在節點發現的過程中會使用的一個特殊的 ConfigMap 對象。
BootstrapSigner 控制器也會使用這一 ConfigMap。

<!--
## Token Format

Bootstrap Tokens take the form of `abcdef.0123456789abcdef`.
More formally, they must match the regular expression `[a-z0-9]{6}\.[a-z0-9]{16}`.

The first part of the token is the "Token ID" and is considered public
information. It is used when referring to a token without leaking the secret
part used for authentication. The second part is the "Token Secret" and should
only be shared with trusted parties.
-->
## 令牌格式

啓動引導令牌使用 `abcdef.0123456789abcdef` 的形式。
更加規範地說，它們必須符合正則表達式 `[a-z0-9]{6}\.[a-z0-9]{16}`。

令牌的第一部分是 “Token ID”，它是一種公開資訊，用於引用令牌並確保不會
泄露認證所使用的祕密資訊。
第二部分是“令牌祕密（Token Secret）”，它應該被共享給受信的第三方。

## 啓用啓動引導令牌

<!--
## Enabling Bootstrap Token Authentication

The Bootstrap Token authenticator can be enabled using the following flag on the
API server:
-->
## 啓用啓動引導令牌身份認證   {#enabling-bootstrap-token-authentication}

啓動引導令牌認證組件可以通過 API 伺服器上的如下標誌啓用：

```
--enable-bootstrap-token-auth
```

<!--
When enabled, bootstrapping tokens can be used as bearer token credentials to
authenticate requests against the API server.
-->
啓動引導令牌被啓用後，可以作爲持有者令牌的憑據，用於 API 伺服器請求的身份認證。

```http
Authorization: Bearer 07401b.f395accd246ae52d
```
<!--
Tokens authenticate as the username `system:bootstrap:<token id>` and are members
of the group `system:bootstrappers`.
Additional groups may be specified in the token's Secret.

Expired tokens can be deleted automatically by enabling the `tokencleaner`
controller on the controller manager.
-->
令牌認證爲使用者名 `system:bootstrap:<token id>` 並且是組 `system:bootstrappers`
的成員。額外的組資訊可以通過令牌的 Secret 來設置。

過期的令牌可以通過啓用控制器管理器中的 `tokencleaner` 控制器來刪除。

```
--controllers=*,tokencleaner
```

<!--
## Bootstrap Token Secret Format

Each valid token is backed by a secret in the `kube-system` namespace. You can
find the full design doc
[here](https://github.com/kubernetes/design-proposals-archive/blob/main/cluster-lifecycle/bootstrap-discovery.md).

Here is what the secret looks like.
-->
## 啓動引導令牌的 Secret 格式  {#bootstrap-token-secret-format}

每個合法的令牌背後對應着 `kube-system` 名字空間中的某個 Secret 對象。
你可以從
[這裏](https://github.com/kubernetes/design-proposals-archive/blob/main/cluster-lifecycle/bootstrap-discovery.md)
找到完整設計文檔。

這是 Secret 看起來的樣子。

```yaml
apiVersion: v1
kind: Secret
metadata:
  # name 必須是 "bootstrap-token-<token id>" 格式的
  name: bootstrap-token-07401b
  namespace: kube-system

# type 必須是 'bootstrap.kubernetes.io/token'
type: bootstrap.kubernetes.io/token
stringData:
  # 供人閱讀的描述，可選。
  description: "The default bootstrap token generated by 'kubeadm init'."

  # 令牌 ID 和祕密信息，必需。
  token-id: 07401b
  token-secret: f395accd246ae52d

  # 可選的過期時間字段
  expiration: 2017-03-10T03:22:11Z

  # 允許的用法
  usage-bootstrap-authentication: "true"
  usage-bootstrap-signing: "true"

  # 令牌要認證爲的額外組，必須以 "system:bootstrappers:" 開頭
  auth-extra-groups: system:bootstrappers:worker,system:bootstrappers:ingress
```

<!--
The type of the secret must be `bootstrap.kubernetes.io/token` and the name must
be `bootstrap-token-<token id>`. It must also exist in the `kube-system` namespace.

The `usage-bootstrap-*` members indicate what this secret is intended to be used for.
A value must be set to `true` to be enabled.
-->
Secret 的類型必須是 `bootstrap.kubernetes.io/token`，而且名字必須是 `bootstrap-token-<token id>`。
令牌必須存在於 `kube-system` 名字空間中。

`usage-bootstrap-*` 成員表明這個 Secret 的用途。啓用時，值必須設置爲 `true`。

<!--
* `usage-bootstrap-authentication` indicates that the token can be used to
authenticate to the API server as a bearer token.
* `usage-bootstrap-signing` indicates that the token may be used to sign the
`cluster-info` ConfigMap as described below.
-->
* `usage-bootstrap-authentication` 表示令牌可以作爲持有者令牌用於 API 伺服器的身份認證。
* `usage-bootstrap-signing` 表示令牌可被用於 `cluster-info` ConfigMap 的簽名，
  就像下面描述的那樣。

<!--
The `expiration` field controls the expiry of the token. Expired tokens are
rejected when used for authentication and ignored during ConfigMap signing.
The expiry value is encoded as an absolute UTC time using [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339). Enable the
`tokencleaner` controller to automatically delete expired tokens.
-->
`expiration` 字段控制令牌的失效期。過期的令牌在用於身份認證時會被拒絕，在用於
ConfigMap 簽名時會被忽略。
過期時間值是遵循 [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)
進行編碼的 UTC 時間。啓用 TokenCleaner 控制器會自動刪除過期的令牌。

<!--
## Token Management with kubeadm

You can use the `kubeadm` tool to manage tokens on a running cluster. See the
[kubeadm token docs](/docs/reference/setup-tools/kubeadm/kubeadm-token/) for details.
-->
## 使用 `kubeadm` 管理令牌   {#token-management-with-kubeadm}

你可以使用 `kubeadm` 工具管理運行中叢集上的令牌。
參見 [kubeadm token 文檔](/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-token/)
以瞭解詳細資訊。

<!--
## ConfigMap Signing

In addition to authentication, the tokens can be used to sign a ConfigMap.
This is used early in a cluster bootstrap process before the client trusts the API
server. The signed ConfigMap can be authenticated by the shared token.

Enable ConfigMap signing by enabling the `bootstrapsigner` controller on the
Controller Manager.
-->
### ConfigMap 簽名  {#configmap-signing}

除了身份認證，令牌還可以用於簽名 ConfigMap。
這一用法發生在叢集啓動過程的早期，在客戶端信任 API 伺服器之前。
被簽名的 ConfigMap 可以被共享令牌完成身份認證。

通過在控制器管理器上啓用 `bootstrapsigner` 控制器可以啓用 ConfigMap 簽名特性。

```
--controllers=*,bootstrapsigner
```

<!--
The ConfigMap that is signed is `cluster-info` in the `kube-public` namespace.
The typical flow is that a client reads this ConfigMap while unauthenticated and
ignoring TLS errors. It then validates the payload of the ConfigMap by looking
at a signature embedded in the ConfigMap.

The ConfigMap may look like this:
-->
被簽名的 ConfigMap 是 `kube-public` 名字空間中的 `cluster-info`。
典型的工作流中，客戶端在未經認證和忽略 TLS 報錯的狀態下讀取這個 ConfigMap。
通過檢查 ConfigMap 中嵌入的簽名校驗 ConfigMap 的載荷。

ConfigMap 會是這個樣子的：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-info
  namespace: kube-public
data:
  jws-kubeconfig-07401b: eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U
  kubeconfig: |
    apiVersion: v1
    clusters:
    - cluster:
        certificate-authority-data: <非常長的證書數據>
        server: https://10.138.0.2:6443
      name: ""
    contexts: []
    current-context: ""
    kind: Config
    preferences: {}
    users: []
```

<!--
The `kubeconfig` member of the ConfigMap is a config file with only the cluster
information filled out. The key thing being communicated here is the
`certificate-authority-data`. This may be expanded in the future.
-->
ConfigMap 的 `kubeconfig` 成員是一個填好了叢集資訊的設定檔案。
這裏主要交換的資訊是 `certificate-authority-data`。在將來可能會有擴展。

<!--
The signature is a JWS signature using the "detached" mode. To validate the
signature, the user should encode the `kubeconfig` payload according to JWS
rules (base64 encoded while discarding any trailing `=`). That encoded payload
is then used to form a whole JWS by inserting it between the 2 dots. You can
verify the JWS using the `HS256` scheme (HMAC-SHA256) with the full token (e.g.
`07401b.f395accd246ae52d`) as the shared secret. Users _must_ verify that HS256
is used.
-->
簽名是一個使用 “detached” 模式生成的 JWS 簽名。
爲了檢驗簽名，使用者應該按照 JWS 規則（base64 編碼且丟掉結尾的 `=`）對
`kubeconfig` 的載荷進行編碼。完成編碼的載荷會被插入到兩個句點中間，形成完整的
JWS。你可以使用完整的令牌（比如 `07401b.f395accd246ae52d`）作爲共享密鑰，
通過 `HS256` 方式 (HMAC-SHA256) 對 JWS 進行校驗。
使用者**必須**確保使用了 HS256。

{{< warning >}}
<!--
Any party with a bootstrapping token can create a valid signature for that
token. When using ConfigMap signing it's discouraged to share the same token with
many clients, since a compromised client can potentially man-in-the middle another
client relying on the signature to bootstrap TLS trust.
-->
任何擁有了啓動引導令牌的主體都可以爲該令牌生成一個合法的簽名。
當使用 ConfigMap 簽名時，非常不建議針對很多客戶使用相同的令牌，因爲某個被攻擊的
客戶可能對另一個一來簽名來開啓 TLS 信任的客戶發起中間人攻擊。
{{< /warning >}}

<!--
Consult the [kubeadm implementation details](/docs/reference/setup-tools/kubeadm/implementation-details/)
section for more information.
-->
參考 [kubeadm 實現細節](/zh-cn/docs/reference/setup-tools/kubeadm/implementation-details/)
瞭解更多資訊。

