---
layout: blog
title: "Kubernetes 1.25: cgroup v2 升級到 GA"
date: 2022-08-31
slug: cgroupv2-ga-1-25
---

<!--
layout: blog
title: "Kubernetes 1.25: cgroup v2 graduates to GA"
date: 2022-08-31
slug: cgroupv2-ga-1-25
-->

<!--
**Authors:**: David Porter (Google), Mrunal Patel (Red Hat)
-->
**作者**: David Porter (Google), Mrunal Patel (Red Hat)

<!--
Kubernetes 1.25 brings cgroup v2 to GA (general availability), letting the
[kubelet](/docs/concepts/overview/components/#kubelet) use the latest container resource
management capabilities.
-->
Kubernetes 1.25 將 cgroup v2 正式發佈（GA），
讓 [kubelet](/zh-cn/docs/concepts/overview/components/#kubelet) 使用最新的容器資源管理能力。

<!--
## What are cgroups?
-->
## 什麼是 cgroup？

<!--
Effective [resource management](/docs/concepts/configuration/manage-resources-containers/) is a
critical aspect of Kubernetes. This involves managing the finite resources in
your nodes, such as CPU, memory, and storage.

*cgroups* are a Linux kernel capability that establish resource management
functionality like limiting CPU usage or setting memory limits for running
processes.
-->
有效的[資源管理](/zh-cn/docs/concepts/configuration/manage-resources-containers/)是 Kubernetes 的一個關鍵方面。
這涉及管理節點中的有限資源，例如 CPU、內存和存儲。

**cgroups** 是一種可建立資源管理功能的 Linux 內核能力，
例如爲正在運行的進程限制 CPU 使用率或設置內存限制。

<!--
When you use the resource management capabilities in Kubernetes, such as configuring
[requests and limits for Pods and containers](/docs/concepts/configuration/manage-resources-containers/#requests-and-limits),
Kubernetes uses cgroups to enforce your resource requests and limits.

The Linux kernel offers two versions of cgroups: cgroup v1 and cgroup v2.
-->
當你使用 Kubernetes 中的資源管理能力時，例如配置 
[Pod 和容器的請求和限制](/zh-cn/docs/concepts/configuration/manage-resources-containers/#requests-and-limits)，
Kubernetes 會使用 cgroups 來強制執行你的資源請求和限制。

Linux 內核提供了兩個版本的 cgroup：cgroup v1 和 cgroup v2。

<!--
## What is cgroup v2?
-->
## 什麼是 cgroup v2？

<!--
cgroup v2 is the latest version of the Linux cgroup API. cgroup v2 provides a
unified control system with enhanced resource management capabilities.

cgroup v2 has been in development in the Linux Kernel since 2016 and in recent
years has matured across the container ecosystem. With Kubernetes 1.25, cgroup
v2 support has graduated to general availability.
-->
cgroup v2 是 Linux cgroup API 的最新版本,
提供了一個具有增強的資源管理能力的統一控制系統。

自 2016 年以來，cgroup v2 一直在 Linux 內核中進行開發，
近年來在整個容器生態系統中已經成熟。在 Kubernetes 1.25 中，
對 cgroup v2 的支持已升級爲正式發佈。

<!--
Many recent releases of Linux distributions have switched over to cgroup v2 by
default so it's important that Kubernetes continues to work well on these new
updated distros.

cgroup v2 offers several improvements over cgroup v1, such as the following:
-->
默認情況下，許多最新版本的 Linux 發行版已切換到 cgroup v2，
因此 Kubernetes 繼續在這些新更新的發行版上正常運行非常重要。

cgroup v2 對 cgroup v1 進行了多項改進，例如：

<!--
* Single unified hierarchy design in API
* Safer sub-tree delegation to containers
* Newer features like [Pressure Stall Information](https://www.kernel.org/doc/html/latest/accounting/psi.html)
* Enhanced resource allocation management and isolation across multiple resources
    * Unified accounting for different types of memory allocations (network and kernel memory, etc)
    * Accounting for non-immediate resource changes such as page cache write backs
-->
* API 中單個統一的層次結構設計
* 爲容器提供更安全的子樹委派能力
* [壓力阻塞信息](https://www.kernel.org/doc/html/latest/accounting/psi.html)等新功能
* 增強的資源分配管理和跨多個資源的隔離
  * 統一覈算不同類型的內存分配（網絡和內核內存等）
  * 考慮非即時資源更改，例如頁面緩存回寫

<!--
Some Kubernetes features exclusively use cgroup v2 for enhanced resource
management and isolation. For example,
the [MemoryQoS feature](/blog/2021/11/26/qos-memory-resources/) improves
memory utilization and relies on cgroup v2 functionality to enable it. New
resource management features in the kubelet will also take advantage of the new
cgroup v2 features moving forward.
-->
一些 Kubernetes 特性專門使用 cgroup v2 來增強資源管理和隔離。 
例如，[MemoryQoS 特性](/blog/2021/11/26/qos-memory-resources/)提高了內存利用率並依賴
cgroup v2 功能來啓用它。kubelet 中的新資源管理特性也將利用新的 cgroup v2 特性向前發展。

<!--
## How do you use cgroup v2?

Many Linux distributions are switching to cgroup v2 by default; you might start
using it the next time you update the Linux version of your control plane and
nodes!

Using a Linux distribution that uses cgroup v2 by default is the recommended
method. Some of the popular Linux distributions that use cgroup v2 include the
following:

* Container Optimized OS (since M97)
* Ubuntu (since 21.10)
* Debian GNU/Linux (since Debian 11 Bullseye)
* Fedora (since 31)
* Arch Linux (since April 2021)
* RHEL and RHEL-like distributions (since 9)
-->
## 如何使用 cgroup v2?

許多 Linux 發行版默認切換到 cgroup v2； 
你可能會在下次更新控制平面和節點的 Linux 版本時開始使用它！

推薦使用默認使用 cgroup v2 的 Linux 發行版。 
一些使用 cgroup v2 的流行 Linux 發行版包括：

* Container-Optimized OS（從 M97 開始）
* Ubuntu（從 21.10 開始，推薦 22.04+）
* Debian GNU/Linux（從 Debian 11 Bullseye 開始）
* Fedora（從 31 開始）
* Arch Linux（從 2021 年 4 月開始）
* RHEL 和類似 RHEL 的發行版（從 9 開始）

<!--
To check if your distribution uses cgroup v2 by default,
refer to [Check your cgroup version](/docs/concepts/architecture/cgroups/#check-cgroup-version) or
consult your distribution's documentation.

If you're using a managed Kubernetes offering, consult your provider to
determine how they're adopting cgroup v2, and whether you need to take action.

To use cgroup v2 with Kubernetes, you must meet the following requirements:
-->
要檢查你的發行版是否默認使用 cgroup v2，
請參閱你的發行版文檔或遵循[識別 Linux 節點上的 cgroup 版本](/zh-cn/docs/concepts/architecture/cgroups/#check-cgroup-version)。

如果你使用的是託管 Kubernetes 產品，請諮詢你的提供商以確定他們如何採用 cgroup v2，
以及你是否需要採取行動。

要將 cgroup v2 與 Kubernetes 一起使用，必須滿足以下要求：

<!--
* Your Linux distribution enables cgroup v2 on kernel version 5.8 or later
* Your container runtime supports cgroup v2. For example:
  * [containerd](https://containerd.io/) v1.4 or later
  * [cri-o](https://cri-o.io/) v1.20 or later
* The kubelet and the container runtime are configured to use the [systemd cgroup driver](/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver)
-->
* 你的 Linux 發行版在內核版本 5.8 或更高版本上啓用 cgroup v2
* 你的容器運行時支持 cgroup v2。例如：
   * [containerd](https://containerd.io/) v1.4 或更高版本
   * [cri-o](https://cri-o.io/) v1.20 或更高版本
* kubelet 和容器運行時配置爲使用 [systemd cgroup 驅動程序](/zh-cn/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver)

<!--
The kubelet and container runtime use a [cgroup driver](/docs/setup/production-environment/container-runtimes#cgroup-drivers)
to set cgroup paramaters. When using cgroup v2, it's strongly recommended that both
the kubelet and your container runtime use the
[systemd cgroup driver](/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver),
so that there's a single cgroup manager on the system. To configure the kubelet
and the container runtime to use the driver, refer to the
[systemd cgroup driver documentation](/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver).
-->
kubelet 和容器運行時使用 [cgroup 驅動](/zh-cn/docs/setup/production-environment/container-runtimes#cgroup-drivers) 
來設置 cgroup 參數。使用 cgroup v2 時，強烈建議 kubelet 和你的容器運行時都使用 
[systemd cgroup 驅動程序](/zh-cn/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver)，
以便系統上只有一個 cgroup 管理員。要配置 kubelet 和容器運行時以使用該驅動程序，
請參閱 [systemd cgroup 驅動程序文檔](/zh-cn/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver)。

<!--
## Migrate to cgroup v2

When you run Kubernetes with a Linux distribution that enables cgroup v2, the
kubelet should automatically adapt without any additional configuration
required, as long as you meet the requirements.

In most cases, you won't see a difference in the user experience when you
switch to using cgroup v2 unless your users access the cgroup file system
directly.
-->
## 遷移到 cgroup v2

當你使用啓用 cgroup v2 的 Linux 發行版運行 Kubernetes 時，只要你滿足要求，
kubelet 應該會自動適應而無需任何額外的配置。

在大多數情況下，除非你的用戶直接訪問 cgroup 文件系統，
否則當你切換到使用 cgroup v2 時，不會感知到用戶體驗有什麼不同。

<!--
If you have applications that access the cgroup file system directly, either on
the node or from inside a container, you must update the applications to use
the cgroup v2 API instead of the cgroup v1 API.

Scenarios in which you might need to update to cgroup v2 include the following:

* If you run third-party monitoring and security agents that depend on the cgroup file system, update the
  agents to versions that support cgroup v2.
* If you run [cAdvisor](https://github.com/google/cadvisor) as a stand-alone
  DaemonSet for monitoring pods and containers, update it to v0.43.0 or later.
* If you deploy Java applications with the JDK, prefer to use JDK 11.0.16 and
  later or JDK 15 and later, which [fully support cgroup v2](https://bugs.openjdk.org/browse/JDK-8230305).
-->
如果你在節點上或從容器內直接訪問 cgroup 文件系統的應用程序，
你必須更新應用程序以使用 cgroup v2 API 而不是 cgroup v1 API。

你可能需要更新到 cgroup v2 的場景包括：

* 如果你運行依賴於 cgroup 文件系統的第三方監控和安全代理，請將代理更新到支持 cgroup v2 的版本。
* 如果你將 [cAdvisor](https://github.com/google/cadvisor) 作爲獨立的 DaemonSet 運行以監控 Pod 和容器，
  請將其更新到 v0.43.0 或更高版本。
* 如果你使用 JDK 部署 Java 應用程序，首選使用[完全支持 cgroup v2](https://bugs.openjdk.org/browse/JDK-8230305)
  的 JDK 11.0.16 及更高版本或 JDK 15 及更高版本。

<!--
## Learn more

* Read the [Kubernetes cgroup v2 documentation](/docs/concepts/architecture/cgroups/)
* Read the enhancement proposal, [KEP 2254](https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2254-cgroup-v2/README.md)
* Learn more about
  [cgroups](https://man7.org/linux/man-pages/man7/cgroups.7.html) on Linux Manual Pages
  and [cgroup v2](https://docs.kernel.org/admin-guide/cgroup-v2.html) on the Linux Kernel documentation
-->
## 進一步瞭解

* 閱讀 [Kubernetes cgroup v2 文檔](/zh-cn/docs/concepts/architecture/cgroups/)
* 閱讀增強提案 [KEP 2254](https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2254-cgroup-v2/README.md)
* 學習更多關於 Linux 手冊頁上的 [cgroups](https://man7.org/linux/man-pages/man7/cgroups.7.html) 和 Linux 內核文檔上的
  [cgroup v2](https://docs.kernel.org/admin-guide/cgroup-v2.html)

<!--
## Get involved

Your feedback is always welcome! SIG Node meets regularly and are available in
the `#sig-node` channel in the Kubernetes [Slack](https://slack.k8s.io/), or
using the SIG [mailing list](https://github.com/kubernetes/community/tree/master/sig-node#contact).

cgroup v2 has had a long journey and is a great example of open source
community collaboration across the industry because it required work across the
stack, from the Linux Kernel to systemd to various container runtimes, and (of
course) Kubernetes.
-->
## 參與其中

隨時歡迎你的反饋！SIG Node 定期開會，可在 Kubernetes [Slack](https://slack.k8s.io/)的 
`#sig-node` 頻道中獲得，或使用 SIG [郵件列表](https://github.com/kubernetes/community/tree/master/sig-node#contact)。

cgroup v2 經歷了漫長的旅程，是整個行業開源社區協作的一個很好的例子，
因爲它需要跨堆棧的工作，從 Linux 內核到 systemd 到各種容器運行時，當然還有 Kubernetes。

<!--
## Acknowledgments

We would like to thank [Giuseppe Scrivano](https://github.com/giuseppe) who
initiated cgroup v2 support in Kubernetes, and reviews and leadership from the
SIG Node community including chairs [Dawn Chen](https://github.com/dchen1107)
and [Derek Carr](https://github.com/derekwaynecarr).

We'd also like to thank the maintainers of container runtimes like Docker,
containerd and CRI-O, and the maintainers of components like
[cAdvisor](https://github.com/google/cadvisor)
and [runc, libcontainer](https://github.com/opencontainers/runc),
which underpin many container runtimes. Finally, this wouldn't have been
possible without support from systemd and upstream Linux Kernel maintainers.

It's a team effort!
-->
## 致謝

我們要感謝 [Giuseppe Scrivano](https://github.com/giuseppe) 在 Kubernetes 中發起對 cgroup v2 的支持，
還要感謝 SIG Node 社區主席 [Dawn Chen](https://github.com/dchen1107) 和
[Derek Carr](https://github.com/derekwaynecarr) 所作的審查和領導工作。

我們還要感謝 Docker、containerd 和 CRI-O 等容器運行時的維護者，
以及支持多種容器運行時的 [cAdvisor](https://github.com/google/cadvisor) 和
[runc, libcontainer](https://github.com/opencontainers/runc) 等組件的維護者。
最後，如果沒有 systemd 和上游 Linux 內核維護者的支持，這將是不可能的。