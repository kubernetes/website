---
layout: blog
title: "Kubernetes v1.34: 使用 Init 容器定義應用環境變量"
date: 2025-09-10T10:30:00-08:00
slug: kubernetes-v1-34-env-files
author: >
  HirazawaUi
translator: Michael Yao (DaoCloud)
---
<!--
layout: blog
title: "Kubernetes v1.34: Use An Init Container To Define App Environment Variables"
date: 2025-09-10T10:30:00-08:00
draft: true
slug: kubernetes-v1-34-env-files
author: >
  HirazawaUi
-->

<!--
Kubernetes typically uses ConfigMaps and Secrets to set environment variables,
which introduces additional API calls and complexity,
For example, you need to separately manage the Pods of your workloads 
and their configurations, while ensuring orderly 
updates for both the configurations and the workload Pods.

Alternatively, you might be using a vendor-supplied container 
that requires environment variables (such as a license key or a one-time token),
but you don’t want to hard-code them or mount volumes just to get the job done.
-->
Kubernetes 通常使用 ConfigMap 和 Secret 來設置環境變量，
這會引入額外的 API 調用和複雜性。例如，你需要分別管理工作負載的 Pod 和它們的設定，
同時還要確保設定和工作負載 Pod 的有序更新。

另外，你可能在使用一個供應商提供的、需要環境變量（例如授權密鑰或一次性令牌）的容器，
但你又不想對這些變量進行硬編碼，或者僅僅爲了完成工作而掛載卷。

<!--
If that's the situation you are in, you now have a new (alpha) way to
achieve that. Provided you have the `EnvFiles`
[feature gate](/docs/reference/command-line-tools-reference/feature-gates/)
enabled across your cluster, you can tell the kubelet to load a container's
environment variables from a volume (the volume must be part of the Pod that
the container belongs to).
this feature gate allows you to load environment variables directly from a file in an emptyDir volume
without actually mounting that file into the container.
It’s a simple yet elegant solution to some surprisingly common problems.
-->
如果你正面對這種情況，現在有一種新的（Alpha）方式來實現。只要你在叢集中啓用了 `EnvFiles`
[特性門控](/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)，
你就可以告訴 kubelet 從一個卷中加載容器的環境變量（此卷必須是容器所屬的 Pod）。
這個特性門控允許你直接從 `emptyDir` 卷中的檔案加載環境變量，而不需要將該檔案實際掛載到容器中。
這是一個簡單而優雅的解決方案，可以應對一些出乎意料的常見問題。

<!--
## What’s this all about?
At its core, this feature allows you to point your container to a file,
one generated by an `initContainer`,
and have Kubernetes parse that file to set your environment variables.
The file lives in an `emptyDir` volume (a temporary storage space that lasts as long as the pod does),
Your main container doesn’t need to mount the volume.
The kubelet will read the file and inject these variables when the container starts.
-->
## 特性概述  {#what-s-this-all-about}

從核心上來說，這個特性允許你將容器指向一個檔案，該檔案由 `initContainer` 生成，
然後讓 Kubernetes 解析該檔案以設置你的環境變量。此檔案位於一個 `emptyDir`
卷中（這是一種臨時儲存空間，只要 Pod 存在就會保留），你的主容器不需要掛載此卷。
kubelet 會在容器啓動時讀取檔案並注入這些變量。

<!--
## How It Works
Here's a simple example:
-->
## 工作原理  {#how-it-works}

這裏有一個簡單的例子：

```yaml
apiVersion: v1
kind: Pod
spec:
  initContainers:
  - name: generate-config
    image: busybox
    command: ['sh', '-c', 'echo "CONFIG_VAR=HELLO" > /config/config.env']
    volumeMounts:
    - name: config-volume
      mountPath: /config
  containers:
  - name: app-container
    image: gcr.io/distroless/static
    env:
    - name: CONFIG_VAR
      valueFrom:
        fileKeyRef:
          path: config.env
          volumeName: config-volume
          key: CONFIG_VAR
  volumes:
  - name: config-volume
    emptyDir: {}
```

<!--
Using this approach is a breeze.
You define your environment variables in the pod spec using the `fileKeyRef` field,
which tells Kubernetes where to find the file and which key to pull.
The file itself resembles the standard for .env syntax (think KEY=VALUE),
and (for this alpha stage at least) you must ensure that it is written into
an `emptyDir` volume. Other volume types aren't supported for this feature.
At least one init container must mount that `emptyDir` volume (to write the file),
but the main container doesn’t need to—it just gets the variables handed to it at startup.
-->
使用這種方法非常簡單。你在 Pod 規約中使用 `fileKeyRef` 字段定義環境變量，
此字段告訴 Kubernetes 去哪裏找到檔案以及要提取哪個鍵。
此檔案本身類似於 `.env` 語法的標準格式（即 `KEY=VALUE`），
並且（至少在這個 Alpha 階段）你必須確保它被寫入到一個 `emptyDir` 卷中。
其他類型的卷在此特性中不受支持。至少有一個 Init 容器必須掛載該 `emptyDir` 卷（以寫入檔案），
但主容器不需要掛載它——它在啓動時就能直接獲取這些變量。

<!--
## A word on security
While this feature supports handling sensitive data such as keys or tokens, 
note that its implementation relies on `emptyDir` volumes mounted into pod.
Operators with node filesystem access could therefore 
easily retrieve this sensitive data through pod directory paths.

If storing sensitive data like keys or tokens using this feature,
ensure your cluster security policies effectively protect nodes
against unauthorized access to prevent exposure of confidential information.
-->
## 關於安全性  {#a-word-on-security}

雖然此特性支持處理密鑰或令牌等敏感資料，但需要注意它的實現依賴於掛載到 Pod 的 `emptyDir` 卷。
具有節點檔案系統訪問權限的操作人員因此可以通過 Pod 目錄路徑輕易獲取這些敏感資料。

如果使用此特性儲存密鑰或令牌等敏感資料，確保你的叢集安全策略能夠有效保護節點免受未經授權的訪問，
以防止機密資訊泄露。

<!--
## Summary
This feature will eliminate a number of complex workarounds used today, simplifying
apps authoring, and opening doors for more use cases. Kubernetes stays flexible and
open for feedback. Tell us how you use this feature or what is missing.
-->
## 總結 {#summary}

此特性將消除如今使用的許多複雜變通方法，簡化應用編寫，併爲更多使用場景打開大門。
Kubernetes 保持靈活性，歡迎反饋。請告訴我們你是如何使用這個特性的，或者此特性還缺少什麼。
