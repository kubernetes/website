---
layout: blog
title: "Kubernetes v1.35: Конфігурація Kubelet Drop-in Directory переходить до GA"
date: 2025-12-22T10:30:00-08:00
slug: kubernetes-v1-35-kubelet-config-drop-in-directory-ga
author: >
  Sohan Kunkerkar (Red Hat)
translator: >
  [Андрій Головін](https://github.com/Andygol)
---

З останнім випуском Kubernetes v1.35 стала загальнодоступною підтримка теки для конфігураційних файлів kubelet. Нова стабільна функція спрощує управління конфігурацією kubelet у великих гетерогенних кластерах.

У версії 1.35 аргумент командного рядка kubelet `--config-dir` готовий до використання у промислових умовах і повністю підтримується, що дозволяє вказати теку, яка містить файли конфігурації kubelet. Усі файли в цій теці будуть автоматично обʼєднані з основною конфігурацією kubelet. Це дозволяє адміністраторам кластерів підтримувати єдину базову конфігурацію для kubelet, одночасно забезпечуючи цільові налаштування для різних груп вузлів або випадків використання, без складних інструментів або ручного управління конфігурацією.

## Проблема: управління конфігурацією kubelet у великому масштабі {##the-problem-managing-kubelet-configuration-at-scale}

У міру того, як кластери Kubernetes стають більшими та складнішими, вони часто включають гетерогенні пули вузлів з різними апаратними можливостями, вимогами до робочого навантаження та експлуатаційними обмеженнями. Ця різноманітність вимагає різних конфігурацій kubelet у різних групах вузлів, але управління цими різноманітними конфігураціями у великому масштабі стає все більш складним завданням. Виникає кілька проблемних моментів:

- **Дрейф конфігурації**: різні вузли можуть мати дещо різні конфігурації, що призводить до несумісної поведінки
- **Налаштування групи вузлів**: вузли GPU, edge вузли та стандартні обчислювальні вузли часто вимагають різних налаштувань kubelet
- **Операційні накладні витрати**: підтримка окремих, повних файлів конфігурації для кожного типу вузла є схильною до помилок і складною для аудиту
- **Управління змінами**: впровадження змін конфігурації в гетерогенних пулах вузлів вимагає ретельної координації

До того, як ця підтримка була додана до Kubernetes, адміністратори кластерів мали вибирати між використанням єдиного монолітного файлу конфігурації для всіх вузлів, ручним веденням декількох повних файлів конфігурації або використанням окремих інструментів. Кожен підхід мав свої недоліки. Перехід до стабільної версії надає адміністраторам кластерів повну підтримку fourth way to solve that challenge.

## Приклади використання {#example-use-cases}

### Управління гетерогенними пулами вузлів {#managing-heterogeneous-node-pools}

Розглянемо кластер із декількома типами вузлів: стандартні обчислювальні вузли, вузли з високою продуктивністю (наприклад, із графічними процесорами або великим обʼємом памʼяті) та edge вузли зі спеціальними вимогами.

#### Базова конфігурація {#base-configuration}

Файл: `00-base.conf`

```yaml
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
clusterDNS:
  - "10.96.0.10"
clusterDomain: cluster.local
```

#### Перевизначення для вузла з високою пропускною здатністю {#high-capacity-node-override}

Файл: `50-high-capacity-nodes.conf`

```yaml
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
maxPods: 50
systemReserved:
  memory: "4Gi"
  cpu: "1000m"
```

#### Перевизначення для edge вузлів {#edge-node-override}

Файл: `50-edge-nodes.conf` (edge compute typically has lower capacity)

```yaml
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
evictionHard:
  memory.available: "500Mi"
  nodefs.available: "5%"
```

Завдяки такій структурі вузли з високою пропускною здатністю застосовують як базову конфігурацію, так і перевизначення, що стосуються пропускної здатності, тоді як edge вузли застосовують базову конфігурацію з налаштуваннями, що стосуються edge.

### Поступове впровадження конфігурації {#gradual-configuration-rollouts}

Під час впровадження змін у конфігурації ви можете:

1. Додати новий файл із високим числовим префіксом (наприклад, `99-new-feature.conf`)
2. Протестувати зміни на підмножині вузлів
3. Поступово впроваджувати зміни на інших вузлах
4. Після стабілізації обʼєднати зміни в базову конфігурацію

## Viewing the merged configuration {#viewing-the-merged-configuration}

Оскільки конфігурація тепер розподілена між декількома файлами, ви можете перевірити остаточну обʼєднану конфігурацію за допомогою точки доступу kubelet `/configz`:

```bash
# Запустіть kubectl proxy
kubectl proxy

# В іншому терміналі завантажте обʼєднану конфігурацію
# Змініть замісник “<node-name>” перед запуском команди curl
curl -X GET http://127.0.0.1:8001/api/v1/nodes/<node-name>/proxy/configz | jq .
```

Це показує фактичну конфігурацію, яку kubelet використовує після застосування всіх обʼєднань. Обʼєднана конфігурація також включає будь-які налаштування конфігурації, які були вказані за допомогою аргументів командного рядка kubelet.

Детальні інструкції з налаштування, приклади конфігурації та поведінка злиття наведені в офіційній документації:

- [Встановлення параметрів Kubelet за допомогою файлу конфігурації](/docs/tasks/administer-cluster/kubelet-config-file/#kubelet-conf-d)
- [Злиття текстових файлів конфігурації Kubelet](/docs/reference/node/kubelet-config-directory-merging/)

## Рекомендації {#good-practices}

При використанні теки конфігурацій kubelet:

1. **Тестуйте конфігурації поступово**: завжди тестуйте нові конфігурації на підмножині вузлів, перш ніж розгортати їх у всьому кластері, щоб мінімізувати ризики.

2. **Контролюйте версії своїх конфігурацій**: зберігайте файли конфігурації (або джерело конфігурації, з якого вони генеруються) у системі контролю версій разом із вашою інфраструктурою як кодом, щоб відстежувати зміни та мати можливість легко повертатися до попередніх версій.

3. **Використовуйте числові префікси для передбачуваного упорядкування**: називайте файли за допомогою числових префіксів (наприклад, `00-`, `50-`, `90-`) для явного контролю порядку злиття та забезпечення зрозумілості шарування конфігурації для інших адміністраторів

4. **Звертайте увагу на тимчасові файли**: деякі текстові редактори під час редагування автоматично створюють резервні файли (наприклад, `.bak`, `.swp` або файли з розширенням `~`) у тій самій теці. Переконайтеся, що ці тимчасові або резервні файли не залишаються в теці конфігурації, оскільки вони можуть оброблятися kubelet.

## Подяки {#acknowledgments}

Ця функція була розроблена спільними зусиллями [SIG Node](https://github.com/kubernetes/community/tree/master/sig-node). Особлива подяка всім учасникам, які допомогли розробити, впровадити, протестувати та задокументувати цю функцію на всіх етапах її розвитку: від альфа-версії в v1.28, бета-версії в v1.30 до загальної доступності в v1.35.

Щоб надати відгук про цю функцію, приєднайтеся до [Kubernetes Node Special Interest Group](https://github.com/kubernetes/community/tree/master/sig-node), беріть участь в обговореннях в [публічному каналі Slack](http://slack.k8s.io/) (#sig-node) або подайте заявку на [GitHub](https://github.com/kubernetes/kubernetes/issues).

## Приєднуйтесь {#get-involved}

Якщо у вас є відгуки чи запитання щодо управління конфігурацією kubelet або ви хочете поділитися своїм досвідом використання цієї функції, приєднуйтесь до обговорення:

- [Сторінка спільноти SIG Node](https://github.com/kubernetes/community/tree/master/sig-node)
- [Kubernetes Slack](http://slack.k8s.io/) у каналі #sig-node
- [Список розсилки SIG Node](https://groups.google.com/forum/#!forum/kubernetes-sig-node)

SIG Node буде радий дізнатися про ваш досвід використання цієї функції у виробництві!
