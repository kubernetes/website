---
layout: blog
title: 'Kubernetes v1.34: Впровадження опції статичної політики менеджера CPU для розподілу кешу Uncore'
date: 2025-09-02T10:30:00-08:00
slug: kubernetes-v1-34-prefer-align-by-uncore-cache-cpumanager-static-policy-optimization
author: Charles Wong (AMD)
translator: >
  [Андрій Головін](https://github.com/Andygol)
---

Нова опція статичної політики менеджера CPU під назвою `prefer-align-cpus-by-uncorecache` була представлена в Kubernetes v1.32 як альфа-функція, а в Kubernetes v1.34 вона перейшла в **бета**-стадію. Ця опція політики менеджера CPU призначена для оптимізації продуктивності конкретних робочих навантажень, що працюють на процесорах з архітектурою _розділеного кешу uncore_. У цій статті пояснюється, що це означає і чому це корисно.

## Розуміння функції

### Що таке кеш uncore?

До відносно недавнього часу майже всі сучасні компʼютерні процесори мали монолітний кеш останнього рівня, який ділився між усіма ядрами в багатопроцесорному пакеті. Цей монолітний кеш також називається _кешем uncore_ (оскільки він не повʼязаний з конкретним ядром) або кешем третього рівня. Крім кешу третього рівня, існує інший кеш, який зазвичай називають кешем першого і другого рівня, який **повʼязаний** з конкретним ядром процесора.

Для зменшення затримки доступу між ядрами процесора та їх кешем нещодавно процесори на базі архітектури AMD64 та ARM впровадили архітектуру _розділеного кешу uncore_, де кеш останнього рівня ділиться на кілька фізичних кешів, які розділені відповідно до конкретних груп ядер у фізичному пакеті. Коротші відстані в межах пакета процесора допомагають зменшити затримку.

![Діаграма, що показує монолітний кеш зліва і розділений кеш справа](./mono_vs_split_uncore.png)

Kubernetes може розміщувати робочі навантаження таким чином, щоб враховувати топологію кешу в межах пакета CPU.

### Розміщення робочих навантажень з урахуванням кешу

Матриця нижче показує [затримку між CPU](https://github.com/nviennot/core-to-core-latency), виміряну в наносекундах (менше — краще) при передачі пакета між CPU через протокол когерентності кешу на процесорі, який використовує розділений кеш uncore. У цьому прикладі пакет процесора складається з 2 кешів uncore. Кожен кеш uncore обслуговує 8 ядер CPU.

![Таблиця, що показує показники латентності між CPU](./c2c_latency.png)

Сині елементи в матриці представляють затримку між CPU, які ділять один і той же кеш uncore, тоді як сірі елементи вказують на затримку між CPU, які відповідають різним кешам uncore. Затримка між CPU, які відповідають різним кешам, вища, ніж затримка між CPU, які належать до одного і того ж кешу.

З увімкненим `prefer-align-cpus-by-uncorecache`, [статичний Менеджер CPU](/docs/concepts/policy/node-resource-managers/#static-policy) намагається виділити ресурси CPU для контейнера таким чином, щоб всі CPU, призначені контейнеру, ділили один і той же кеш uncore. Ця політика працює на основі найкращих зусиль, прагнучи мінімізувати розподіл ресурсів CPU контейнера між кешами uncore, виходячи з вимог контейнера та враховуючи ресурси, які можна виділити на вузлі.

Запускаючи робоче навантаження, де це можливо, на наборі CPU, які використовують найменшу можливу кількість кешів uncore, програми отримують вигоду від зменшення затримки кешу (як видно з матриці вище) і зменшення конкуренції з іншими робочими навантаженнями, що може призвести до загального підвищення пропускної здатності. Перевага проявляється лише в тому випадку, якщо ваші вузли використовують топологію розділеного кешу uncore для своїх процесорів.

Наступна діаграма ілюструє розподіл кешу uncore, коли функція увімкнена.

![Діаграма, що показує приклад розподілу навантаження на процесор, стандартну статичну політику та політику prefer-align-cpus-by-uncorecache](./cache-align-diagram.png)

Стандартно Kubernetes не враховує топологію кешу uncore; контейнери отримують ресурси CPU за допомогою методології упаковки. Як наслідок, Контейнер 1 і Контейнер 2 можуть зазнати впливу "галасливого сусіда" через конкуренцію за доступ до кешу на Uncore Cache 0. Крім того, Контейнер 2 матиме CPU, розподілені між обома кешами, що може призвести до затримки між кешами.

З увімкненим `prefer-align-cpus-by-uncorecache`, кожен контейнер ізольований на окремому кеші. Це вирішує проблему конкуренції за кеш між контейнерами та мінімізує латентність кешу для використовуваних CPU.

## Використання

Звичайні випадки використання можуть включати телекомунікаційні програми, такі як vRAN, Mobile Packet Core та брандмауери. Важливо зазначити, що оптимізація, надана `prefer-align-cpus-by-uncorecache`, може залежати від робочого навантаження. Наприклад, програми, які обмежені пропускною здатністю памʼяті, можуть не отримати вигоду від розподілу кешу uncore, оскільки використання більшої кількості кешів uncore може збільшити доступ до пропускної здатності памʼяті.

## Увімкнення функції

Щоб увімкнути цю функцію, потрібно встановити політику менеджера CPU на `static` та увімкнути параметри політики менеджера CPU за допомогою `prefer-align-cpus-by-uncorecache`.

Для Kubernetes 1.34 функція знаходиться на стадії бета-тестування і вимагає також увімкнення [функціональних можливостей](https://docs/reference/command-line-tools-reference/feature-gates/) `CPUManagerPolicyBetaOptions`.

Додайте наступне до файлу конфігурації kubelet:

```yaml
kind: KubeletConfiguration
apiVersion: kubelet.config.k8s.io/v1beta1
featureGates:
  ...
  CPUManagerPolicyBetaOptions: true
cpuManagerPolicy: "static"
cpuManagerPolicyOptions:
  prefer-align-cpus-by-uncorecache: "true"
reservedSystemCPUs: "0"
...
```

Якщо ви вносите цю зміну до вже наявного вузла, видаліть файл `cpu_manager_state`, а потім перезапустіть kubelet.

`prefer-align-cpus-by-uncorecache` може бути увімкнено на вузлах з монолітним кешем uncore. Ця функція імітуватиме ефект розподілу сокетів з найкращими зусиллями та упакує ресурси CPU на сокеті, подібно до стандартної статичної політики менеджера CPU.

## Додаткова інформація

Дивіться статтю [Менеджери ресурсів вузлів](/docs/concepts/policy/node-resource-managers/) щоб дізнатися більше про менеджер CPU та доступні політики.

Ознайомтеся з [документацією](/docs/concepts/policy/node-resource-managers/#prefer-align-cpus-by-uncorecache) до `prefer-align-cpus-by-uncorecache`.

Дивіться [Kubernetes Enhancement Proposal](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/4800-cpumanager-split-uncorecache) для отримання додаткової інформації про те, як реалізовано `prefer-align-cpus-by-uncorecache`.

## Долучайтеся

Ця функція розробляється [SIG Node](https://github.com/Kubernetes/community/blob/master/sig-node/README.md). Якщо ви зацікавлені в допомозі в розробці цієї функції, наданні відгуків або участі в будь-яких інших поточних проектах SIG Node, будь ласка, відвідайте зустріч SIG Node для отримання додаткової інформації.
