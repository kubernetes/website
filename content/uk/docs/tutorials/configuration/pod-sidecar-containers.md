---
title: Використання контейнерів sidecar
content_type: tutorial
weight: 40
min-kubernetes-server-version: 1.29
---

<!-- overview -->

Цей розділ актуальний для людей, які впроваджують нову вбудовану функцію [sidecar-контейнерів](/docs/concepts/workloads/pods/sidecar-containers/) для своїх навантажень.

Sidecar-контейнери — це не нова концепція, про що було згадано в [блог-пості](/blog/2015/06/the-distributed-system-toolkit-patterns/) ще у 2015 році. Kubernetes дозволяв запускати декілька контейнерів у Pod, щоб реалізувати цю концепцію. Однак запуск sidecar-контейнера як звичайного контейнера має багато обмежень, які вирішуються за допомогою нової підтримки вбудованих sidecar-контейнерів.

{{< feature-state feature_gate_name="SidecarContainers" >}}

## {{% heading "objectives" %}}

- Зрозуміти необхідність використання sidecar-контейнерів.
- Вміти розвʼязувати проблеми з sidecar-контейнерами.
- Зрозуміти варіанти універсального "впровадження" sidecar-контейнерів у будь-яке навантаження.

## {{% heading "prerequisites" %}}

{{< include "task-tutorial-prereqs.md" >}} {{< version-check >}}

<!-- lessoncontent -->

## Огляд sidecar-контейнерів {#sidecar-containers-overview}

Sidecar-контейнери — це додаткові контейнери, які працюють разом з основним контейнером застосунку в межах одного {{< glossary_tooltip text="Podʼа" term_id="pod" >}}. Ці контейнери використовуються для покращення або розширення функціональності основного _app-контейнера_, надаючи додаткові послуги або функціональність, такі як логування, моніторинг, безпека або синхронізація даних, без прямого втручання в код основного застосунку. Детальніше можна прочитати на сторінці концепції [Sidecar-контейнерів](/docs/concepts/workloads/pods/sidecar-containers/).

Концепція sidecar-контейнерів не є новою, і є багато її реалізацій. Як і sidecar-контейнери, які ви, як особа, що визначає Pod, хочете запустити, ви також можете побачити, що деякі {{< glossary_tooltip text="надбудови" term_id="addons" >}} змінюють Podʼи, до того, як Podʼи почнуть працювати, додаючи додаткові sidecar-контейнери. Механізми _інʼєкцій_ цих додаткових sidecar-контейнерів часто використовують [мутуючі вебхуки](/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook). Наприклад, надбудова service mesh може впроваджувати sidecar-контейнер, який налаштовує взаємний TLS і шифрування під час передачі між різними Podʼами.

Хоча концепція sidecar-контейнерів не є новою, вбудована реалізація цієї функції в Kubernetes, однак, нова. І як і з будь-якою новою функцією, впровадження цієї функції може викликати певні труднощі.

Цей навчальний посібник досліджує труднощі та рішення, з якими можуть зіткнутися кінцеві користувачі, а також автори sidecar-контейнерів.

## Переваги вбудованих sidecar-контейнерів {#benefits-of-a-built-in-sidecar-containers}

Використання нативної підтримки sidecar-контейнерів у Kubernetes має кілька переваг:

1. Ви можете налаштувати нативний sidecar-контейнер так, щоб він запускався перед {{< glossary_tooltip text="init-контейнерами" term_id="init-container" >}}.
2. Вбудовані sidecar-контейнери можна налаштувати так, щоб вони гарантовано завершувалися останніми. Sidecar-контейнери завершують роботу за допомогою сигналу `SIGTERM`, коли всі звичайні контейнери завершили роботу та завершилися. Якщо sidecar-контейнер не завершує роботу коректно, сигнал `SIGKILL` буде використано для його завершення.
3. Для Jobs, коли `restartPolicy: OnFailure` або `restartPolicy: Never`, нативні sidecar-контейнери не блокують завершення Pod. Для старих sidecar-контейнерів потрібно було приділяти особливу увагу вирішенню цієї ситуації.
4. Також для Jobs, вбудовані sidecar-контейнери будуть продовжувати перезапускатися після завершення, навіть якщо звичайні контейнери не будуть цього робити при `restartPolicy: Never` у Pod.

Дивіться [відмінності від контейнерів ініціалізації](/docs/concepts/workloads/pods/sidecar-containers/#differences-from-application-containers) для додаткових відомостей.

## Впровадження вбудованих sidecar-контейнерів {#adopting-built-in-sidecar-containers}

[Функціональна можливість](/docs/reference/command-line-tools-reference/feature-gates/) `SidecarContainers` перебуває у стані бета-версії, починаючи з версії Kubernetes 1.29, і є стандартно увімкненою. Деякі кластери можуть мати цю функцію вимкненою або мати встановлене програмне забезпечення, яке не сумісне з цією функцією.

Коли це трапляється, Pod може бути відхилено або sidecar-контейнери можуть блокувати запуск Podʼа, роблячи Pod непридатним для використання. Цей стан легко виявити, оскільки Pod просто застряє на стадії ініціалізації. Однак рідко буває зрозуміло, що спричинило проблему.

Ось міркування та кроки з усунення несправностей, які можна виконати під час впровадження sidecar-контейнерів для свого навантаження.

### Переконайтеся, що функціональну можливість увімкнено {#ensure-the-feature-gate-is-enabled}

Перш за все, переконайтеся, що як API-сервер, так і вузли мають версію Kubernetes v1.29 або пізнішу. Функція не працюватиме на кластерах, де вузли працюють на більш ранніх версіях, де вона не увімкнена.

{{< alert title="Примітка" color="info" >}}

Функцію можна увімкнути на вузлах з версією 1.28. Поведінка завершення роботи вбудованих sidecar-контейнерів відрізнялася у версії 1.28, і не рекомендується налаштовувати поведінку sidecar-контейнера для цієї версії. Однак, якщо єдиною турботою є порядок запуску, вищенаведену заяву можна змінити на вузли, що працюють на версії 1.28 з увімкненою функціональною можливістю.

{{< /alert >}}

Ви повинні переконатися, що функціональна можливість увімкнено як для API-сервера (серверів) у межах панелі управління, **так і** для всіх вузлів.

Одним зі способів перевірити увімкнення функціональної можливості є виконання команди:

- Для API-сервера

  ```shell
  kubectl get --raw /metrics | grep kubernetes_feature_enabled | grep SidecarContainers
  ```

- Для окремого вузла

  ```shell
  kubectl get --raw /api/v1/nodes/<node-name>/proxy/metrics | grep kubernetes_feature_enabled | grep SidecarContainers
  ```

Якщо ви бачите щось на кшталт:

```none
kubernetes_feature_enabled{name="SidecarContainers",stage="BETA"} 1
```

це означає, що функцію увімкнено.

### Перевірка сторонніх інструментів і мутуючих вебхуків {#check-3rd-party-tooling-and-mutating-webhooks}

Якщо у вас виникли проблеми під час перевірки функції, це може бути ознакою того, що один зі сторонніх інструментів або мутуючих вебхуків не працюють.

Коли функціональну можливість `SidecarContainers` увімкнено, Podʼи отримують нове поле в їхньому API. Деякі інструменти або мутуючі вебхуки могли бути створені на основі попередньої версії Kubernetes API.

Якщо інструменти передають невідомі поля як є, використовуючи різні стратегії виправлення для змінни об’єкта Pod, це не буде проблемою. Однак є інструменти, які видалять невідомі поля; якщо у вас є такі, їх потрібно буде перекомпілювати з v1.28+ версією клієнтського коду Kubernetes API.

Спосіб перевірки цього полягає у використанні команди `kubectl describe pod` для вашого Podʼа, який пройшов через мутуючий admission webhook. Якщо будь-які інструменти вилучили нове поле (`restartPolicy: Always`), ви не побачите його у виводі команди.

Якщо ви зіткнулися з такою проблемою, рекомендується повідомити автора інструментів або вебхуків, щоб вони використовували одну зі стратегій накладання патчів для модифікації обʼєктів замість їх повного оновлення.

{{< alert title="Примітка" color="info" >}}

Мутуючий webhook може оновлювати Podʼи на основі певних умов. Таким чином, sidecar-контейнери можуть працювати для одних Podʼів, а для інших — ні.

{{< /alert >}}

### Автоматичне встромляння sidecar-контейнерів {#automatic-injection-of-sidecars}

Якщо ви використовуєте програмне забезпечення, яке автоматично встромляє sidecar-контейнери, існує кілька можливих стратегій, які ви можете застосувати, щоб забезпечити можливість використання нативних sidecar-контейнерів. Усі ці стратегії загалом є варіантами вибору того, чи буде Pod, до якого встромляється sidecar, розміщений на вузлі, який підтримує цю функцію.

Наприклад, можна ознайомитися з [цією дискусією в спільноті Istio](https://github.com/istio/istio/issues/48794), яка досліджує наведені нижче варіанти.

1. Позначення Podʼів, що розміщуються на вузлах із підтримкою sidecars. Ви можете використовувати мітки вузлів і node affinity, щоб позначити вузли, які підтримують sidecar-контейнери, і забезпечити розміщення Pods на цих вузлах.
2. Перевірка сумісності вузлів під час додавання контейнера. Під час впровадження sidecar-контейнерів можна використовувати такі стратегії перевірки сумісності вузлів:
   - Запитати версію вузла та припустити, що функціональну можливість увімкнено для версії 1.29+.
   - Запитати метрики Prometheus вузла та перевірити стан увімкнення функції.
   - Припустити, що вузли працюють із [підтримуваною версійною розбіжністю](/releases/version-skew-policy/#supported-version-skew) від API-сервера.
   - Можуть існувати інші власні способи визначення сумісності вузлів.
3. Розробка універсального інжектора sidecar-контейнерів. Ідея універсального sidecar-контейнера полягає в тому, щоб додати sidecar-контейнер як звичайний контейнер, а також як нативний sidecar-контейнер, і мати логіку на рівні виконання, яка визначить, який варіант працюватиме. Універсальний інжектор sidecar є ресурсозатратним, оскільки він враховуватиме запити двічі, але його можна розглядати як робоче рішення для особливих випадків.
   - Один зі способів полягає в тому, щоб під час запуску нативного sidecar-контейнера визначити версію вузла та завершити роботу негайно, якщо версія не підтримує функцію sidecar.
   - Розгляньте дизайн із виявленням функції під час виконання:
     - Визначте empty dir, щоб контейнери могли взаємодіяти один з одним.
     - Впровадьте init-контейнер, який назвемо `NativeSidecar`, з `restartPolicy=Always`.
     - `NativeSidecar` має записати файл в empty dir під час першого запуску та завершити роботу з кодом виходу `0`.
     - `NativeSidecar` під час повторного запуску (коли нативні sidecar підтримуються) перевіряє, чи файл уже існує в empty dir, і змінює його, вказуючи, що вбудовані sidecar-контейнери підтримуються і працюють.
     - Впровадьте звичайний контейнер, який назвемо `OldWaySidecar`.
     - `OldWaySidecar` під час запуску перевіряє наявність файлу в empty dir.
     - Якщо файл вказує, що `NativeSidecar` не працює, він припускає, що функція sidecar не підтримується, і працює як sidecar.
     - Якщо файл вказує, що `NativeSidecar` працює, він або не робить нічого та спить назавжди (у випадку, коли Pod має `restartPolicy=Always`), або завершить роботу негайно з кодом виходу `0` (у випадку, коли Pod має `restartPolicy!=Always`).

## {{% heading "whatsnext" %}}

- Дізнайтеся більше про [sidecar-контейнери](/docs/concepts/workloads/pods/sidecar-containers/).
