---
title: Використання kubectl для створення Deploymentʼа
weight: 10
description: |- 
  Дізнайтесь, що таке Deployment застосунків.
  Розгорніть свій перший застосунок у Kubernetes за допомогою kubectl.
---

<!DOCTYPE html>
<html lang="uk">

<body>

<div class="layout" id="top">

    <main class="content">

        <div class="row">
         <div class="col-md-8">
          <h3>Мета</h3>
            <ul>
                <li>Дізнатися, що таке Deployment застосунків.</li>
                <li>Розгорнути свій перший застосунок у Kubernetes за допомогою kubectl.</li>
                </ul>
            </div>

            <div class="col-md-8">
                <h3>Процеси Kubernetes Deployment</h3>

                {{< note >}}
                <p>Цей навчальний посібник використовує контейнер, який вимагає архітектури AMD64. Якщо ви використовуєте minikube на компʼютері з іншою архітектурою процесора, ви можете спробувати використовувати minikube з драйвером, який може емулювати AMD64. Наприклад, драйвер Docker Desktop може це зробити.</p>
                {{< /note >}}

                <p>
                Після створення <a href="/uk/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">працюючого кластера Kubernetes</a> ви можете розгортати свої контейнеризовані застосунки на його основі. Для цього створіть <b>розгортання (Deployment)</b> Kubernetes. Deployment вказує Kubernetes, як створювати та оновлювати екземпляри вашого застосунку. Після створення Deployment панель управління Kubernetes розподіляє екземпляри застосунків, що включені в цей Deployment, для запуску на окремих вузлах в кластері.
                </p>

                <p>Коли екземпляри застосунків створені, контролер розгортання Kubernetes безперервно відстежує їх стан. Якщо вузол, на якому запущено екземпляр, вимикається або видаляється, контролер розгортання замінює екземпляр новим на іншому вузлі в кластері. <b>Це забезпечує механізм самовідновлення для розвʼязання проблем з відмовою або обслуговуванням вузлів.</b></p>

                <p>У світі до-оркестрування часто використовувалися скрипти встановлення для запуску застосунків, але вони не дозволяли відновлення після відмови вузла. Шляхом як створення екземплярів застосунків, так і утримання їх в робочому стані на різних вузлах, розгортання Kubernetes забезпечує фундаментально відмінний підхід до управління застосунками.</p>

            </div>

            <div class="col-md-4">
                <div class="content__box content__box_lined">
                    <h3>Зміст:</h3>
                    <ul>
                        <li>Deployment'и</li>
                        <li>Kubectl</li>
                    </ul>
                </div>
                <div class="content__box content__box_fill">
                    <p><i>
                        Deployment відповідає за створення та оновлення Podʼів для вашого застосунку
                    </i></p>
                </div>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">
                <h2 style="color: #3771e3;">Розгортання вашого першого застосунку в Kubernetes</h2>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8">
                <p><img src="/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg"></p>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">

                <p>Ви можете створювати та управляти розгортанням (Deployment) за допомогою інтерфейсу командного рядка Kubernetes, <b>kubectl</b>. Kubectl використовує API Kubernetes для взаємодії з кластером. У цьому модулі ви вивчите найпоширеніші команди kubectl, які потрібні для створення розгортань та запуску застосунків в кластері Kubernetes.</p>

                <p>Коли ви створюєте Deployment, вам необхідно вказати образ контейнера вашого застосунку та скільки його реплік ви бажаєте запустити. Згодом цю інформацію можна змінити, оновивши Deployment. В навчальних модулях <a href="/uk/docs/tutorials/kubernetes-basics/scale/scale-intro/">5</a> і <a href="/uk/docs/tutorials/kubernetes-basics/update/update-intro/">6</a> йдеться про те, як масштабувати і оновлювати Deployment'и.</p>
            </div>
            <div class="col-md-4">
                <div class="content__box content__box_fill">
                    <p><i> Для того, щоб розгортати застосунки в Kubernetes, їх потрібно упакувати в один із підтримуваних форматів контейнерів </i></p>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8">
                <p>Для вашого першого розгортання ви будете використовувати застосунок hello-node, який упакований в Docker-контейнер і використовує NGINX для відгуку на всі запити. (Якщо ви ще не пробували створити застосунок hello-node та розгортати його за допомогою контейнера, ви можете це зробити, слідуючи інструкціям з <a href="/uk/docs/tutorials/hello-minikube/">посібника Привіт Minikube</a>).</p>
                <p>Вам також потрібно мати `kubectl`. Якщо ви ще не встановили його, відвідайте <a href="/uk/docs/tasks/tools/#kubectl">встановлення інструментів</a>.</p>
                <p>Тепер ви знаєте, що таке Deployment. Тож розгорнемо ваш перший застосунок!</p>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">
                <h3>Основи kubectl</h3>
                <p>Загальний формат команди kubectl: <code>kubectl <i>дія ресурс</i></code></p>
                <p>Тут виконується вказана <em>дія</em> (наприклад, <tt>create</tt>, <tt>describe</tt> або <tt>delete</tt>) для вказаного <em>ресурсу</em> (наприклад, <tt>node</tt> або <tt>deployment</tt>). Ви можете використовувати <code>-<span />-help</code> після команд для отримання додаткової інформації про можливі параметри (наприклад, <code>kubectl get nodes --help</code>).</p>
                <p>Перевірте, що kubectl налаштовано для роботи з вашим кластером, виконавши команду <b><code>kubectl version</code></b>.</p>
                <p>Перевірте, що kubectl встановлено і ви можете бачити як версію клієнта, так і версію сервера.</p>
                <p>Щоб переглянути вузли в кластері, виконайте команду <b><code>kubectl get nodes</code></b>.</p>
                <p>Ви побачите доступні вузли. Пізніше Kubernetes вибере, де розгорнути наш застосунок на основі ресурсів, доступних на вузлах.</p>
            </div>
        </div>
        <div class="row">
            <div class="col-md-12">
                <a id="deploy-an-app"></a>
                <h3>Розгортання застосунку</h3>
                <p>Розгорнімо наш перший застосунок на Kubernetes за допомогою команди <code>kubectl create deployment</code>. Ми повинні вказати назву розгортання та розташування образу застосунку (вкажіть повну URL-адресу репозиторію образів, розміщених за межами Docker Hub).</p>
                <p><b><code>kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1</code></b></p>
                <p>Відмінно! Ви щойно розгорнули свій перший застосунок, створивши Deployment. Це призвело до виконання для вас кількох дій:</p>
                <ul>
                    <li>пошук відповідного вузла, де може бути запущений екземпляр застосунку (у нас доступний лише 1 вузол)</li>
                    <li>планування запуску застосунку на цьому вузлі</li>
                    <li>налаштування кластера для перепланування екземпляра на новому вузлі за необхідності</li>
                </ul>
                <p>Щоб переглянути ваші розгортання, використовуйте команду <code>kubectl get deployments</code>:</p>
                <p><b><code>kubectl get deployments</code></b></p>
                <p>Ми бачимо, що є 1 розгортання, яке запускає один екземпляр вашого застосунку. Екземпляр працює в контейнері на вашому вузлі.</p>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>Перегляд застосунку</h3>
                <p><a href="/uk/docs/concepts/workloads/pods/">Podʼи</a>, які працюють всередині Kubernetes, запущені в ізольованій приватній мережі. Типово вони видимі з інших Podʼів та служб всередині того ж самого кластера Kubernetes, але не за межами цієї мережі. Коли ми використовуємо <code>kubectl</code>, ми взаємодіємо через кінцеву точку API для спілкування з нашим застосунком.</p>
                <p>Розглянемо інші варіанти того, як вивести наш застосунок за межі кластера Kubernetes пізніше, в <a href="/uk/docs/tutorials/kubernetes-basics/expose/">Модулі 4</a>. Також, як у базовому посібнику, тут ми не пояснюємо докладно, що таке <code>Podʼи</code>, це буде розглянуто в подальших темах.</p>
                <p>Команда <code>kubectl proxy</code> може створити проксі, який буде пересилати дані в мережу, що охоплює весь кластер. Роботу проксі можна завершити, натиснувши control-C, і він не виводитиме жодного результату під час роботи.</p>
                <p><strong>Вам потрібно відкрити друге вікно термінала для запуску проксі.</strong></p>
                <p><b><code>kubectl proxy</code></b></p>
                <p>Тепер у нас є зʼєднання між вашим хостом (терміналом) та кластером Kubernetes. Проксі дозволяє безпосередній доступ до API з цих терміналів.</p>
                <p>Ви можете побачити всі ці API, розміщені через проксі-endpoint. Наприклад, ми можемо запитати версію напряму через API, використовуючи команду <code>curl</code>:</p>
                <p><b><code>curl http://localhost:8001/version</code></b></p>
                <div class="alert alert-info note callout" role="alert"><strong>Примітка:</strong> Якщо порт 8001 недоступний, переконайтеся, що команда <code>kubectl proxy</code>, яку ви запустили вище, працює в другому терміналі.</div>
                <p>Сервер API автоматично створює кінцеву точку для кожного Podʼу на основі імені Podʼа, яка також доступна через проксі.</p>
                <p>Спочатку нам потрібно отримати імʼя Podʼу, і ми збережемо його в змінну оточення <tt>POD_NAME</tt>:</p>
                <p><b><code>export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')</code></b><br />
                    <b><code>echo Name of the Pod: $POD_NAME</code></b></p>
                <p>Ви можете отримати доступ до Podʼу через проксі-API, запустивши:</p>
                <p><b><code>curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/</code></b></p>
                <p>Для того, щоб нове розгортання було доступним без використання проксі, потрібен сервіс, про що буде розказано в <a href="/uk/docs/tutorials/kubernetes-basics/expose/">Модулі 4</a>.</p>
            </div>
        </div>

        <div class="row">
            <p>
                Якщо ви готові, перейдіть до <a href="/uk/docs/tutorials/kubernetes-basics/explore/explore-intro/" title="Перегляд подів та вузлів">Перегляд Podʼів та Nodeʼів</a>.
            </p>
        </div>



    </main>

</div>

</body>
</html>
