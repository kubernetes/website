---
title: Використання kubectl для створення Deployment
weight: 10
---

## {{% heading "objectives" %}}

* Дізнайтесь, що таке Deployment застосунків.
* Розгорніть свій перший застосунок у Kubernetes за допомогою kubectl.

## Процеси Kubernetes Deployment {#kubernetes-deployments}

{{% alert %}}
_Deployment відповідає за створення та оновлення екземплярів для вашого застосунку._
{{% /alert %}}

{{< note >}}
Цей навчальний посібник використовує контейнер, який вимагає архітектури AMD64. Якщо ви використовуєте minikube на компʼютері з іншою архітектурою процесора, ви можете спробувати використовувати minikube з драйвером, який може емулювати AMD64. Наприклад, драйвер Docker Desktop може це зробити.
{{< /note >}}

Після запуску [кластера Kubernetes](/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/) ви можете розгортати свої контейнеризовані застосунки на його основі. Для цього створіть **Deployment (розгортання)** Kubernetes. Deployment вказує Kubernetes, як створювати та оновлювати екземпляри вашого застосунку. Після створення Deployment панель управління Kubernetes розподіляє екземпляри застосунків, що включені в цей Deployment, для запуску на окремих Вузлах в кластері.

Коли екземпляри застосунків створені, контролер Deployment безперервно відстежує їх стан. Якщо вузол, на якому запущено екземпляр, вимикається або видаляється, контролер Deployment замінює екземпляр новим на іншому вузлі в кластері. **Це забезпечує механізм самовідновлення для розвʼязання проблем з відмовою або обслуговуванням вузлів.**

У світі до ери оркестрування часто використовувалися скрипти встановлення для запуску застосунків, але вони не дозволяли відновлення після відмови вузла. Шляхом як створення екземплярів застосунків, так і утримання їх в робочому стані на різних вузлах, Deployments Kubernetes забезпечує принципово новий підхід до управління застосунками.

## Розгортання вашого першого застосунку в Kubernetes {#deploying-your-first-app-on-kubernetes}

{{% alert %}}
_Для того, щоб розгортати застосунки в Kubernetes, їх потрібно упакувати в один із підтримуваних форматів контейнерів_
{{% /alert %}}

{{< figure src="/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg" class="diagram-medium" >}}

Ви можете створювати та управляти Deployment (розгортанням) за допомогою інтерфейсу командного рядка Kubernetes — [kubectl](/docs/reference/kubectl/). `kubectl` використовує API Kubernetes для взаємодії з кластером. У цьому модулі ви вивчите найпоширеніші команди `kubectl`, які потрібні для створення Deployment та запуску застосунків в кластері Kubernetes.

Коли ви створюєте Deployment, вам необхідно вказати образ контейнера вашого застосунку та скільки його реплік ви бажаєте запустити. Згодом цю інформацію можна змінити, оновивши ваш Deployment; [Модуль 5](/docs/tutorials/kubernetes-basics/scale/scale-intro/)
та [Модуль 6](/docs/tutorials/kubernetes-basics/update/update-intro/) розповідають, як масштабувати та оновлювати ваші Deploymentʼи.

Для вашого першого Deployment (розгортання) ви будете використовувати застосунок hello-node, який упакований в Docker-контейнер і використовує NGINX для відгуку на всі запити. (Якщо ви ще не пробували створити застосунок hello-node та розгортати його за допомогою контейнера, ви можете це зробити, слідуючи інструкціям з [посібника Привіт Minikube](/docs/tutorials/hello-minikube/).)

Вам також потрібно мати `kubectl`. Якщо ви ще не встановили його, відвідайте сторінку [Встановлення інструментів](/docs/tasks/tools/#kubectl).

Тепер ви знаєте, що таке Deployment. Тож розгорнемо ваш перший застосунок!

### Основи kubectl {#kubectl-basics}

Загальний формат команди kubectl це: `kubectl дія ресурс`.

Команда виконує вказану _дію_ (наприклад, `create`, `describe` або `delete`) для вказаного _ресурсу_ (наприклад, `node` або `deployment`). Виможете використовувати ключ `--help` після команд для отримання додаткової інформації про можливі параметри (наприклад, `kubectl get nodes --help`).

Перевірте, що kubectl налаштовано для роботи з вашим кластером, виконавши команду `kubectl version`.

Переконайтесь, що kubectl встановлено і ви можете бачити як версію клієнта, так і версію сервера.

Щоб переглянути вузли в кластері, виконайте команду `kubectl get nodes`.

Ви побачите доступні вузли. Пізніше Kubernetes вибере, де розгорнути наш застосунок на основі ресурсів, доступних на Вузлах.

### Розгортання застосунку {#deploy-an-app}

Розгорнімо наш перший застосунок в Kubernetes за допомогою команди `kubectl create deployment`. Ми повинні вказати назву розгортання та розташування образу застосунку (вкажіть повну URL-адресу репозиторію образів, розміщених за межами Docker Hub).

```shell
kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
```

Відмінно! Ви щойно розгорнули свій перший застосунок, створивши розгортання. Це призвело до виконання для вас кількох дій:

* пошук відповідного вузла, де може бути запущений екземпляр застосунку (у нас доступний лише 1 вузол)
* планування запуску застосунку на цьому Вузлі
* налаштування кластера для перепланування екземпляра на новому Вузлі за необхідності

Щоб переглянути ваші розгортання, використовуйте команду `kubectl get deployments`:

```shell
kubectl get deployments
```

Ми бачимо, що у нас є 1 розгортання, яке запускає один екземпляр вашого застосунку. Екземпляр працює в контейнері на вашому вузлі.

### Перегляд застосунку {#view-the-app}

[Podʼи](/docs/concepts/workloads/pods/), які працюють всередині Kubernetes, запущені в ізольованій приватній мережі. Стандартно вони видимі з інших podʼів та сервісів всередині того ж самого кластера Kubernetes, але не за межами цієї мережі. Коли ми використовуємо `kubectl`, ми взаємодіємо через точку доступу API для спілкування з нашим застосунком.

Розглянемо інші варіанти того, як експонувати наш застосунок за межі кластера Kubernetes пізніше, в [Модулі 4](/docs/tutorials/kubernetes-basics/expose/). Також, як у базовому посібнику, тут ми не пояснюємо докладно, що таке `Pods`, це буде розглянуто в подальших темах.

Команда `kubectl proxy` може створити проксі, який буде пересилати дані в мережу, що охоплює весь кластер. Роботу проксі можна завершити комбінацією Control-C, і він не виводитиме жодного результату під час роботи.

**Для запуску проксі потрібно відкрити друге вікно термінала.**

```shell
kubectl proxy
```

Тепер у нас є зʼєднання між вашим хостом (терміналом) та кластером Kubernetes. Проксі дозволяє безпосередній доступ до API з цих терміналів.

Ви можете побачити всі ці API, що знаходяться за точкою доступу проксі. Наприклад, ми можемо запитати версію напряму через API, використовуючи команду `curl`:

```shell
curl http://localhost:8001/version
```

{{< note >}}
Якщо порт 8001 недоступний, переконайтеся, що команда `kubectl proxy`, яку ви запустили вище, працює в другому терміналі.
{{< /note >}}

Сервер API автоматично створює точку доступу для кожного podʼа на основі імені podʼа, яка також доступна через проксі.

Спочатку нам потрібно отримати імʼя Podʼа, і ми збережемо його в змінну оточення `POD_NAME`.

```shell
export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')
echo Name of the Pod: $POD_NAME
```

Ви можете отримати доступ до Podʼа через API за допомогою проксі, виконавши команду:

```shell
curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME:8080/proxy/
```

Для того, щоб новий Deployment був доступним без використання проксі, потрібен Service, про що буде розказано в [Модулі 4](/docs/tutorials/kubernetes-basics/expose/).

## {{% heading "whatsnext" %}}

* Підручник [Перегляд Pods та Nodes](/docs/tutorials/kubernetes-basics/explore/explore-intro/).
* Дізнайтесь більше про [Deployments](/docs/concepts/workloads/controllers/deployment/).
