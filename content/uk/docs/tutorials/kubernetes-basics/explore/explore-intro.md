---
title: Перегляд Podʼів та Вузлів (Node)
weight: 10
---

## {{% heading "objectives" %}}

* Дізнайтесь, що таке Pod в Kubernetes.
* Дізнайтесь, що таке Node в Kubernetes.
* Діагностика розгорнутих застосунків.

## Podʼи Kubernetes {#kubernetes-pods}

{{% alert %}}
_Pod — це група з одного або декількох контейнерів (таких як Docker), що має спільне сховище даних (volumes), IP-адресу та містить інформацію про те, як їх запустити._
{{% /alert %}}

Коли ви створили Deployment у [Модулі 2](/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/), Kubernetes створив **Pod**, щоб розмістити екземпляр вашого застосунку. Pod — це абстракція в Kubernetes, що являє собою групу з одного або декількох контейнерів застосунку (таких як Docker) та ресурсів, спільних для цих контейнерів. До цих ресурсів належать:

* Спільні сховища даних, або Volumes
* Мережа, адже кожен Pod у кластері має унікальну IP-адресу
* Інформація про те, як запускати кожний контейнер, така як версія образу контейнера або використання певних портів

Pod моделює специфічний для даного застосунку "логічний хост" та може містити різні, але доволі тісно повʼязані один з одним контейнери. Наприклад, в одному Podʼі може бути контейнер з вашим Node.js застосунком та інший контейнер, що передає дані Node.js для публікації вебсервером. Контейнери в межах Podʼа мають спільну IP-адресу та порти, завжди є сполученими, плануються для запуску разом та запускаються у спільному контексті на одному Node (вузлі).

Pod є неподільною атомарною одиницею платформи Kubernetes. Коли ви створюєте Deployment у Kubernetes, цей Deployment створює Podʼи вже з контейнерами всередині, на відміну від створення контейнерів окремо. Кожен Pod привʼязаний до вузла, до якого його було розподілено, і лишається на ньому до припинення роботи (згідно з політикою перезапуску) або видалення. У разі відмови вузла ідентичні Podʼи розподіляються по інших доступних Вузлах кластера.

### Узагальнена схема Podʼів {#pods-overview}

{{< figure src="/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg" class="diagram-medium" >}}

{{% alert %}}
_Контейнери слід розміщувати разом в одному Podʼі, тільки якщо вони тісно повʼязані між собою і потребують спільного використання ресурсів, таких як диск._
{{% /alert %}}

## Вузли {#nodes}

Pod завжди запускається на **Node (Вузлі)**. Pod завжди запускається на <b>Вузлі</b>. Вузол — це робоча машина в Kubernetes, віртуальна або фізична, залежно від кластера. Функціонування кожного Вузла керується панеллю управління. Вузол може мати декілька Podʼів, а панель управління автоматично керує розподілом Podʼів між вузлами в кластері. Панель управління Kubernetes автоматично розподіляє Podʼи по вузлах кластера з урахуванням ресурсів, наявних на кожному Вузлі.

На кожному Вузлі Kubernetes запущені як мінімум:

* Kubelet — процес, що забезпечує обмін даними між панеллю управління Kubernetes та Вузлом; kubelet керує Podʼами та контейнерами, запущеним на машині.

* Оточення для запуску контейнерів (таке як Docker) забезпечує завантаження образу контейнера з реєстру, розпакування контейнера та запуск застосунку.

### Узагальнена схема вузлів {#nodes-overview}

{{< figure src="/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg" class="diagram-medium" >}}

## Розвʼязання проблем за допомогою kubectl {#troubleshooting-with-kubectl}

В [Модулі 2](/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/), ви використовували інтерфейс командного рядка kubectl. Ви будете продовжувати його використовувати в Модулі 3 для отримання інформації про розгорнуті застосунки та їхні середовища. За допомогою наступних команд kubectl можна виконати найбільш поширені операції:

* `kubectl get` — показати перелік ресурсів
* `kubectl describe` — виведення детальної інформації про ресурс
* `kubectl logs` — виведення логів контейнера в podʼі
* `kubectl exec` — виконання команди в контейнері в podʼі

Ви можете використовувати ці команди, щоб переглядати інформацію про те, коли були розгорнуті застосунки, який їхній поточний статус, де вони запущені та які їхні конфігурації.

Тепер, коли ми більше знаємо про компоненти нашого кластера та командний рядок, дослідімо наш застосунок.

### Перевірка конфігурації застосунку {#check-application-configuration}

Перевірмо, чи працює застосунок, який ми розгорнули в попередньому сценарії. Ми використаємо команду `kubectl get` і подивимося на наявні Podʼи:

```shell
kubectl get pods
```

Якщо podʼи не запущені, зачекайте кілька секунд і знову спробуйте вивести список Podʼів. Ви можете продовжити, як тільки побачите, що працює один Pod.

Далі, щоб переглянути, які контейнери є всередині цього Podʼа і які образи використовуються для створення цих контейнерів, ми використовуємо команду  `kubectl describe pods`:

```shell
kubectl describe pods
```

Тут ми бачимо деталі про контейнер Podʼа: IP-адресу, порти та список подій, повʼязаних з життєвим циклом Podʼа.

Вивід команди `describe` є розлогим і охоплює деякі концепції, які ми ще не пояснили, але не хвилюйтеся, вони стануть зрозумілими до кінця цього посібника.

{{< note >}}
Команду `describe` можна використовувати для отримання детальної інформації про більшість примітивів Kubernetes, включаючи Node, Podʼи та Deployment. Вивід команди describe призначений для сприйняття людиною, а не для створення скриптів.
{{< /note >}}

### Показати застосунок у терміналі {#show-the-app-in-the-terminal}

Памʼятаєте, що Podʼи працюють в ізольованій, приватній мережі — тому нам потрібно налаштувати проксі-доступ до них для налагодження та взаємодії з ними. To do this, Для цього ми використовуємо команду `kubectl proxy` для запуску проксі в **іншому терміналі**. Відкрийте нове вікно термінала і введіть у цьому новому терміналі:

```shell
kubectl proxy
```

Тепер ми знову отримаємо імʼя Podʼа та будемо звертатись до цього Podʼа безпосередньо через проксі. Щоб отримати імʼя Podʼа та зберегти його в змінну середовища `POD_NAME`:

```shell
export POD_NAME="$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')"
echo Name of the Pod: $POD_NAME
```

Щоб переглянути вивід нашого застосунку, виконайте запит `curl`:

```shell
curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME:8080/proxy/
```

URL — це шлях до API Podʼа.

{{< note >}}
Нам не потрібно вказувати імʼя контейнера, оскільки у нас є лише один контейнер всередині podʼа.
{{< /note >}}

### Виконання команди в контейнері {#executing-commands-on-the-container}

Ми можемо виконувати команди безпосередньо в контейнері після того, як Pod буде запущено та він працюватиме. Для цього ми використовуємо команду `exec` і вказуємо імʼя Podʼа як параметр. Перегляньмо змінні середовища:

```shell
kubectl exec "$POD_NAME" -- env
```

Знову варто зазначити, що можна пропустити імʼя самого контейнера, оскільки у нас є лише один контейнер в Podʼі.

Далі розпочнімо сеанс bash в контейнері Podʼа:

```shell
kubectl exec -ti $POD_NAME -- bash
```

Тепер у нас є відкрита консоль в контейнері, де запущений наш застосунок NodeJS. Вихідний код застосунку знаходиться у файлі `server.js`:

```shell
cat server.js
```

You can check that the application is up by running a curl command:

```shell
curl http://localhost:8080
```

{{< note >}}
тут ми використовували `localhost`, оскільки ми виконали команду всередині Podʼа NodeJS. Якщо ви не можете підʼєднатися до localhost:8080, перевірте, чи ви виконали команду `kubectl exec` і запускаєте команду зсередини Podʼа.
{{< /note >}}

Щоб закрити підключення до контейнера, введіть `exit`.

## {{% heading "whatsnext" %}}

* Підручник [Використання Service для надання доступу до вашого застосунку](/docs/tutorials/kubernetes-basics/expose/expose-intro/).
* Дізнайтесь більше про [Pods](/docs/concepts/workloads/pods/).
* Дізнайтесь більше про [Nodes](/docs/concepts/architecture/nodes/).
