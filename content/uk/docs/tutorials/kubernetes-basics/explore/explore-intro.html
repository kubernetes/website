---
title: Перегляд Podʼів та вузлів (Node)
weight: 10
description: |- 
  Дізнайтесь, як розвʼязувати проблеми з розгорнутими застосунками,
  використовуючи kubectl get, kubectl describe, kubectl logs та kubectl exec.
---

<!DOCTYPE html>

<html lang="uk">

<body>

<div class="layout" id="top">

    <main class="content">

        <div class="row">

     <div class="col-md-8">
          <h3>Мета</h3>
                <ul>
                    <li>Дізнатися, що таке Podʼи Kubernetes.</li>
                    <li>Дізнатися, що таке вузли Kubernetes.</li>
                    <li>Діагностика розгорнутих застосунків.</li>
                </ul>
            </div>

            <div class="col-md-8">
                <h2>Podʼи Kubernetes</h2>
                <p>Коли ви створили Deployment у модулі <a href="/uk/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">2</a>, Kubernetes створив <b>Pod</b>, щоб розмістити ваш застосунок. Pod — це абстракція в Kubernetes, що являє собою групу з одного або декількох контейнерів застосунку (таких як Docker) та ресурсів, спільних для цих контейнерів. До цих ресурсів належать:</p>
                <ul>
                    <li>Спільні сховища даних, або Volumes</li>
                    <li>Мережа, адже кожен Pod у кластері має унікальну IP-адресу</li>
                    <li>Інформація про запуск кожного контейнера, така як версія образу контейнера або використання певних портів</li>
                </ul>
                <p>Pod моделює специфічний для даного застосунку "логічний хост" та може містити різні, але доволі щільно звʼязані один з одним контейнери. Наприклад, в одному Podʼі може бути контейнер з вашим Node.js застосунком та інший контейнер, що передає дані для публікації Node.js вебсерверу. Контейнери в межах Podʼа мають спільну IP-адресу та порти, завжди є сполученими, плануються для запуску разом та запускаються у спільному контексті на одному вузлі.</p>

                <p>Pod є неподільною одиницею платформи Kubernetes. Коли ви створюєте Deployment у Kubernetes, цей Deployment створює Podʼи вже з контейнерами всередині, на відміну від створення контейнерів окремо. Кожен Pod привʼязаний до вузла, до якого його було розподілено, і лишається на ньому до припинення роботи (згідно з політикою перезапуску) або видалення. У разі відмови вузла ідентичні Podʼи розподіляються по інших доступних вузлах кластера.</p>

            </div>
            <div class="col-md-4">
                <div class="content__box content__box_lined">
                    <h3>Зміст:</h3>
                    <ul>
                        <li>Podʼи</li>
                        <li>Вузли</li>
                        <li>Основні команди kubectl</li>
                    </ul>
                </div>
                <div class="content__box content__box_fill">
                        <p><i>
                            Pod — це група з одного або декількох контейнерів (таких як Docker), що має спільне сховище даних (volumes), унікальну IP-адресу і містить інформацію про те, як їх запустити.
                        </i></p>
                </div>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">
                <h2 style="color: #3771e3;">Узагальнена схема Podʼів</h2>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8">
                <p><img src="/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg"></p>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">
                
                <h2>Вузли</h2>
                <p>Pod завжди запускається на <b>вузлі</b>. Вузол — це робоча машина в Kubernetes, віртуальна або фізична, залежно від кластера. Функціонування кожного вузла контролюється панеллю управління. Вузол може мати декілька Podʼів, а панель управління автоматично призначає Podʼи вузлам в кластері. Панель управління Kubernetes автоматично розподіляє Podʼи по вузлах кластера з урахуванням ресурсів, наявних на кожному вузлі.</p>
                
                <p>На кожному вузлі Kubernetes запущені як мінімум:</p>
                <ul>
                    
                    <li>Kubelet — процес, що забезпечує обмін даними між панеллю управління Kubernetes та робочим вузлом; kubelet керує Podʼами та контейнерами, запущеним на машині.</li>
                    <li>Оточення для запуску контейнерів (таке як Docker) забезпечує завантаження образу контейнера з реєстру, розпакування контейнера та запуск застосунку.</li>

                </ul>

            </div>
            <div class="col-md-4">
                <div class="content__box content__box_fill"> 
                    <p><i> Контейнери повинні бути разом в одному Podʼі, лише якщо вони щільно звʼязані і мають спільні ресурси, такі як диск. </i></p>
                </div>
            </div>
        </div>

        <br>

        <div class="row">
            <div class="col-md-8">
                <h2 style="color: #3771e3;">Узагальнена схема вузлів</h2>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8">
                <p><img src="/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg"></p>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">
                <h2>Виправлення проблем за допомогою kubectl</h2>
                <p>У модулі <a href="/uk/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/">2</a> ви використовували інтерфейс командного рядка kubectl. Ви будете продовжувати його використовувати в модулі 3 для отримання інформації про розгорнуті застосунки та їхні середовища. За допомогою наступних підкоманд kubectl можна виконати найбільш поширені операції:</p>
                <ul>
                    <li><tt><b>kubectl get</b></tt> — показати перелік ресурсів</li>
                    <li><tt><b>kubectl describe</b></tt> — виведення детальної інформації про ресурс</li>
                    <li><tt><b>kubectl logs</b></tt> — виведення логів контейнера в Podʼі</li>
                    <li><tt><b>kubectl exec</b></tt> — виконання команди в контейнері в Podʼі</li>
                </ul>
        
                <p>Ви можете використовувати ці команди, щоб переглядати інформацію про те, коли були розгорнуті застосунки, який їхній поточний статус, де вони запущені та які їхні конфігурації.</p>
        
                <p>Тепер, коли ми більше знаємо про компоненти нашого кластера та командний рядок, дослідімо наш застосунок.</p>
        
            </div>
            <div class="col-md-4">
                <div class="content__box content__box_fill">
                    <p><i>Вузол — це робоча машина в Kubernetes і може бути віртуальною машиною або фізичною машиною залежно від кластера. На одному вузлі може працювати кілька Podʼів.</i></p>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>Перевірка конфігурації застосунку</h3>
                <p>Перевірмо, чи працює застосунок, який ми розгорнули в попередньому сценарії. Ми використаємо команду <code>kubectl get</code> і подивимося на наявні Podʼи:</p>
                <p><b><code>kubectl get pods</code></b></p>
                <p>Якщо Podʼи не запущені, зачекайте кілька секунд і знову спробуйте вивести список Podʼів. Ви можете продовжити, якщо ви бачите, що працює один Pod.</p>
                <p>Далі, щоб переглянути, які контейнери є всередині цього Podʼа і які образи використовуються для створення цих контейнерів, ми використовуємо команду <code>kubectl describe pods</code>:</p>
                <p><b><code>kubectl describe pods</code></b></p>
                <p>Тут ми бачимо деталі про контейнер Podʼа: IP-адресу, порти та список подій, повʼязаних з життєвим циклом Podʼа.</p>
                <p>Вивід підкоманди <tt>describe</tt> є розлогим і охоплює деякі концепції, які ми ще не пояснили, але не хвилюйтеся, вони стануть зрозумілими до кінця цього курсу.</p>
                <p><em><strong>Примітка:</strong> підкоманду <tt>describe</tt> можна використовувати для отримання детальної інформації про більшість примітивів Kubernetes, включаючи вузли, Podʼи та Deployment. Вивід команди describe призначений для сприйняття людиною, а не для сценаріїв.</em></p>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>Показати застосунок у терміналі</h3>
                <p>Пригадайте, що Podʼи працюють в ізольованій, приватній мережі — тому нам потрібно налаштувати проксі-доступ до них для налагодження та взаємодії з ними. Для цього ми використовуємо команду <code>kubectl proxy</code> для запуску проксі в <strong>іншому терміналі</strong>. Відкрийте нове вікно термінала і введіть у цьому новому терміналі:</p>
                <p><code><b>kubectl proxy</b></code></p>
                <p>Тепер ми знову отримаємо імʼя Podʼа та будемо звертатись до цього Podʼу безпосередньо через проксі. Щоб отримати імʼя Podʼа та зберегти його в змінну середовища <tt>POD_NAME</tt>:</p>
                <p><code><b>export POD_NAME="$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')"</b></code><br />
                <code><b>echo Name of the Pod: $POD_NAME</b></code></p>
                <p>Щоб переглянути вивід нашого застосунку, виконайте запит <code>curl</code>:</p>
                <p><code><b>curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME:8080/proxy/</b></code></p>
                <p>URL — це шлях до API Podʼа.</p>
            </div>
        </div>
        
        <div class="row">
            <div class="col-md-12">
                <h3>Перегляд логів контейнера</h3>
                <p>Все, що застосунок зазвичай виводить на стандартний вивід, стає логами контейнера всередині Podʼа. Ми можемо отримати ці логи, використовуючи команду <code>kubectl logs</code>:</p>
                <p><code><b>kubectl logs "$POD_NAME"</b></code></p>
                <p><em><strong>Примітка:</strong> Нам не потрібно вказувати імʼя контейнера, оскільки у нас є лише один контейнер всередині Podʼа.</em></p>
            </div>
        </div>
        
        <div class="row">
            <div class="col-md-12">
                <h3>Виконання команди в контейнері</h3>
                <p>Ми можемо виконувати команди безпосередньо в контейнері після того, як Pod буде запущено та він працюватиме. Для цього ми використовуємо підкоманду <code>exec</code> і вказуємо імʼя Podʼа як параметр. Перегляньмо змінні середовища:</p>
                <p><code><b>kubectl exec "$POD_NAME" -- env</b></code></p>
                <p>Знову варто зазначити, що можна пропустити імʼя самого контейнера, оскільки у нас є лише один контейнер в Podʼі.</p>
                <p>Далі розпочнім сеанс bash в контейнері Podʼа:</p>
                <p><code><b>kubectl exec -ti $POD_NAME -- bash</b></code></p>
                <p>Тепер у нас є відкрита консоль в контейнері, де запущений наш застосунок NodeJS. Вихідний код застосунку знаходиться у файлі <tt>server.js</tt>:</p>
                <p><code><b>cat server.js</b></code></p>
                <p>Ви можете перевірити, чи застосунок запущено, виконавши команду <tt>curl</tt>:</p>
                <p><code><b>curl http://localhost:8080</b></code></p>
                <p><em><strong>Примітка:</strong> тут ми використовували <tt>localhost</tt>, оскільки ми виконали команду всередині Podʼа NodeJS. Якщо ви не можете підʼєднатися до localhost:8080, перевірте, чи ви виконали команду <code>kubectl exec</code> і запускаєте команду зсередини Podʼа</em></p>
                <p>Щоб закрити підключення до контейнера, введіть <code><b>exit</b></code>.</p>
            </div>
        </div>
        
        <div class="row">
            <p>
                Як тільки ви будете готові, переходьте до <a href="/uk/docs/tutorials/kubernetes-basics/expose/expose-intro/" title="Використання Service для надання доступу до вашого застосунку">Використання Service для надання доступу до вашого застосунку</a>.
            </p>
        </div>
    </main>

</div>

</body>
</html>
