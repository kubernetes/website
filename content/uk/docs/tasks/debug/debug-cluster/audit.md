---
content_type: task
title: Аудит
weight: 35
---

<!-- overview -->

_Аудит_ Kubernetes забезпечує безпеку шляхом створення хронологічного набору записів, які документують послідовність дій у кластері. Кластер аудитує дії, що генеруються користувачами, застосунками, які використовують API Kubernetes, а також самою панеллю управління.

Аудит дозволяє адміністраторам кластера відповісти на такі питання:

- що сталося?
- коли це сталося?
- хто це ініціював?
- на чому це сталося?
- де це було помічено?
- звідки це було ініційовано?
- куди це направлялося?

<!-- body -->

Записи аудиту починають свій життєвий цикл всередині компонента [kube-apiserver](/docs/reference/command-line-tools-reference/kube-apiserver/). Кожен запит на кожному етапі його виконання генерує подію аудиту, яка потім передається до попередньої обробки відповідно до певної політики та записується в бекенд. Політика визначає, що буде записано, а бекенд зберігає записи. Поточні реалізації бекендів включають файли логів та вебхуки.

Кожний запит може бути записаний з асоційованим _stage_. Визначені етапи:

- `RequestReceived` — Етап для подій, що генеруються, як тільки обробник аудиту отримує запит, і до того, як він передає його вниз по ланцюжку обробників.
- `ResponseStarted` — Після надсилання заголовків відповіді, але перед відправленням тіла відповіді. Цей етап генерується лише для тривалих запитів (наприклад, watch).
- `ResponseComplete` — Тіло відповіді завершено і більше байтів не буде відправлено.
- `Panic` — Події, що генеруються при виникненні паніки.

{{< note >}}
Конфігурація [події аудиту](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event) відрізняється від обʼєкта API [Event](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#event-v1-core).
{{< /note >}}

Функція логування аудиту збільшує витрати памʼяті сервера API, оскільки для кожного запиту зберігається певний контекст, необхідний для аудитування. Витрати памʼяті залежать від конфігурації логування аудиту.

## Політика аудиту {#audit-policy}

Політика аудиту визначає правила того, які події повинні бути записані та які дані вони повинні містити. Структура обʼєкта політики аудиту визначена в групі API [`audit.k8s.io`](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy). Коли подія обробляється, її порівнюють зі списком прав по черзі. Перший збіг прав встановлює _рівень аудиту_ події. Визначені рівні аудиту:

- `None` — не записувати події, які відповідають цьому правилу.
- `Metadata` — реєструвати події з метаданими (користувач, часова відмітка, ресурс, дія тощо), але не тіло запиту чи відповіді.
- `Request` — реєструвати події з метаданими та тілом запиту, але не з тілом відповіді. Це не застосовується до запитів на ресурси.
- `RequestResponse` — реєструвати події з метаданими запиту, тілом запиту та тілом відповіді. Це не застосовується до запитів на ресурси.

Ви можете передати файл з політикою до `kube-apiserver`, використовуючи прапорець `--audit-policy-file`. Якщо прапорець пропущено, жодні події не записуються. Зверніть увагу, що поле `rules` __обовʼязково__ повинно бути вказано у файлі політики аудиту. Політика з нульовою кількістю (0) прав вважається неприпустимою.

Нижче наведено приклад файлу політики аудиту:

{{% code_sample file="audit/audit-policy.yaml" %}}

Ви можете використовувати мінімальну політику аудиту для логування всіх запитів на рівні `Metadata`:

```yaml
# Записати всі запити на рівні Metadata.
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: Metadata
```

Якщо ви створюєте власний профіль аудиту, ви можете скористатися профілем аудиту для Google Container-Optimized OS як вихідною точкою. Ви можете перевірити сценарій [configure-helper.sh](https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh), який генерує файл політики аудиту. Більшість файлу політики аудиту можна побачити, дивлячись безпосередньо на цей сценарій.

Ви також можете звернутися до [посилання на конфігурацію `Policy`](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy) для отримання деталей про визначені поля.

## Бекенди аудиту {#audit-backends}

Події аудиту зберігаються в зовнішньому сховищі за допомогою бекендів аудиту. Стандартно `kube-apiserver` надає два бекенди:

- Файловий бекенд, який записує події у файлову систему.
- Бекенд Webhook, який відправляє події на зовнішній HTTP API.

У всіх випадках події аудиту слідують структурі, визначеній API Kubernetes в групі API [`audit.k8s.io`](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event).

{{< note >}}
У випадку патчів тіло запиту є масивом JSON з операціями патча, а не обʼєктом JSON з відповідним обʼєктом API Kubernetes. Наприклад, наступне тіло запиту є допустимим запитом на накладання патча до `/apis/batch/v1/namespaces/some-namespace/jobs/some-job-name`:

```json
[
  {
    "op": "replace",
    "path": "/spec/parallelism",
    "value": 0
  },
  {
    "op": "remove",
    "path": "/spec/template/spec/containers/0/terminationMessagePolicy"
  }
]
```

{{< /note >}}

### Бекенд логів {#log-backend}

Бекенд логів записує події аудиту у файл у форматі [JSONlines](https://jsonlines.org/). Ви можете налаштувати бекенд логів за допомогою наступних прапорців `kube-apiserver`:

- `--audit-log-path` вказує шлях до файлу логу, який бекенд логів використовує для запису подій аудиту. Відсутність цього прапорця вимикає бекенд логів; `-` означає стандартний вивід
- `--audit-log-maxage` визначає максимальну кількість днів для зберігання старих файлів логів аудиту
- `--audit-log-maxbackup` визначає максимальну кількість файлів логів аудиту для зберігання
- `--audit-log-maxsize` визначає максимальний розмір в мегабайтах файлу логів аудиту до його ротації

Якщо панель управління вашого кластера працює з `kube-apiserver` як з Pod, не забудьте змонтувати `hostPath` до місця розташування файлу політики та файлу логів, щоб записи аудиту були збережені. Наприклад:

```yaml
  - --audit-policy-file=/etc/kubernetes/audit-policy.yaml
  - --audit-log-path=/var/log/kubernetes/audit/audit.log
```

потім змонтуйте томи:

```yaml
...
volumeMounts:
  - mountPath: /etc/kubernetes/audit-policy.yaml
    name: audit
    readOnly: true
  - mountPath: /var/log/kubernetes/audit/
    name: audit-log
    readOnly: false
```

і нарешті налаштуйте `hostPath`:

```yaml
...
volumes:
- name: audit
  hostPath:
    path: /etc/kubernetes/audit-policy.yaml
    type: File

- name: audit-log
  hostPath:
    path: /var/log/kubernetes/audit/
    type: DirectoryOrCreate
```

### Бекенд Webhook {#webhook-backend}

Бекенд аудиту webhook надсилає події аудиту до віддаленого веб-API, яке вважається формою Kubernetes API, включаючи засоби автентифікації. Ви можете налаштувати бекенд webhook за допомогою наступних прапорців `kube-apiserver`:

- `--audit-webhook-config-file` вказує шлях до файлу з конфігурацією webhook. Конфігурація webhook фактично є спеціалізованим [kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters).
- `--audit-webhook-initial-backoff` вказує час очікування після першого невдалого запиту перед повторною спробою. Наступні запити повторюються з експоненційною затримкою.

Файл конфігурації webhook використовує формат kubeconfig для вказування віддаленої адреси служби та облікових даних, які використовуються для підключення до неї.

## Пакетна обробка подій {#batching}

Обидва типи бекенд систем, як `log`, так і `webhook`, підтримують пакетну обробку. Нижче наведено перелік доступних прапорців для кожного бекенду. Стандартно пакетна обробка __увімкнена__ для `webhook` і __вимкнена__ для `log`.

{{< tabs name="tab_with_md" >}}
{{% tab name="webhook" %}}

- `--audit-webhook-mode` визначає стратегію буферизації. Одна з наступних:
  - `batch` — буферизувати події та асинхронно обробляти їх пакетами. Це стандартне значення для `webhook`.
  - `blocking` — блокувати відповіді сервера API на обробці кожної окремої події.
  - `blocking-strict` — те саме, що й `blocking`, але коли відбувається збій під час логування аудиту на етапі RequestReceived, весь запит до kube-apiserver зазнає збою.

Наступні прапорці використовуються тільки в режимі `batch`:

- `--audit-webhook-batch-buffer-size` визначає кількість подій для буферизації перед пакетною обробкою. Якщо швидкість надходження подій переповнює буфер, події відкидаються. Стандартне значення — 10000.
- `--audit-webhook-batch-max-size` визначає максимальну кількість подій в одному пакеті. Стандартне значення — 400.
- `--audit-webhook-batch-max-wait` визначає максимальний час очікування перед безумовною буферизацією подій у черзі.
- `--audit-webhook-batch-throttle-enable` визначає, чи увімкнено тротлінг пакетів. Стандартно тротлінг увімкнено.
- `--audit-webhook-batch-throttle-qps` визначає максимальну середню кількість пакетів, що генеруються за секунду. Стандартне значення — 10.
- `--audit-webhook-batch-throttle-burst` визначає максимальну кількість пакетів, які генеруються в той же момент, якщо дозволений QPS раніше не використовувався повністю. Стандартне значення — 10.
{{% /tab %}}
{{% tab name="log" %}}
- `--audit-log-mode` визначає стратегію буферизації. Одна з наступних:
  - `batch` — буферизувати події та асинхронно обробляти їх пакетами. Пакетна обробка не рекомендується для бекенду `log`.
  - `blocking` — блокувати відповіді сервера API при обробці кожної окремої події. Це стандартний режим для бекенду `log`.
  - `blocking-strict` — те ж саме, що і блокування, але при збої під час логування аудиту на етапі RequestReceived, весь запит до kube-apiserver зазнає невдачі.

Наступні прапорці використовуються тільки в режимі `batch` (стандартно для бекенду `log` пакетна обробка __вимкнена__, і коли пакетну обробку вимкнено, всі прапорці, повʼязані з пакетною обробкою, ігноруються):

- `--audit-log-batch-buffer-size` визначає кількість подій для буферизації перед пакетною обробкою. Якщо кількість подій, що надходять, переповнює буфер, події буде відкинуто.
- `--audit-log-batch-max-size` визначає максимальну кількість подій в одному пакеті.
- `--audit-log-batch-max-wait` визначає максимальний час очікування перед безумовною обробкою подій у черзі.
- `--audit-log-batch-throttle-enable` визначає, чи увімкнено тротлінг пакетної обробки.
- `--audit-log-batch-throttle-qps` визначає максимальну середню кількість пакетів, що генеруються за секунду.
- `--audit-log-batch-throttle-burst` визначає максимальну кількість пакетів, згенерованих за один момент часу, якщо раніше було недовикористано дозволений QPS.
{{% /tab %}}
{{< /tabs >}}

## Налаштування параметрів {#parameter-tuning}

Параметри повинні бути встановлені з урахуванням навантаження на API-сервер.

Наприклад, якщо kube-apiserver отримує 100 запитів кожну секунду, і кожен запит проходить аудит лише на етапах `ResponseStarted` та `ResponseComplete`, вам слід розрахувати приблизно 200 подій аудиту, які генеруються кожну секунду. Припускаючи, що в пакеті може бути до 100 подій, вам слід встановити рівень обмеження принаймні у 2 запити на секунду. Припускаючи, що система може потребувати до 5 секунд для запису подій, вам слід встановити розмір буфера для зберігання подій протягом до 5 секунд; це означає: 10 пакетів або 1000 подій.

Проте в більшості випадків стандартні значення параметрів повинні бути достатніми, і вам не потрібно хвилюватися про їх ручне встановлення. Ви можете переглянути наступні метрики Prometheus, які експонує kube-apiserver, а також логи, щоб контролювати стан підсистеми аудиту.

- Метрика `apiserver_audit_event_total` містить загальну кількість експортованих подій аудиту.
- Метрика `apiserver_audit_error_total` містить загальну кількість подій, які були втрачені через помилку під час експортування.

### Обмеження розміру запису в лозі {#truncate}

Обидва бекенди і логів, і webhook підтримують обмеження розміру подій, які записуються. Наприклад, ось список прапорців, доступних для бекенду логів:

- `audit-log-truncate-enabled` визначає, чи ввімкнене обрізання подій та пакетів.
- `audit-log-truncate-max-batch-size` максимальний розмір у байтах пакета, який надсилається до бекенду.
- `audit-log-truncate-max-event-size` максимальний розмір у байтах аудитивної події, яка надсилається до бекенду.

Типово обрізання вимкнено як у `webhook`, так і у `log`. Адміністратор кластера повинен встановити `audit-log-truncate-enabled` або `audit-webhook-truncate-enabled`, щоб увімкнути цю функцію.

## {{% heading "whatsnext" %}}

- Дізнайтеся про [анотації аудиту мутуючих вебхуків](/docs/reference/access-authn-authz/extensible-admission-controllers/#mutating-webhook-auditing-annotations).
- Дізнайтеся більше про типи ресурсів [`Event`](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event) та [`Policy`](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy) з Довідки налаштування аудиту.
