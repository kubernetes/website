---
title: Використання простору імен користувача з Podʼом
content_type: task
weight: 210
min-kubernetes-server-version: v1.25
---

<!-- overview -->

{{< feature-state feature_gate_name="UserNamespacesSupport" >}}

Ця сторінка показує, як налаштувати простір імен користувача для Podʼів. Це дозволяє ізолювати користувача, що працює всередині контейнера, від того, який працює на хості.

Процес, що працює як root у контейнері, може працювати як інший (не root) користувач на хості; іншими словами, процес має повні привілеї для операцій всередині простору імен користувача, але не має привілеїв для операцій за межами простору імен.

Ви можете використовувати цю функцію, щоб зменшити шкоду, яку скомпрометований контейнер може завдати хосту або іншим Podʼам на тому ж вузлі. Є [кілька уразливостей безпеки][KEP-vulns], оцінених як **ВИСОКІ** або **КРИТИЧНІ**, які не були використовні при активному використанні просторів імен користувача. Очікується, що простори імен користувача захистять від деяких майбутніх уразливостей також.

Без використання просторів імен користувача контейнер, що працює як root, у випадку втечі з контейнера має привілеї root на вузлі. І якщо деякі можливості були надані контейнеру, то ці можливості також дійсні на хості. Цього не відбувається, коли використовуються простори імен користувача.

[KEP-vulns]: https://github.com/kubernetes/enhancements/tree/217d790720c5aef09b8bd4d6ca96284a0affe6c2/keps/sig-node/127-user-namespaces#motivation

## {{% heading "prerequisites" %}}

{{< include "task-tutorial-prereqs.md" >}} {{< version-check >}}

{{% thirdparty-content single="true" %}}

<!-- якщо в майбутньому додається ще один рантайм, то опустити параметр single -->

* ОС вузла повинна бути Linux
* Ви повинні мати можливість виконувати команди на хості
* Ви повинні мати можливість виконувати команди у Podʼах
* Вам потрібно увімкнути [функціональну можливість](/docs/reference/command-line-tools-reference/feature-gates/) `UserNamespacesSupport`

{{< note >}}
Feature gate для увімкнення просторів імен користувача раніше називався `UserNamespacesStatelessPodsSupport`, коли підтримувалися лише Podʼи без збереження стану. Тільки Kubernetes v1.25 по v1.27 визнають `UserNamespacesStatelessPodsSupport`.
{{</ note >}}

Кластер, який ви використовуєте, **обовʼязково** повинен містити принаймні один вузол, який відповідає [вимогам](/docs/concepts/workloads/pods/user-namespaces/#before-you-begin) щодо використання просторів імен користувача з Podʼами.

Якщо у вас є суміш вузлів і лише деякі з них надають підтримку просторів імен користувача для
Podʼів, вам також потрібно забезпечити те, що Podʼи з просторами імен користувача будуть
[заплановані](/docs/concepts/scheduling-eviction/assign-pod-node/) на відповідні вузли.

<!-- steps -->

## Запуск Podʼа, що використовує простір імен користувача {#create-pod}

Простір імен користувача для Podʼа вимкається, встановленням поля `hostUsers` в `.spec`
на `false`. Наприклад:

{{% code_sample file="pods/user-namespaces-stateless.yaml" %}}

1. Створіть Pod у вашому кластері:

   ```shell
   kubectl apply -f https://k8s.io/examples/pods/user-namespaces-stateless.yaml
   ```

1. Приєднайтеся до Podʼа і виконайте `readlink /proc/self/ns/user`:

   ```shell
   kubectl exec -ti userns -- bash
   ```

Виконайте цю команду:

```shell
read

link /proc/self/ns/user
```

Вивід схожий на:

```shell
user:[4026531837]
```

Також виконайте:

```shell
cat /proc/self/uid_map
```

Вивід схожий на:

```shell
0  833617920      65536
```

Потім відкрийте оболонку на хості та виконайте ті ж самі команди.

Команда `readlink` показує простір імен користувача, в якому працює процес. Він повинен бути різним, коли ви виконуєте його на хості і всередині контейнера.

Останнє число у файлі `uid_map` всередині контейнера повинно бути 65536, на хості це число повинно бути більшим.

Якщо ви запускаєте kubelet всередині простору імен користувача, вам потрібно порівняти вивід команди в Pod з виводом, отриманим на хості:

```shell
readlink /proc/$pid/ns/user
```

замінивши `$pid` на PID kubelet.
