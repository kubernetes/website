---
title: Перевірка впливу видалення dockershim на ваш кластер
content_type: task
weight: 50
---

<!-- overview -->

Компонент `dockershim` Kubernetes дозволяє використовувати Docker як {{< glossary_tooltip text="середовище виконання контейнерів" term_id="container-runtime" >}} Kubernetes. Вбудований компонент `dockershim` Kubernetes був видалений у випуску v1.24.

Ця сторінка пояснює, як ваш кластер може використовувати Docker як середовище виконання контейнерів, надає деталі щодо ролі, яку відіграє `dockershim` при використанні, і показує кроки, які можна виконати, щоб перевірити, чи може видалення `dockershim` впливати на робочі навантаження.

## Пошук залежностей вашого застосунку від Docker {#find-docker-dependencies}

Якщо ви використовуєте Docker для побудови контейнерів вашого застосунку, ви все ще можете запускати ці контейнери на будь-якому середовищі виконання контейнерів. Це використання Docker не вважається залежністю від Docker як середовища виконання контейнерів.

Коли використовується альтернативне середовище виконання контейнерів, виконання команд Docker може або не працювати, або призводити до неочікуваного виводу. Ось як ви можете зʼясувати, чи є у вас залежність від Docker:

1. Переконайтеся, що привілейовані Podʼи не виконують команди Docker (наприклад, `docker ps`), перезапускають службу Docker (команди типу `systemctl restart docker.service`) або змінюють файли Docker, такі як `/etc/docker/daemon.json`.
2. Перевірте наявність приватних реєстрів або налаштувань дзеркал образів у файлі конфігурації Docker (наприклад, `/etc/docker/daemon.json`). Зазвичай їх потрібно повторно налаштувати для іншого середовища виконання контейнерів.
3. Перевірте, що скрипти та застосунки, які працюють на вузлах поза вашою інфраструктурою Kubernetes, не виконують команди Docker. Це може бути:
   - SSH на вузли для усунення несправностей;
   - Сценарії запуску вузлів;
   - Встановлені безпосередньо на вузлах агенти безпеки та моніторингу.
4. Інструменти сторонніх розробників, які виконують вищезгадані привілейовані операції. Див. [Міграція телеметрії та агентів безпеки з dockershim](/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents) для отримання додаткової інформації.
5. Переконайтеся, що немає непрямих залежностей від поведінки dockershim. Це крайній випадок і ймовірно не вплине на ваш застосунок. Деякі інструменти можуть бути налаштовані реагувати на специфічну поведінку Docker, наприклад, видаляти сповіщення про певні метрики або шукати певне повідомлення у лозі як частину інструкцій щодо усунення несправностей. Якщо у вас налаштовано такі інструменти, перевірте поведінку на тестовому кластері перед міграцією.

## Пояснення залежності від Docker {#role-of-dockershim}

[Середовище виконання контейнерів](/docs/concepts/containers/#container-runtimes) — це програмне забезпечення, яке може виконувати контейнери, які складаються з Podʼів Kubernetes. Kubernetes відповідає за оркестрування та планування Podʼів; на кожному вузлі {{< glossary_tooltip text="kubelet" term_id="kubelet" >}} використовує інтерфейс середовища виконання контейнерів як абстракцію, щоб ви могли використовувати будь-яке сумісне середовище виконання контейнерів.

У своїх перших випусках Kubernetes пропонував сумісність з одним середовищем виконання контейнерів — Docker. Пізніше, в історії проєкту Kubernetes, оператори кластерів хотіли б використовувати додаткові середовища виконання контейнерів. CRI було розроблено для того, щоб дозволити такий вид гнучкості — і kubelet почав підтримувати CRI. Однак, оскільки Docker існував до того, як була винайдена специфікація CRI, проєкт Kubernetes створив адаптер `dockershim`. Адаптер dockershim дозволяє kubelet взаємодіяти з Docker так, ніби Docker був середовищем виконання контейнерів, сумісним з CRI.

Ви можете прочитати про це в блозі [Інтеграція Kubernetes Containerd стає загально доступною](/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/).

![Dockershim vs. CRI з Containerd](/images/blog/2018-05-24-kubernetes-containerd-integration-goes-ga/cri-containerd.png)

Перехід до Containerd як середовища виконання контейнерів прибирає посередника. Всі ті самі контейнери можуть бути запущені середовищем виконання контейнерів, такими як Containerd, як і раніше. Але тепер, оскільки контейнери розміщуються безпосередньо з середовищем виконання контейнерів, вони не є видимими для Docker. Отже, будь-який інструментарій Docker або стильний інтерфейс користувача, який ви могли використовувати раніше для перевірки цих контейнерів, більше не доступний.

Ви не можете отримати інформацію про контейнери за допомогою команд `docker ps` або `docker inspect`. Оскільки ви не можете отримувати перелік контейнерів, ви не можете отримати логи, зупинити контейнери або виконати щось всередині контейнера за допомогою `docker exec`.

{{< note >}}

Якщо ви запускаєте робочі навантаження через Kubernetes, найкращий спосіб зупинити контейнер — це через API Kubernetes, а не безпосередньо через середовище виконання контейнерів (ця порада стосується всіх розширень контейнерів, не тільки Docker).

{{< /note >}}

Ви все ще можете отримувати образи або будувати їх за допомогою команди `docker build`. Але образи, побудовані або отримані Docker, не будуть видимі для середовища виконання контейнерів та Kubernetes. Їх потрібно буде розмістити у якомусь реєстрі, щоб їх можна було використовувати в Kubernetes.

## Відомі проблеми {#known-issues}

### Деякі метрики файлової системи відсутні та формат метрик відрізняється {#some-filesystem-metrics-are-missing-and-the-metrics-format-is-different}

Точка доступу Kubelet `/metrics/cadvisor` надає метрики Prometheus, як описано в [Метрики для системних компонентів Kubernetes](/docs/concepts/cluster-administration/system-metrics/). Якщо ви встановите збирач метрик, який залежить від цієї точки доступу, ви можете побачити такі проблеми:

- Формат метрик на вузлі Docker - це `k8s_<container-name>_<pod-name>_<namespace>_<pod-uid>_<restart-count>`, але формат у іншому середовищі відрізняється. Наприклад, на вузлі containerd він має вигляд `<container-id>`.
- Деякі метрики файлової системи відсутні, як описано нижче:

  ```none
  container_fs_inodes_free
  container_fs_inodes_total
  container_fs_io_current
  container_fs_io_time_seconds_total
  container_fs_io_time_weighted_seconds_total
  container_fs_limit_bytes
  container_fs_read_seconds_total
  container_fs_reads_merged_total
  container_fs_sector_reads_total
  container_fs_sector_writes_total
  container_fs_usage_bytes
  container_fs_write_seconds_total
  container_fs_writes_merged_total
  ```

#### Обхідний шлях {#workaround}

Ви можете помʼякшити цю проблему, використовуючи [cAdvisor](https://github.com/google/cadvisor) як автономний DaemonSet.

1. Знайдіть останній [реліз cAdvisor](https://github.com/google/cadvisor/releases) із шаблоном імені `vX.Y.Z-containerd-cri` (наприклад, `v0.42.0-containerd-cri`).
2. Дотримуйтесь кроків у [DaemonSet Kubernetes cAdvisor](https://github.com/google/cadvisor/tree/master/deploy/kubernetes), щоб створити DaemonSet.
3. Drf;Вкажіть збирачу метрик використовувати точку доступу `/metrics` cAdvisor, яка надає повний набір [метрик контейнера в форматі Prometheus](https://github.com/google/cadvisor/blob/master/docs/storage/prometheus.md).

Альтернативи:

- Використовуйте альтернативне рішення для збору метрик сторонніх розробників.
- Збирайте метрики з Kubelet summary API, який доступний через `/stats/summary`.

## {{% heading "whatsnext" %}}

- Прочитайте [Міграція з dockershim](/docs/tasks/administer-cluster/migrating-from-dockershim/), щоб зрозуміти наступні кроки
- Прочитайте статтю [dockershim deprecation FAQ](/blog/2020/12/02/dockershim-faq/) для отримання додаткової інформації.
