---
title: Захист кластера
content_type: task
weight: 320
---

<!-- overview -->

У цьому документі розглядаються теми, повʼязані з захистом кластера від випадкового або зловмисного доступу та надаються загальні рекомендації безпеки.

## {{% heading "prerequisites" %}}

* {{< include "task-tutorial-prereqs.md" >}} {{< version-check >}}

<!-- steps -->

## Контроль доступу до API Kubernetes {#controlling-access-to-the-kubernetes-api}

Оскільки Kubernetes повністю заснований на API, контроль та обмеження, хто може мати доступ до кластера та які дії вони можуть виконувати, є першою лінією захисту.

### Використання Transport Layer Security (TLS) для всього трафіку API {#using-transport-layer-security-tls-for-all-api-traffic}

Kubernetes очікує, що всі комунікації API в кластері будуть типово зашифровані за допомогою TLS, і більшість методів встановлення дозволять створювати необхідні сертифікати та розподіляти їх між компонентами кластера. Зверніть увагу, що деякі компоненти та методи встановлення можуть дозволяти локальні порти через HTTP, і адміністраторам варто ознайомитися з налаштуваннями кожного компонента для ідентифікації потенційно незахищеного трафіку.

### Автентифікація API {#api-authentication}

Виберіть механізм автентифікації для використання API-серверами, який відповідає загальним сценаріям доступу при встановленні кластера. Наприклад, невеликі, однокористувацькі кластери можуть бажати використовувати простий підхід з використанням сертифікатів або статичних токенів Bearer. Більші кластери можуть бажати інтегрувати наявний сервер OIDC або LDAP, який дозволяє розподіляти користувачів на групи.

Всі клієнти API повинні бути автентифіковані, навіть ті, що є частиною інфраструктури, такі як вузли, проксі, планувальник та втулки томів. Зазвичай ці клієнти є [сервісними обліковими записами](/docs/reference/access-authn-authz/service-accounts-admin/) або використовують сертифікати клієнта x509, і вони створюються автоматично при запуску кластера або налаштовуються як частина встановлення кластера.

Для отримання додаткової інформації звертайтеся до [документації з автентифікації](/docs/reference/access-authn-authz/authentication/).

### Авторизація API {#api-authorization}

Після автентифікації кожен виклик API також повинен пройти перевірку авторизації. Kubernetes має вбудований компонент контролю доступу на основі ролей ([Role-Based Access Control (RBAC)](/docs/reference/access-authn-authz/rbac/)), який зіставляє користувача або групу набору дозволів, згрупованих за ролями. Ці дозволи поєднують дії (отримати, створити, видалити) з ресурсами (Podʼи, служби, вузли) і можуть бути обмежені простором імен або розгортанням кластера. Доступні набори стандартних ролей, які надають розумне розділення відповідальності залежно від дій, які може бажати виконати клієнт. Рекомендується використовувати авторизатори [Node](/docs/reference/access-authn-authz/node/) та [RBAC](/docs/reference/access-authn-authz/rbac/) разом з втулком входу [NodeRestriction](/docs/reference/access-authn-authz/admission-controllers/#noderestriction).

Так само як і з автентифікацією, для менших кластерів можуть бути відповідні прості та загальні ролі, але зі збільшенням кількості користувачів, які взаємодіють з кластером, може знадобитися розділити команди на окремі {{< glossary_tooltip text="простори імен" term_id="namespace" >}} з більш обмеженими ролями.

При авторизації важливо розуміти, як оновлення одного обʼєкта може призвести до дій в інших місцях. Наприклад, користувач не зможе створити Podʼи безпосередньо, але дозволивши їм створювати Deployment, що створює Podʼи для них, дозволить їм створювати ці Podʼи опосередковано. Так само, видалення вузла з API призведе до припинення роботи Podʼів, запланованих на цей вузол, і їх повторного створення на інших вузлах. Стандартні ролі являють собою компроміс між гнучкістю та загальними випадками використання, але більш обмежені ролі повинні бути уважно переглянуті, щоб запобігти випадковому підвищенню привілеїв. Якщо стандартні ролі не відповідають вашим потребам, ви можете створити ролі, специфічні для вашого випадку використання.

Для отримання додаткової інформації звертайтеся до [розділу довідки з авторизації](/docs/reference/access-authn-authz/authorization/).

## Контроль доступу до Kubelet {#controlling-access-to-the-kubelet}

Kubelet експонує HTTPS-точки доступу, які надають потужний контроль над вузлом та контейнерами. Типово Kubelet дозволяє неавтентифікований доступ до цього API.

Операційні кластери повинні увімкнути автентифікацію та авторизацію Kubelet.

Для отримання додаткової інформації звертайтеся до [розділу довідки з автентифікації/авторизації Kubelet](/docs/reference/access-authn-authz/kubelet-authn-authz/).

## Керування можливостями робочого навантаження або користувача під час виконання {#controlling-the-capabilities-of-a-workload-or-user-at-runtime}

Авторизація в Kubernetes має високий рівень, спрямований на грубі дії з ресурсами. Більш потужні елементи керування існують як **політики** для обмеження за випадком використання того, як ці обʼєкти діють на кластер, себе та інші ресурси.

### Обмеження використання ресурсів у кластері {#limiting-resource-usage-on-a-cluster}

[Квоти ресурсів](/docs/concepts/policy/resource-quotas/) обмежують кількість або потужність виділених ресурсів для простору імен. Це найчастіше використовується для обмеження обсягу процесора, памʼяті або постійного дискового простору, який може виділятися простору імен, але також може контролювати кількість Podʼів, Serviceʼів або томів, що існують у кожному просторі імен.

[Діапазони обмежень](/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/) обмежують максимальний або мінімальний розмір деяких з вищезазначених ресурсів, щоб уникнути можливості користувачів запитувати надмірно високі або низькі значення для часто зарезервованих ресурсів, таких як памʼять, або надавати типові значення, коли вони не вказані.

### Керування привілеями, з якими працюють контейнери {#controlling-the-privileges-containers-run-with}

В описі Podʼа міститься [контекст безпеки](/docs/tasks/configure-pod-container/security-context/), який дозволяє запитувати доступ до виконання від імені конкретного користувача Linux на вузлі (наприклад, root), доступ до виконання з підвищеними привілеями або доступ до мережі хосту та інші елементи керування, які інакше дозволили б йому працювати без обмежень на вузлі хосту.

Ви можете налаштувати [допуски безпеки Pod](/docs/concepts/security/pod-security-admission/), щоб забезпечити використання певного [стандарту безпеки Pod](/docs/concepts/security/pod-security-standards/) у {{< glossary_tooltip text="просторі імен" term_id="namespace" >}} або виявити порушення.

Загалом, більшість робочих навантажень застосунків потребують обмеженого доступу до ресурсів хосту, щоб вони могли успішно працювати як процес root (uid 0) без доступу до інформації про хост. Однак, враховуючи привілеї, повʼязані з користувачем root, слід робити контейнери застосунків такими, що не вимагають прав root для виконання. Так само адміністратори, які бажають запобігти втечі клієнтських застосунків з їхніх контейнерів, повинні застосувати стандарт безпеки Pod **Baseline** або **Restricted**.

### Запобігання завантаженню небажаних модулів ядра контейнерами {#preventing-containers-from-loading-unwanted-kernel-modules}

Ядро Linux автоматично завантажує модулі ядра з диска за потребою в певних обставинах, наприклад, коли пристрій приєднаний або файлова система змонтована. Особливо актуальним для Kubernetes є те, що навіть непривілейовані процеси можуть спричинити завантаження певних модулів, повʼязаних з мережевими протоколами, просто створюючи сокет відповідного типу. Це може дозволити зловмиснику використовувати дірку в безпеці ядра, щодо якої адміністратор має припущення, що вона не використовується.

Щоб запобігти автоматичному завантаженню конкретних модулів, ви можете деінсталювати їх з вузла або додати правила для їх блокування. У більшості дистрибутивів Linux ви можете це зробити, створивши файл, наприклад, `/etc/modprobe.d/kubernetes-blacklist.conf`, з таким вмістом:

```none
# DCCP майже не потрібен, має кілька серйозних вразливостей
# і не знаходиться у доброму стані обслуговування.
blacklist dccp

# SCTP не використовується в більшості кластерів Kubernetes, і також мав
# вразливості в минулому.
blacklist sctp
```

Для більш загального блокування завантаження модулів можна використовувати Linux Security Module (наприклад, SELinux), щоб абсолютно відмовити контейнерам у дозволі `module_request`, запобігаючи ядру завантажувати модулі для контейнерів у будь-яких обставинах. (Podʼи все ще можуть використовувати модулі, які були завантажені вручну або модулі, які були завантажені ядром від імені якогось більш привілейованого процесу.)

### Обмеження доступу до мережі {#restricting-network-access}

[Мережеві політики](/docs/tasks/administer-cluster/declare-network-policy/) для простору імен дозволяють авторам застосунків обмежувати, які Podʼи в інших просторах імен можуть отримувати доступ до Podʼів і портів у їхніх просторах імен. Багато з підтримуваних [постачальників мережі Kubernetes](/docs/concepts/cluster-administration/networking/) зараз враховують мережеві політики.

Також можна використовувати квоти та діапазони обмежень, щоб контролювати, чи можуть користувачі запитувати порти вузла або послуги з балансування навантаження, що у багатьох кластерах може контролювати видимість застосунків цих користувачів поза межами кластера.

Додаткові захисти можуть бути доступні, які контролюють правила мережі на рівні втулка чи середовища, такі як брандмауери на рівні вузла, фізичне розділення вузлів кластера для запобігання звʼязку між ними або розширена політика мережевого зʼєднання.

### Обмеження доступу до API метаданих хмари {#restricting-cloud-metadata-api-access}

Хмарні платформи (AWS, Azure, GCE і т. д.) часто надають доступ до служб метаданих локально на екземплярах обчислювальних потужностей. Типово ці API доступні Podʼам, що працюють на екземплярі, і можуть містити облікові дані хмари для цього вузла або дані про створення, такі як облікові дані kubelet. Ці облікові дані можуть бути використані для підвищення привілеїв всередині кластера або до інших хмарних служб за тим самим обліковим записом.

При запуску Kubernetes на хмарній платформі обмежуйте дозволи, надані обліковим записам екземплярів, використовуйте [мережеві політики](/docs/tasks/administer-cluster/declare-network-policy/) для обмеження доступу Podʼів до API метаданих та уникайте використання даних про створення для передачі секретів.

### Керування того, до яких вузлів мають доступ Podʼи {#controlling-which-nodes-pods-may-access}

Стандартно не має обмежень, щодо того, на яких вузлах може запускатися Pod. Kubernetes пропонує [широкий набір політик для керування розміщенням Podʼів на вузлах](/docs/concepts/scheduling-eviction/assign-pod-node/) та [політику розміщення та виселення Podʼів на основі позначок](/docs/concepts/scheduling-eviction/taint-and-toleration/), доступні для кінцевих користувачів. Для багатьох кластерів використання цих політик для розділення робочих навантажень може бути домовленістю, якої автори дотримуються або впроваджують через інструментарій.

Як адміністратор, бета-втулок обробки доспуску `PodNodeSelector` може бути використаний для примусового призначення Podʼів у межах стандартного простору імен або для вимоги до вказання певного селектора вузла, і якщо кінцеві користувачі не можуть змінювати простори імен, це може суттєво обмежити розміщення всіх Podʼів в певному робочому навантаженні.

## Захист компонентів кластера від компрометації {#protecting-cluster-components-from-compromise}

У цьому розділі описані деякі загальні шаблони для захисту кластерів від компрометації.

### Обмеження доступу до etcd {#restricting-access-to-etcd}

Права на запис до бази даних etcd для API еквівалентні отриманню root-прав на весь кластер, а доступ на читання може бути використаний для ескалації досить швидко. Адміністратори повинні завжди використовувати надійні облікові дані від серверів API до сервера etcd, такі як взаємна автентифікація за допомогою сертифікатів TLS клієнта, і часто рекомендується ізолювати сервери etcd за допомогою брандмауера, до яких можуть отримувати доступ лише сервери API.

{{< caution >}}
Дозвіл іншим компонентам в межах кластера доступу до головного екземпляра etcd з правами на читання або запис повного простору ключів еквівалентний наданню прав адміністратора кластера. Рекомендується використовувати окремі екземпляри etcd для компонентів, які не є головними, або використовувати ACL etcd для обмеження доступу на читання та запис до підмножини простору ключів.
{{< /caution >}}

### Увімкнення логування аудиту {#enabling-audit-logging}

[Audit logger](/docs/tasks/debug/debug-cluster/audit/) є бета-функцією, яка записує дії, виконані API, для подальшого аналізу в разі компрометації. Рекомендується увімкнути логування аудиту та архівувати файл аудиту на захищеному сервері.

### Обмеження доступу до альфа- або бета-функцій {#restricting-access-to-alpha-or-beta-features}

Альфа- і бета-функції Kubernetes знаходяться в активній розробці і можуть мати обмеження або помилки, які призводять до вразливостей безпеки. Завжди оцінюйте цінність, яку можуть надати альфа- або бета-функції, у порівнянні з можливим ризиком для вашої безпеки. У разі сумнівів вимикайте функції, які ви не використовуєте.

### Часто змінюйте облікові дані інфраструктури {#rotate-infrastructure-credentials-frequently}

Чим коротший термін дії Secret або облікового запису, тим складніше для зловмисника використати цей обліковий запис. Встановлюйте короткі терміни дії на сертифікати та автоматизуйте їх ротацію. Використовуйте постачальника автентифікації, який може контролювати терміни дії виданих токенів та використовуйте короткі терміни дії, де це можливо. Якщо ви використовуєте токени службового облікового запису в зовнішніх інтеграціях, плануйте часту ротацію цих токенів. Наприклад, як тільки завершиться фаза запуску, токен запуску, використаний для налаштування вузлів, повинен бути відкликаний або його запис авторизації скасований.

### Перегляд інтеграцій сторонніх розробників перед їх включенням {#review-third-party-integrations-before-enabling-them}

Багато сторонніх інтеграцій до Kubernetes можуть змінювати профіль безпеки вашого кластера. При включенні інтеграції завжди переглядайте дозволи, які запитує розширення, перед наданням доступу. Наприклад, багато інтеграцій з безпеки можуть запитувати доступ до перегляду всіх секретів у вашому кластері, що фактично робить цей компонент адміністратором кластера. У разі сумнівів обмежте інтеграцію на роботу в одному просторі імен, якщо це можливо.

Компоненти, які створюють Podʼи, також можуть мати неочікувану потужність, якщо вони можуть робити це всередині просторів імен, таких як простір імен `kube-system`, оскільки ці Podʼи можуть отримати доступ до секретів службових облікових записів або працювати з підвищеними привілеями, якщо цим службовим обліковим записам надано доступ до дозвольних [PodSecurityPolicies](/docs/concepts/security/pod-security-policy/).

Якщо ви використовуєте [Pod Security admission](/docs/concepts/security/pod-security-admission/) та дозволяєте будь-якому компоненту створювати Podʼи в межах простору імен, що дозволяє привілейовані Podʼи, ці Podʼи можуть мати здатність втікати зі своїх контейнерів і використовувати цей розширений доступ для підвищення своїх привілеїв.

Ви не повинні дозволяти ненадійним компонентам створювати Podʼи в будь-якому системному просторі імен (те, що починається з `kube-`) або в будь-якому просторі імен, де цей доступ дозволяє можливість підвищення привілеїв.

### Шифрування секретів у спокої {#encrypt-secrets-at-rest}

Загалом, база даних etcd буде містити будь-яку інформацію, доступну через API Kubernetes і може надати зловмиснику значний обсяг інформації про стан вашого кластера. Завжди шифруйте свої резервні копії за допомогою розглянутого рішення для резервного копіювання та шифрування, і розгляньте можливість використання повного шифрування диска, де це можливо.

Kubernetes підтримує необовʼязкове [шифрування у спокої](/docs/tasks/administer-cluster/encrypt-data/) для інформації в API Kubernetes. Це дозволяє вам забезпечити те, що при збереженні Kubernetes даних для обʼєктів (наприклад, обʼєктів `Secret` або `ConfigMap`), сервер API записує зашифроване представлення обʼєкта. Це шифрування означає, що навіть у того, хто має доступ до даних резервних копій etcd, не має можливості переглянути вміст цих обʼєктів. У Kubernetes {{< skew currentVersion >}} ви також можете шифрувати власні ресурси; шифрування в спокої для розширених API, визначених у визначеннях CustomResourceDefinitions, було додано в Kubernetes як частина випуску v1.26.

### Отримання сповіщень про оновлення безпеки та повідомлення про вразливості {#receiving-alerts-for-security-updates-and-reporting-vulnerabilities}

Приєднуйтесь до групи [kubernetes-announce](https://groups.google.com/forum/#!forum/kubernetes-announce), щоб отримувати електронні листи про оголошення з питань безпеки. Див. сторінку [повідомлень про безпеку](/docs/reference/issues-security/security/) для отримання додаткової інформації щодо повідомлення про вразливості.

## Що далі {#whats-next}

* [Контрольний список безпеки](/docs/concepts/security/security-checklist/) для отримання додаткової інформації щодо керівництва з безпеки Kubernetes.
* [Довідка Seccomp вузлів](/docs/reference/node/seccomp/)
