---
title: Адміністрування менеджера хмарного контролера
content_type: concept
weight: 110
---

<!-- overview -->

{{< feature-state state="beta" for_k8s_version="v1.11" >}}

Оскільки хмарні провайдери розвиваються та випускають нові функції в іншому темпі порівняно з проєктом Kubernetes, абстрагування провайдеро-залежного коду у бінарний файл `{{< glossary_tooltip text="cloud-controller-manager" term_id="cloud-controller-manager" >}}` дозволяє хмарним постачальникам розвиватися незалежно від основного коду Kubernetes.

`cloud-controller-manager` може бути повʼязаний з будь-яким хмарним провайдером, який відповідає вимогам [cloudprovider.Interface](https://github.com/kubernetes/cloud-provider/blob/master/cloud.go). Для забезпечення зворотної сумісності, [cloud-controller-manager](https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager), що постачається у складі основного проєкту Kubernetes, використовує ті ж хмарні бібліотеки, що і `kube-controller-manager`. Очікується, що хмарні постачальники, які вже підтримуються у ядрі Kubernetes, використовуватимуть вбудований cloud-controller-manager для передачі даних з ядра Kubernetes.

<!-- body -->

## Адміністрування {#administration}

### Вимоги {#requirements}

Кожна хмара має свій власний набір вимог для запуску своєї інтеграції з власним провайдером, це не повинно суттєво відрізнятися від вимог до запуску `kube-controller-manager`. Загалом вам знадобиться:

* автентифікація/авторизація в хмарі: вашій хмарі може знадобитися токен або правила IAM, щоб дозволити доступ до їхніх API
* автентифікація/авторизація в Kubernetes: cloud-controller-manager може потребувати налаштування RBAC правила для звʼязку з apiserver Kubernetes
* висока доступність: як і kube-controller-manager, вам може знадобитися налаштування високої доступності для cloud controller manager з використанням вибору лідера (стандартно увімкнено).

### Робота cloud-controller-manager {#running-cloud-controller-manager}

Успішне виконання cloud-controller-manager вимагає деяких змін у конфігурації кластера.

* `kubelet` та `kube-controller-manager` повинні бути налаштовані відповідно до використання користувачем зовнішнього CCM. Якщо користувач має зовнішній CCM (не внутрішні цикли управління хмарою в Kubernetes Controller Manager), то `--cloud-provider=external` повинен бути вказаний. В іншому випадку це не повинно бути вказано.

Майте на увазі, що налаштування кластера на використання контролера хмарного провайдера змінить поведінку вашого кластера:

* Компоненти, що вказують `--cloud-provider=external`, додають спеціальний taint `node.cloudprovider.kubernetes.io/uninitialized` з ефектом `NoSchedule` під час ініціалізації. Це помічає вузол як такий, що потребує другої ініціалізації з зовнішнього контролера перед тим, як він зможе розпочати роботу. Зверніть увагу, що в разі недоступності cloud-controller-manager, нові вузли у кластері залишаться незапланованими. Taint важливий, оскільки планувальник може вимагати специфічної для хмари інформації про вузли, такої як їхній регіон чи тип (high cpu, gpu, high memory, spot instance тощо).
* інформація про вузли в кластері більше не буде вибиратися з локальних метаданих, а замість цього всі виклики API для вибору інформації про вузли будуть проходити через cloud controller manager. Це може означати, що ви можете обмежити доступ до вашого API хмари на kubelet для кращої безпеки. Для великих кластерів вам може бути доцільно розглянути можливість обмеження швидкості викликів API cloud controller manager, оскільки він тепер відповідальний майже за всі виклики API вашої хмари зсередини кластера.

Контролер хмарного провайдера може надавати:

* контролер Node — відповідає за оновлення вузлів Kubernetes з використанням API хмари та видалення вузлів Kubernetes, які були видалені у вашій хмарі.
* контролер Service — відповідає за балансування навантаження у вашій хмарі для сервісів типу LoadBalancer.
* контролер Route — відповідає за налаштування мережевих маршрутів у вашій хмарі
* будь-які інші функції, які ви хочете реалізувати, якщо ви використовуєте провайдера не з ядра Kubernetes.

## Приклади {#examples}

Якщо ви використовуєте хмару, яка наразі підтримується в ядрі Kubernetes і хочете використовувати контролер хмарного провайдера, див. [контролер хмарного провайдера в ядрі Kubernetes](https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager).

Для контролерів хмарних провайдерів, які не входять у ядро Kubernetes, ви можете знайти відповідні проєкти у репозиторіях, підтримуваних хмарними постачальниками або SIGs.

Для провайдерів, які вже є в ядрі Kubernetes, ви можете запускати вбудований контролер хмарного провайдера як DaemonSet у вашому кластері, використовуючи наступне як рекомендацію:

{{% code_sample file="admin/cloud/ccm-example.yaml" %}}

## Обмеження {#limitations}

Запуск контролера хмарного провайдера супроводжується кількома можливими обмеженнями. Хоча ці обмеження вирішуються у майбутніх релізах, важливо, щоб ви були обізнані з цими обмеженнями для операційних робочих навантажень.

### Підтримка томів {#support-for-volumes}

Контролер хмарного провайдера не реалізує жодного з контролерів томів, що знаходяться в `kube-controller-manager`, оскільки інтеграція томів також потребує координації з kubelet. Під час розвитку CSI (інтерфейс контейнерного сховища) та додавання більш надійної підтримки втулків flex томів буде додано необхідну підтримку до контролера хмарного провайдера, щоб хмари могли повністю інтегруватися з томами. Дізнайтеся більше про зовнішні втулки томів CSI [тут](https://github.com/kubernetes/features/issues/178).

### Масштабованість {#scalability}

Контролер хмарного провайдера запитує API вашого хмарного постачальника для отримання інформації про всі вузли. Для дуже великих кластерів розгляньте можливі вузькі місця, такі як вимоги до ресурсів та обмеження швидкості API.

### Курча і яйце {#chicken-and-egg}

Метою проєкту контролера хмарного провайдера є відділення розробки хмарних функцій від розробки проєкту ядра Kubernetes. На жаль, багато аспектів проєкту Kubernetes мають припущення, що функції хмарного провайдера тісно інтегровані у проєкт. Внаслідок цього, прийняття цієї нової архітектури може створити кілька ситуацій, коли робиться запит інформації від хмарного постачальника, але контролер хмарного провайдера може не мати можливості повернути цю інформацію без завершення початкового запиту.

Хорошим прикладом цього є функція TLS bootstrapping в Kubelet. TLS bootstrapping передбачає, що Kubelet має можливість запитати у хмарного провайдера (або локального сервісу метаданих) всі його типи адрес (приватні, публічні і т. д.), але контролер хмарного провайдера не може встановити типи адрес вузла без попередньої ініціалізації, що потребує, щоб kubelet мав TLS-сертифікати для звʼязку з apiserver.

Під час розвитку цієї ініціативи будуть внесені зміни для розвʼязання цих питань у майбутніх релізах.

## {{% heading "whatsnext" %}}

Щоб створити та розробити свій власний контролер хмарного провайдера, прочитайте [Розробка контролера хмарного провайдера](/docs/tasks/administer-cluster/developing-cloud-controller-manager/).
