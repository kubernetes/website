---
title: Імперативне керування обʼєктами Kubernetes за допомогою файлів конфігурації
content_type: task
weight: 40
---

<!-- overview -->
Обʼєкти Kubernetes можна створювати, оновлювати та видаляти за допомогою інструменту командного рядка `kubectl` разом із файлом конфігурації обʼєкта, написаним у форматі YAML або JSON. У цьому документі пояснюється, як визначати та керувати обʼєктами за допомогою файлів конфігурації.

## {{% heading "prerequisites" %}}

Встановіть [`kubectl`](/docs/tasks/tools/).

{{< include "task-tutorial-prereqs.md" >}} {{< version-check >}}

<!-- steps -->

## Компроміси {#trade-offs}

Інструмент `kubectl` підтримує три види управління обʼєктами:

* Імперативні команди
* Імперативне конфігурування обʼєктів
* Декларативне конфігурування обʼєктів

Див. [Управління обʼєктами Kubernetes](/docs/concepts/overview/working-with-objects/object-management/) для обговорення переваг та недоліків кожного виду управління обʼєктами.

## Як створювати обʼєкти {#how-to-create-objects}

Ви можете використовувати `kubectl create -f` для створення обʼєкта з файлу конфігурації. Дивіться [Довідник API Kubernetes](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/) для отримання деталей.

* `kubectl create -f <filename|url>`

## Як оновити обʼєкти {#how-to-update-objects}

{{< warning >}}
Оновлення обʼєктів за допомогою команди `replace` призводить до видалення всіх частин специфікації, які не вказані в файлі конфігурації. Це не слід використовувати з обʼєктами, чиї специфікації частково керуються кластером, наприклад, Service типу `LoadBalancer`, де поле `externalIPs` керується незалежно від файлу конфігурації. Поля, які керуються незалежно, повинні бути скопійовані в файл конфігурації, щоб уникнути їх втрати під час виконання `replace`.
{{< /warning >}}

Ви можете використовувати `kubectl replace -f` для оновлення поточного обʼєкта згідно з файлом конфігурації.

* `kubectl replace -f <filename|url>`

## Як видалити обʼєкти {#how-to-delete-objects}

Ви можете використовувати `kubectl delete -f` для видалення обʼєкта, який описаний у файлі конфігурації.

* `kubectl delete -f <filename|url>`

{{< warning >}}
Якщо файл конфігурації вказує поле `generateName` в секції `metadata` замість поля `name`, ви не можете видалити обʼєкт, використовуючи `kubectl delete -f <filename|url>`. Вам доведеться використовувати інші прапорці для видалення обʼєкта. Наприклад:

```shell
kubectl delete <тип> <імʼя>
kubectl delete <тип> -l <мітка>
```

{{< /warning >}}

## Як переглянути обʼєкт {#how-to-view-objects}

Ви можете використовувати `kubectl get -f`, щоб переглянути інформацію про обʼєкт, що описаний у файлі конфігурації.

* `kubectl get -f <filename|url> -o yaml`

Прапорець `-o yaml` вказує, що повна конфігурація обʼєкта виводиться. Використовуйте `kubectl get -h`, щоб побачити список опцій.

## Обмеження {#limitations}

Команди `create`, `replace` та `delete` працюють добре, коли кожна конфігурація обʼєкта повністю визначена і записана у своєму файлі конфігурації. Однак, коли поточний обʼєкт оновлюється, і оновлення не обʼєднуються в його файл конфігурації, оновлення будуть втрачені після наступного виконання `replace`. Це може статися, якщо контролер, такий як HorizontalPodAutoscaler, вносить оновлення безпосередньо до поточного обʼєкта. Ось приклад:

1. Ви створюєте обʼєкт з файлу конфігурації.
1. Інше джерело оновлює обʼєкт, змінюючи якесь поле.
1. Ви замінюєте обʼєкт з файлу конфігурації. Зміни, внесені іншим джерелом на кроці 2, втрачені.

Якщо вам потрібна підтримка кількох записувачів для одного обʼєкта, ви можете використовувати `kubectl apply` для керування обʼєктом.

## Створення та редагування обʼєкта за URL без зберігання конфігурації {#creating-and-editing-an-object-from-a-url-without-saving-the-configuration}

Припустимо, що у вас є URL файлу конфігурації обʼєкта. Ви можете використовувати `kubectl create --edit` для внесення змін до конфігурації перед створенням обʼєкта. Це особливо корисно для підручників та завдань, які вказують на файл конфігурації, який може бути змінений читачем.

```shell
kubectl create -f <url> --edit
```

## Міграція від імперативних команд до імперативного конфігурування обʼєктів {#migrating-from-imperative-commands-to-imperative-object-configuration}

Міграція від імперативних команд до імперативної конфігурації обʼєктів включає декілька кроків, які потрібно виконати вручну.

1. Експортуйте поточний обʼєкт у локальний файл конфігурації обʼєкта:

    ```shell
    kubectl get <kind>/<name> -o yaml > <kind>_<name>.yaml
    ```

2. Ручне видалення поля стану з файлу конфігурації обʼєкта.

3. Для подальшого керування обʼєктом виключно використовуйте `replace`.

    ```shell
    kubectl replace -f <kind>_<name>.yaml
    ```

## Визначення селекторів контролерів та міток PodTemplate {#defining-controller-selectors-and-podtemplate-labels}

{{< warning >}}
Оновлення селекторів на контролерах наполегливо не рекомендується.
{{< /warning >}}

Рекомендований підхід — визначити одну незмінну мітку PodTemplate, яка використовується тільки селектором контролера без іншого семантичного значення.

Приклад мітки:

```yaml
selector:
  matchLabels:
      controller-selector: "apps/v1/deployment/nginx"
template:
  metadata:
    labels:
      controller-selector: "apps/v1/deployment/nginx"
```

## {{% heading "whatsnext" %}}

* [Управління обʼєктами Kubernetes за допомогою імперативних команд](/docs/tasks/manage-kubernetes-objects/imperative-command/)
* [Декларативне керування обʼєктами Kubernetes за допомогою файлів конфігурації](/docs/tasks/manage-kubernetes-objects/declarative-config/)
* [Довідник команд Kubectl](/docs/reference/generated/kubectl/kubectl-commands/)
* [Довідник API Kubernetes](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/)
