---
api_metadata:
  apiVersion: ""
  import: "k8s.io/apimachinery/pkg/apis/meta/v1"
  kind: "ObjectMeta"
content_type: "api_reference"
description: "ObjectMeta — це метадані, які повинні бути у всіх збережених ресурсів, включаючи всі обʼєкти, які користувачі повинні створювати."
title: "ObjectMeta"
weight: 7
auto_generated: false
---

`import "k8s.io/apimachinery/pkg/apis/meta/v1"`

ObjectMeta — це метадані, які повинні бути у всіх збережених ресурсів, включаючи всі обʼєкти, які користувачі повинні створювати.

----

- **name** (string)

  Ім’я (назва) має бути унікальним у просторі імен. Потрібне під час створення ресурсів, хоча деякі ресурси можуть дозволяти клієнту запитувати створення відповідного імені автоматично. Назва в першу чергу призначена для створення ідемпотентності та визначення конфігурації. Не може бути змінене. Більше інформації: [https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names](/docs/concepts/overview/working-with-objects/names#names)

- **generateName** (string)

  GenerateName — це необов’язковий префікс, який використовується сервером для генерації унікального імені, ТІЛЬКИ ЯКЩО поле Name не було надано. Якщо використовується це поле, ім’я, що повертається клієнту, відрізнятиметься від переданого. Це значення також поєднується з унікальним суфіксом. Надане значення має ті самі правила перевірки, що й поле Name, і може бути скорочено на довжину суфікса, необхідного для того, щоб зробити значення унікальним на сервері.

  Якщо це поле вказано, а згенерована назва існує, сервер поверне 409.

  Застосовується, лише якщо ім’я не вказано. Більше інформації: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency

- **namespace** (string)

  Простір імен визначає простір, у якому кожне ім’я має бути унікальним. Порожній простір імен еквівалентний простору імен "default", але "default" є канонічним представленням. Не всі об’єкти повинні мати область імен — значення цього поля для цих об’єктів буде порожнім.

  Має бути DNS_LABEL. Не може бути змінене. Більше інформації: [https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces](/docs/concepts/overview/working-with-objects/namespaces)

- **labels** (map[string]string)

  Масив (map) рядків ключів і значень, які можна використовувати для організації та категоризації (охоплення та вибору) обʼєктів. Може відповідати селекторам контролерів реплікації та сервісів. Більше інформації: [https://kubernetes.io/docs/concepts/overview/working-with-objects/labels](/docs/concepts/overview/working-with-objects/labels)

- **annotations** (map[string]string)

  Анотації — це неструктурований масив (map) значень ключів, що зберігається з ресурсом, який може бути заданий зовнішніми інструментами для зберігання та отримання довільних метаданих. Вони не є запитуваними та повинні зберігатися при модифікації обʼєктів. Більше інформації: [https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations](/docs/concepts/overview/working-with-objects/annotations)

### System {#system}

- **finalizers** ([]string)

   *Set: унікальні значення будуть збережені під час злиття*

  Це поле повинно бути порожнім перед тим, як обʼєкт буде видалено з реєстру. Кожен запис є ідентифікатором відповідального компонента, який видалить цей запис зі списку. Якщо `deletionTimestamp` обʼєкта не є nil, записи у цьому списку можуть бути лише видалені. Завершувачі можуть оброблятися та видалятися у будь-якому порядку. Порядок НЕ є обовʼязковим, оскільки це створює значний ризик зависання завершувачів. Поле `finalizers` є спільним, будь-який актор з відповідними дозволами може змінити його порядок. Якщо список завершувачів обробляється у порядку, це може призвести до ситуації, коли компонент, відповідальний за перший завершувач у списку, чекає сигналу (значення поля, зовнішньої системи або іншого), що виробляється компонентом, відповідальним за завершувача, який знаходиться далі у списку, що призводить до тупикової ситуації. Без обовʼязкового порядку завершувачі можуть впорядковуватися самостійно та не вразливі до змін порядку у списку.

- **managedFields** ([]ManagedFieldsEntry)

  *Atomic: буде замінено під час злиття*

  ManagedFields зіставляє ідентифікатор робочого процесу та версію з набором полів, якими керує цей робочий процес. Це здебільшого для внутрішнього ведення обліку, і користувачам зазвичай не потрібно встановлювати або розуміти це поле. Робочий процес може бути імʼям користувача, імʼям контролера або імʼям конкретного шляху застосування, як-от "ci-cd". Набір полів завжди знаходиться у версії, яку використовував робочий процес при зміні обʼєкта.

  <a name="ManagedFieldsEntry"></a>
  *ManagedFieldsEntry — це ідентифікатор робочого процесу, набір полів (FieldSet) і версія групи ресурсу, до якого застосовується набір полів.*

  - **managedFields.apiVersion** (string)

    APIVersion визначає версію ресурсу, до якого застосовується цей набір полів. Формат такий самий, як у верхньорівневого поля APIVersion: "group/version". Це необхідно для відстеження версії набору полів, оскільки він не може бути автоматично конвертований.

  - **managedFields.fieldsType** (string)

    FieldsType є дискримінатором для різних форматів і версій полів. На цей час можливе лише одне значення: "FieldsV1".

  - **managedFields.fieldsV1** (FieldsV1)

    FieldsV1 зберігає перший формат JSON версії, як описано в типі "FieldsV1".

    <a name="FieldsV1"></a>
    *FieldsV1 зберігає набір полів у структурі даних, подібній до Trie, у форматі JSON.

    Кожен ключ або представляє саму область (позначену як '.'), і завжди буде зіставлятись з порожнім набором, або є рядком, що представляє субполе або елемент. Рядок буде слідувати одному з чотирьох форматів: `f:<name>`, де `<name>` — це імʼя поля в структурі або ключа в map; `v:<value>`, де `<value>` — це точне значення у форматі JSON для елемента списку; `i:<index>`, де `<index>` — це позиція елемента у списку; `k:<keys>`, де `<keys>` — це масив (map) полів ключів елемента списку з їх унікальними значеннями. Якщо ключ зіставляється з порожнім значенням Fields, поле, яке представляє цей ключ, є частиною набору.

    Точний формат визначено в sigs.k8s.io/structured-merge-diff*

  - **managedFields.manager** (string)

    Manager є ідентифікатором робочого процесу, що керує цим набором полів.

  - **managedFields.operation** (string)

    Operation — це тип операції, яка призвела до створення цього запису ManagedFieldsEntry. Єдині допустимі значення для цього поля — 'Apply' та 'Update'.

  - **managedFields.subresource** (string)

    Subresource — це назва субресурсу, який використовується для оновлення цього обʼєкта, або порожній рядок, якщо обʼєкт було оновлено через основний ресурс. Значення цього поля використовується для розрізнення між менеджерами, навіть якщо вони мають однакові імена. Наприклад, оновлення статусу буде відрізнятися від звичайного оновлення за допомогою того самого імені менеджера. Зверніть увагу, що поле APIVersion не повʼязане з полем Subresource і завжди відповідає версії основного ресурсу.

  - **managedFields.time** (Time)

    Time — це часовий відбиток, коли був доданий запис ManagedFields. Час також буде оновлено, якщо додано поле, менеджер змінює будь-яке зі значень власних полів або видаляє поле. Відмітка часу не оновлюється, коли поле видаляється з запису через те, що його взяв на себе інший менеджер.

    <a name="Time"></a>
    *Time — це обгортка навколо time.Time, яка підтримує коректне перетворення у YAML та JSON. Для багатьох з функцій, які пропонує пакет time, надаються обгортки.*

  - **ownerReferences** ([]OwnerReference)

    *Patch strategy: обʼєднання за ключем `uid`*

    *Map: унікальні значення ключа uid будуть збережені під час злиття*

    Список обʼєктів, від яких залежить цей обʼєкт. Якщо ВСІ обʼєкти у списку були видалені, цей обʼєкт буде прибраний в процесі збирання сміття. Якщо цей обʼєкт керується контролером, то запис у цьому списку вказуватиме на цей контролер, із полем controller встановленим в true. Не може бути більше одного керуючого контролера.

    <a name="OwnerReference"></a>
    *OwnerReference містить достатньо інформації, щоб дозволити вам ідентифікувати власний обʼєкт. Власний обʼєкт повинен бути в тому ж просторі імен, що й залежний, або мати область видимості кластера, тому поля namespace немає.*

  - **ownerReferences.apiVersion** (string), обовʼязкове

    APIVersion визначає версію ресурсу, до якого відноситься цей обʼєкт.

  - **ownerReferences.kind** (string), обовʼязкове

    Kind визначає тип ресурсу, до якого відноситься цей обʼєкт. Докладніше: hhtps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds

  - **ownerReferences.name** (string), обовʼязкове

    Ім’я визначає ім’я ресурсу, до якого відноситься цей обʼєкт. Докладніше: hhtps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#names

  - **ownerReferences.uid** (string), обовʼязкове

    UID визначає унікальний ідентифікатор ресурсу, до якого відноситься цей обʼєкт. Докладніше: hhtps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#uids

  - **ownerReferences.blockOwnerDeletion** (boolean)

    Якщо true, І якщо у власника є pfdthoedfx "foregroundDeletion", то власника не можна видалити зі сховища ключ-значення, доки це посилання не буде видалено. Див. [https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion](/docs/concepts/architecture/garbage-collection/#foreground-deletion) щодо того, як збирач сміття взаємодіє з цим полем та застосовує явне видалення. стандартно — false. Щоб встановити це поле, користувачу потрібно мати дозвіл "delete" від власника, інакше буде повернуто 422 (Unprocessable Entity).

  - **ownerReferences.controller** (boolean)

    Якщо true, це посилання вказує на керуючий контролер.

### Read-only {#read-only}

- **creationTimestamp** (Time)

  CreationTimestamp — це відмітка часу, що представляє час сервера під час створення цього обʼєкта. Немає гарантії, що вона встановлена в порядку "відбулося перед" між окремими операціями. Клієнти не можуть встановлювати це значення. Використовується формат RFC3339 та знаходиться в часовому поясі UTC.

  Заповнюється системою. Тільки для читання. Null для списків. Додаткова інформація: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata

  <a name="Time"></a>
  *Time — це обгортка навколо time.Time, яка підтримує коректне перетворення у YAML та JSON. Для багатьох з функцій, які пропонує пакет time, надаються обгортки.*

- **deletionGracePeriodSeconds** (int64)

  Кількість секунд, які дозволяють цьому обʼєкту завершити роботу належним чином перед тим, як він буде видалений з системи. Встановлюється лише тоді, коли також встановлено deletionTimestamp. Може бути скорочено тільки в меншу сторону. Тільки для читання.

- **deletionTimestamp** (Time)

  Час видалення (DeletionTimestamp) — це дата та час у форматі RFC 3339, коли цей ресурс буде видалено. Це поле встановлюється сервером, коли користувач запитує належне видалення, і не може бути прямо встановлене клієнтом. Ресурс очікується бути видаленим (більше не видимий у списку ресурсів та недосяжний за іменем) після часу, вказаного у цьому полі, як тільки список завершувачів (finalizers) буде порожнім. Поки список завершувачів містить елементи, видалення заблоковане. Як тільки встановлюється час видалення, це значення не можна скасувати або встановити далі в майбутнє, хоча його можна скоротити або ресурс може бути видалений раніше цього часу. Наприклад, користувач може запросити видалення Podʼа через 30 секунд. Kubelet відреагує, надіславши сигнал належного завершення роботи контейнерам у Podʼі. Після цих 30 секунд Kubelet надішле сигнал примусового завершення (SIGKILL) контейнеру й після очищення видалить Pod з API. У випадку мережевих розділень цей обʼєкт може існувати після цієї позначки часу, доки адміністратор або автоматизований процес не визначить, що ресурс повністю завершив роботу. Якщо не встановлено, належне видалення обʼєкта не було запитано.

  Заповнюється системою, коли запитано належне видалення. Тільки для читання. Додаткова інформація: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata

  <a name="Time"></a>
  *Time — це обгортка навколо time.Time, яка підтримує коректне перетворення у YAML та JSON. Для багатьох з функцій, які пропонує пакет time, надаються обгортки.*

- **generation** (int64)

  Послідовний номер, що представляє конкретну генерацію бажаного стану. Заповнюється системою. Тільки для читання.

- **resourceVersion** (string)

  Непрозоре (opaque) значення, яке представляє внутрішню версію цього обʼєкта, яке може бути використано клієнтами для визначення змін в обʼєктах. Це може використовуватися для оптимістичного одночасного виконання, виявлення змін та операції спостереження над ресурсом або набором ресурсів. Клієнти повинні розглядати ці значення як непрозорі та передавати їх незмінними назад на сервер. Вони можуть бути дійсними тільки для певного ресурсу або набору ресурсів.

  Заповнюється системою. Тільки для читання. Значення повинно бути розглянуте клієнтами як непрозоре. Додаткова інформація: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency

- **selfLink** (string)

  Застаріле: selfLink — це застаріле поле, призначене лише для читання, яке більше не заповнюється системою.

- **uid** (string)

  UID є унікальним у часі та просторі значенням для цього об’єкта. Зазвичай він генерується сервером після успішного створення ресурсу, і його не можна змінювати під час операцій PUT.

  Заповнюється системою. Лише для читання. Додаткова інформація: [https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids](/docs/concepts/overview/working-with-objects/names#uids)
