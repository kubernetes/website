---
api_metadata:
  apiVersion: "resource.k8s.io/v1"
  import: "k8s.io/api/resource/v1"
  kind: "ResourceClaim"
content_type: "api_reference"
description: "ResourceClaim описує запит на доступ до ресурсів у кластері для використання робочими навантаженнями."
title: "ResourceClaim v1"
weight: 16
auto_generated: true
---

`apiVersion: resource.k8s.io/v1`

`import "k8s.io/api/resource/v1"`

## ResourceClaim {#ResourceClaim}

ResourceClaim описує запит на доступ до ресурсів у кластері, для використання робочими навантаженнями. Наприклад, якщо робоче навантаження потребує пристрою-акселератора з конкретними властивостями, ось як виражається цей запит. Розділ статусу відстежує, чи було задоволено цей запит і які саме ресурси були виділені.

Це альфа-тип і потребує увімкнення функціональної можливості DynamicResourceAllocation.

---

- **apiVersion**: resource.k8s.io/v1

- **kind**: ResourceClaim

- **metadata** (<a href="{{< ref "../common-definitions/object-meta#ObjectMeta" >}}">ObjectMeta</a>)

  Стандартні метадані обʼєкта

- **spec** (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaimSpec" >}}">ResourceClaimSpec</a>), обовʼязково

  Spec описує, що запитується і як це налаштувати. Специфікація є незмінною.

- **status** (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaimStatus" >}}">ResourceClaimStatus</a>)

  Status описує, чи заявка готова до використання і що було виділено.

## ResourceClaimSpec {#ResourceClaimSpec}

ResourceClaimSpec визначає, що запитується в ResourceClaim і як це налаштувати.

---

- **devices** (DeviceClaim)

  Devices визначає як запитувати пристрої.

  <a name="DeviceClaim"></a>
  *DeviceClaim визначає, як запитувати пристрої за допомогою ResourceClaim.*

  - **devices.config** ([]DeviceClaimConfiguration)

    *Atomic: буде замінено під час злиття*

    Це поле містить конфігурацію для декількох потенційних драйверів, які можуть задовольнити запити у цій заявці. Воно ігнорується під час призначення заявки.

    <a name="DeviceClaimConfiguration"></a>
    *DeviceClaimConfiguration використовується для параметрів конфігурації у DeviceClaim.*

    - **devices.config.opaque** (OpaqueDeviceConfiguration)

      Opaque надає специфічні для драйвера параметри конфігурації.

      <a name="OpaqueDeviceConfiguration"></a>
      *OpaqueDeviceConfiguration містить параметри конфігурації драйвера у форматі, визначеному постачальником драйвера.*

      - **devices.config.opaque.driver** (string), обовʼязково

        Драйвер використовується для визначення того, якому втулку kubelet потрібно передати ці конфігураційні параметри.

        Політика допуску, надана розробником драйвера, може використовувати цей параметр, щоб вирішити, чи потрібно їх перевіряти.

        Має бути субдоменом DNS і закінчуватися на DNS-домені, що належить постачальнику драйвера. Має складатись із символів нижнього регістру.

      - **devices.config.opaque.parameters** (RawExtension), обовʼязково

        Параметри можуть містити довільні дані. Відповідальність за перевірку та керування версіями покладається на розробника драйверів. Зазвичай це включає самоідентифікацію та версію ("kind" + "apiVersion" для типів Kubernetes), а також конвертацію між різними версіями.

        Довжина вихідних даних повинна бути меншою або дорівнювати 10 Ki.

        <a name="RawExtension"></a>
        *RawExtension використовується для зберігання розширень у зовнішніх версіях.*

        Щоб використовувати це, створіть поле, яке має тип RawExtension у вашій зовнішній, версійованій структурі, і Object у вашій внутрішній структурі. Також потрібно зареєструвати ваші різні типи втулків.

        // Внутрішній пакунок:

          ```go
        	type MyAPIObject struct {
        		runtime.TypeMeta `json:",inline"`
        		MyPlugin runtime.Object `json:"myPlugin"`
        	}

        	type PluginA struct {
        		AOption string `json:"aOption"`
        	}
          ```

        // Зовнішній пакунок:

          ```go
        	type MyAPIObject struct {
        		runtime.TypeMeta `json:",inline"`
        		MyPlugin runtime.RawExtension `json:"myPlugin"`
        	}

        	type PluginA struct {
        		AOption string `json:"aOption"`
        	}
          ```

        // Готовий JSON буде виглядати приблизно так:

          ```json
        	{
        		"kind":"MyAPIObject",
        		"apiVersion":"v1",
        		"myPlugin": {
        			"kind":"PluginA",
        			"aOption":"foo",
        		},
        	}
          ```

        Що відбувається? Спочатку декодування використовує json або yaml для десеріалізації даних у ваш зовнішній MyAPIObject. Це призводить до зберігання необробленого JSON, але без розпакування. Наступний крок — копіювання (за допомогою pkg/conversion) у внутрішню структуру. Функції перетворення, встановлені в DefaultScheme пакета runtime, розпаковують JSON, збережений у RawExtension, перетворюючи його в правильний тип обʼєкта і зберігаючи його в Object. (TODO: У випадку, коли обʼєкт має невідомий тип, буде створено і збережено обʼєкт runtime.Unknown.)

    - **devices.config.requests** ([]string)

      *Atomic: буде замінено під час злиття*

      Requests перераховує назви запитів, до яких застосовується конфігурація. Якщо поле порожнє, конфігурація застосовується до всіх запитів.

      Посилання на підзапити повинні містити назву основного запиту і можуть містити підзапит у форматі \<основний запит>[/\<підзапит>]. Якщо вказано лише головний запит, конфігурація застосовується до всіх підзапитів.

  - **devices.constraints** ([]DeviceConstraint)

    *Atomic: буде замінено під час злиття*

    Ці обмеження повинні задовольнятися набором пристроїв, які виділяються для заявки.

    <a name="DeviceConstraint"></a>
    *DeviceConstraint повинен мати рівно одне поле, крім Requests.*

    - **devices.constraints.distinctAttribute** (string)

      DistinctAttribute вимагає, щоб усі відповідні пристрої мали цей атрибут, а його тип і значення були унікальними для всіх цих пристроїв.

      Він діє як інверсія до MatchAttribute.

      Це обмеження використовується для уникнення розподілу декількох запитів на один і той самий пристрій шляхом забезпечення диференціації на рівні атрибутів.

      Це корисно для сценаріїв, де запити на ресурси повинні виконуватися окремими фізичними пристроями. Наприклад, контейнер запитує два мережеві інтерфейси, які повинні бути розподілені між двома різними фізичними мережевими картами.

    - **devices.constraints.matchAttribute** (string)

      MatchAttribute вимагає, щоб усі пристрої, про які йдеться, мали цей атрибуту, а його тип і значення були однаковими для всіх цих пристроїв.

      Наприклад, якщо ви вказали "dra.example.com/numa" (гіпотетичний приклад!), то будуть обрані лише пристрої в одному й тому самому NUMA-вузлі. Пристрій, який не має цього атрибуту, не буде обраний. Усі пристрої повинні використовувати значення одного типу для цього атрибуту, оскільки це є частиною його специфікації, але якщо якийсь пристрій цього не робить, він також не буде обраний.

      Має включати доменний кваліфікатор.

    - **devices.constraints.requests** ([]string)

      *Atomic: буде замінено під час злиття*

      Requests — це список з одного або більше запитів у цій заявці, які мають спільно задовольняти цю умову. Якщо запит виконується кількома пристроями, то всі пристрої повинні відповідати цій умові. Якщо це не вказано, ця умова застосовується до всіх запитів у заявці.

      Посилання на підзапити повинні містити назву основного запиту і можуть містити підзапит у форматі \<основний запит>[/\<підзапит>]. Якщо вказано лише головний запит, конфігурація застосовується до всіх підзапитів.

  - **devices.requests** ([]DeviceRequest)

    *Atomic: буде замінено під час злиття*

    Requests представляють індивідуальні запити на окремі пристрої, які мають бути задоволені. Якщо список порожній, то не потрібно виділяти жодних ресурсів.

    <a name="DeviceRequest"></a>
    *DeviceRequest — це запит на пристрої, необхідні для заявки. Зазвичай це запит на один ресурс, такий як пристрій, але також може включати запит на кілька однакових пристроїв. За допомогою FirstAvailable також можна створити пріоритетний список запитів.*

    - **devices.requests.name** (string), обовʼязково

      Імʼя можна використовувати для посилання на цей запит у записі pod.spec.containers[].resources.claims та в обмеженні заявки.

      Посилання з використанням імені у DeviceRequest однозначно ідентифікують запит, якщо встановлено поле Exactly. Коли встановлено поле FirstAvailable, посилання на імʼя DeviceRequest буде відповідати будь-якому підзапиту, вибраному планувальником.

      Повинна бути мітка DNS.

    - **devices.requests.exactly** (ExactDeviceRequest)

      Exactly вказує деталі для одного запиту, які повинні бути точно виконані для того, щоб запит був задоволений.

      Має бути задано одне зі значень Exactly або FirstAvailable.

      <a name="ExactDeviceRequest"></a>
      *ExactDeviceRequest — це запит на один або декілька ідентичних пристроїв.*

      - **devices.requests.exactly.deviceClassName** (string), обовʼязково

        DeviceClassName посилається на конкретний DeviceClass, який може визначати додаткові налаштування та селектори, що будуть успадковані цим запитом.

        DeviceClassName є обов’язковим.

        Адміністратори можуть використовувати це, щоб обмежити доступні для запитів пристрої, встановлюючи класи лише з селекторами для дозволених пристроїв. Якщо користувачі можуть вільно запитувати будь-що без обмежень, адміністратори можуть створити порожній DeviceClass для використання користувачами.

      - **devices.requests.exactly.adminAccess** (boolean)

        AdminAccess вказує, що це заявка на адміністративний доступ до пристрою(їв). Заявки з AdminAccess очікується використовувати для моніторингу або інших сервісів управління пристроєм. Вони ігнорують усі звичайні заявки на пристрій щодо режимів доступу та будь-яких розподілів ресурсів.

        Це альфа-поле і вимагає увімкнення функціональної можливості DRAAdminAccess. Доступ адміністратора вимкнено, якщо це поле не встановлено або встановлено на false, інакше його увімкнено.

      - **devices.requests.exactly.allocationMode** (string)

        AllocationMode та пов’язані з ним поля визначають, як пристрої виділяються для виконання цього запиту. Підтримувані значення:

        - ExactCount: Цей запит на конкретну кількість пристроїв. Це значення використовується стандартно. Точна кількість вказується в полі `count`.

        - All: Цей запит на всі пристрої, що відповідають умовам, у пулі. Для успішного розподілу на вузлі має існувати принаймні один пристрій. Виділення не вдасться, якщо деякі пристрої вже виділені, за винятком випадків, коли запитується adminAccess.

        Якщо AllocationMode не вказано, стандатний режим — ExactCount. Якщо режим — ExactCount і кількість не вказана, стандартна кількість один. Будь-які інші запити повинні вказати це поле.

        Можуть бути додані нові режими в майбутньому. Клієнти повинні відмовитися від обробки запитів із невідомими режимами.

        Можливі значення переліку:
        - `"All"`
        - `"ExactCount"`

      - **devices.requests.exactly.capacity** (CapacityRequirements)

        Capacity визначає вимоги до ресурсів для кожної ємності.

        Якщо це поле не встановлено і пристрій підтримує кілька розподілів, до кожної ємності буде застосовано стандартне значення відповідно до requestPolicy. Для ємності, яка не має requestPolicy, стандартним значенням є повна ємність.

        Застосовується до кожного розподілу пристрою. Якщо Count > 1, запит не буде виконано, якщо немає достатньої кількості пристроїв, що відповідають вимогам. Якщо AllocationMode встановлено на All, запит не буде виконано, якщо є пристрої, які відповідають вимогам, але не відповідають вимогам запиту.

        <a name="CapacityRequirements"></a>
        *CapacityRequirements визначає вимоги до емності для конкретного запиту на пристрій.*

        - **devices.requests.exactly.capacity.requests** (map[string]<a href="{{< ref "../common-definitions/quantity#Quantity" >}}">Quantity</a>)

          Requests представляють собою індивідуальні запити пристрою на окремі ресурси, які повинні бути надані пристроєм.

          Це значення використовується як додаткова умова фільтрації щодо доступної ємності на пристрої. Семантично це еквівалентно селектору CEL з `device.capacity[\<domain>].\<name>.compareTo(quantity(\<request quantity>)) >= 0`. Наприклад, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0.

          Коли визначено requestPolicy, запитувана кількість коригується в бік збільшення до найближчого допустимого значення на основі політики. Якщо запитувана кількість не може бути скоригована до допустимого значення, оскільки перевищує дозволене requestPolicy, пристрій вважається непридатним для розподілу.

          Для будь-якої ємності, яка не була явно запрошена:
          - Якщо requestPolicy не встановлено, використовується стандартне значення (тобто затребувано все обладнання).
          - Якщо requestPolicy встановлено, використовувана стандартна ємність визначається відповідно до цієї політики.

          Якщо пристрій дозволяє багаторазове виділення, сукупна сума за всіма запитами не повинна перевищувати значення ємності. Спожита ємність, яка може бути скоригована на основі requestPolicy, якщо вона визначена, записується в полі `status.devices[*].consumedCapacity` запиту ресурсів.

      - **devices.requests.exactly.count** (int64)

        Поле Count використовується лише тоді, коли режим підрахунку — "ExactCount". Має бути більше нуля. Якщо AllocationMode встановлено як ExactCount і це поле не вказано, стандартне значення — один.

      - **devices.requests.exactly.selectors** ([]DeviceSelector)

        *Atomic: буде замінено під час злиття*

        Селектори визначають критерії, які має задовольнити конкретний пристрій, щоб він був розглянутий для цього запиту. Усі селектори повинні бути виконані, щоб пристрій був прийнятий до розгляду.

        <a name="DeviceSelector"></a>
        *DeviceSelector повинен мати рівно одне встановлене поле.*

        - **devices.requests.exactly.selectors.cel** (CELDeviceSelector)

          CEL містить вираз CEL для вибору пристрою.

          <a name="CELDeviceSelector"></a>
          *CELDeviceSelector містить CEL-вираз для вибору пристрою.*

          - **devices.requests.exactly.selectors.cel.expression** (string), обовʼязково

            Вираз є виразом CEL, який оцінює один пристрій. Він має оцінюватися як true, коли пристрій відповідає бажаним критеріям, і як false, коли не відповідає. Будь-який інший результат є помилкою і призводить до зупинки надання пристроїв.

            Вхідні дані виразу — це обʼєкт з назвою "device", який має наступні властивості:
            - driver (рядок): імʼя драйвера, який визначає цей пристрій.
            - attributes (map[string]object): атрибути пристрою, згруповані за префіксом (наприклад, device.attributes["dra.example.com"] оцінюється як обʼєкт з усіма атрибутами, які були префіксовані "dra.example.com").
            - capacity (map[string]object): обсяги пристрою, згруповані за префіксом.
            - allowMultipleAllocations (bool): властивість allowMultipleAllocations пристрою (v1.34+ з увімкненою функцією DRAConsumableCapacity).

            Приклад: Розглянемо пристрій з driver="dra.example.com", який надає два атрибути з назвою "model" та "ext.example.com/family" і один обсяг з назвою "modules". Вхідні дані для цього виразу будуть мати такі поля:

            ```none
            device.driver
            device.attributes["dra.example.com"].model
            device.attributes["ext.example.com"].family
            device.capacity["dra.example.com"].modules
            ```

            Поле device.driver можна використовувати для перевірки конкретного драйвера, або як загальну попередню умову (тобто ви хочете розглядати лише пристрої від цього драйвера), або як частину виразу з кількома умовами, який призначений для розгляду пристроїв з різних драйверів.

            Тип значення кожного атрибута визначається визначенням пристрою, і користувачі, які пишуть ці вирази, повинні звертатися до документації для своїх конкретних драйверів. Тип значення кожного обсягу — Quantity.

            Якщо невідомий префікс використовується для запиту в device.attributes або device.capacity, буде повернено порожній map. Будь-яке посилання на невідоме поле спричинить помилку оцінки і зупинку виділення.

            Робочий вираз має перевіряти наявність атрибутів перед їх використанням.

            Для зручності використання доступна функція cel.bind(), яка може бути використана для спрощення виразів, що звертаються до кількох атрибутів з одного домену. Наприклад:

            ```none
            cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
            ```

            Довжина виразу повинна бути меншою або дорівнювати 10 Ki. Вартість його обчислення також обмежена на основі передбачуваної кількості логічних кроків.

      - **devices.requests.exactly.tolerations** ([]DeviceToleration)

        *Atomic: буде замінено під час злиття*

        Якщо вказано, допуски запиту.

        Допуски для NoSchedule необхідні для виділення пристрою, який має цей ефект. Те саме стосується і NoExecute.

        Крім того, якщо будь-який з виділених пристроїв буде позначено taint NoExecute після розподілу, і цей ефект не буде допущено, то всі podʼи, що споживають ResourceClaim, буде видалено, щоб виселити їх. Планувальник не дозволить новим podʼам зарезервувати заявку на ресурс, доки у нього є ці позначені taint пристрої. Після того, як всі podʼи будуть виселені, заявка буде перерозподілена.

        Максимальна кількість допусків - 16.

        Це альфа-поле і вимагає увімкнення воріт функції DRADeviceTaints.

        <a name="DeviceToleration"></a>
        *ResourceClaim, до якого прикріплено DeviceToleration, допускає будь-яке позначення taint, що відповідає трійці \<ключ,значення,ефект>, використовуючи оператор узгодження \<оператор>.*

        - **devices.requests.exactly.tolerations.effect** (string)

          Effect вказує на ефект taint, який має мати збіг. Порожнє значення означає відповідність усім ефектам taint. Якщо вказано, допустимими значеннями є NoSchedule та NoExecute.

          Можливі значення переліку (enum):
          - `"NoExecute"` Виселяти всі вже запущені podʼи, які не толерантні до taint.
          - `"NoSchedule"` Не дозволяти новим podʼам планувати використання tainted пристроїв, якщо вони не толерантні до taint, але дозволяти всім podʼам, надісланим до Kubelet без проходження через планувальник, запускатися, і дозволяти всім вже запущеним podʼам продовжувати працювати.
          - `"None"` Немає ефекту, позначення taint є суто інформаційним.

        - **devices.requests.exactly.tolerations.key** (string)

          Key є ключем taint, до якого застосовується толерантність. Порожній означає збіг з усіма ключами. Якщо ключ порожній, оператор повинен мати значення Exists; ця комбінація означає збіг всіх значень і всіх ключів. Має бути імʼя мітки.

        - **devices.requests.exactly.tolerations.operator** (string)

          Operator представляє відношення ключа до значення. Допустимими операторами є Exists та Equal. Стандартно використовується Equal. Exists еквівалентний символу підстановки для значення, так що запит на ресурс може толерантно ставитися до всіх taint певної категорії.

          Можливі значення переліку (enum):
          - `"Equal"`
          - `"Exists"`

        - **devices.requests.exactly.tolerations.tolerationSeconds** (int64)

          TolerationSeconds представляє період часу, протягом якого толерантність (яка повинна мати ефект NoExecute, інакше це поле ігнорується) буде толерувати taint. Стандартно це значення не задано, що означає, що толерантність буде зберігатися вічно (не виселяти). Нульові та відʼємні значення будуть розглядатися системою як 0 (виселити негайно). Якщо значення більше нуля, то час, коли pod потрібно виселити, обчислюється як \<час, коли було додано taint> + \<секунди толерантності>.

        - **devices.requests.exactly.tolerations.value** (string)

          Value є значенням taint, якому відповідає толерантність. Якщо оператор має значення Exists, значення має бути порожнім, інакше — звичайним рядком. Має бути значенням мітки.

    - **devices.requests.firstAvailable** ([]DeviceSubRequest)

      *Atomic: буде замінено під час злиття*

      FirstAvailable містить підзапити, з яких планувальник вибере саме один. Він намагається задовольнити їх у тому порядку, в якому вони перераховані. Отже, якщо в списку є два записи, планувальник перевірить тільки другий, якщо визначить, що перший не може бути використаний.

      DRA ще не впроваджує бальну оцінку, тому планувальник вибере перший набір пристроїв, який задовольняє всі вимоги в заявці. І якщо вимоги можуть бути задоволені на більш ніж одному вузлі, інші функції планування визначать, який вузол буде обрано. Це означає, що набір пристроїв, виділених для вимоги, може не бути оптимальним набором, доступним для кластера. Оцінювання буде реалізовано пізніше.

      <a name="DeviceSubRequest"></a>
      *DeviceSubRequest описує запит на пристрій, наданий у масиві claim.spec.devices.requests[].firstAvailable. Кожен з них, як правило, є запитом на один ресурс, наприклад, пристрій, але також може запитувати декілька ідентичних пристроїв.*

      *DeviceSubRequest схожий на ExactDeviceRequest, але не розкриває поле AdminAccess, оскільки воно підтримується лише при запиті конкретного пристрою.*

      - **devices.requests.firstAvailable.deviceClassName** (string), обовʼязково

        DeviceClassName посилається на конкретний DeviceClass, який може визначати додаткові налаштування та селектори, що будуть успадковані цим запитом.

        DeviceClassName є обов’язковим. Які саме класи доступні, залежить від кластера.

        Адміністратори можуть використовувати це, щоб обмежити доступні для запитів пристрої, встановлюючи класи лише з селекторами для дозволених пристроїв. Якщо користувачі можуть вільно запитувати будь-що без обмежень, адміністратори можуть створити порожній DeviceClass для використання користувачами.

      - **devices.requests.firstAvailable.name** (string), обовʼязково

        Name можна використовувати для посилання на цей підзапит у списку обмежень або списку конфігурацій для вимоги. Посилання повинні мати формат \<головний запит>/\<підзапит>.

        Має бути міткою DNS.

      - **devices.requests.firstAvailable.allocationMode** (string)

        AllocationMode та пов’язані з ним поля визначають, як пристрої виділяються для виконання цього запиту. Підтримувані значення:

        - ExactCount: Цей запит на конкретну кількість пристроїв. Це значення використовується стандартно. Точна кількість вказується в полі `count`.

        - All: Цей запит на всі пристрої, що відповідають умовам, у пулі. Виділення не вдасться, якщо деякі пристрої вже виділені, за винятком випадків, коли запитується adminAccess.

        Якщо AllocationMode не вказано, стандатний режим — ExactCount. Якщо режим — ExactCount і кількість не вказана, стандартна кількість один. Будь-які інші запити повинні вказати це поле.

        Можуть бути додані нові режими в майбутньому. Клієнти повинні відмовитися від обробки запитів із невідомими режимами.

        Можливі значення переліку:
        - `"All"`
        - `"ExactCount"`

      - **devices.requests.firstAvailable.capacity** (CapacityRequirements)

        Capacity визначає вимоги до ресурсів для кожної ємності.

        Якщо це поле не встановлено і пристрій підтримує кілька розподілів, до кожної ємності буде застосовано стандартне значення відповідно до requestPolicy. Для ємності, яка не має requestPolicy, стандартним значенням є повна ємність.

        Застосовується до кожного розподілу пристроїв. Якщо Count > 1, запит не буде виконано, якщо не буде достатньо пристроїв, що відповідають вимогам. Якщо AllocationMode встановлено на All, запит не буде виконано, якщо є пристрої, які відповідають запиту та мають таку ємність із значенням >= запитуваної кількості, але які не можуть бути розподілені для цього запиту.

        <a name="CapacityRequirements"></a>
        *CapacityRequirements визначає вимоги до ємності для конкретного запиту на пристрій.*

        - **devices.requests.firstAvailable.capacity.requests** (map[string]<a href="{{< ref "../common-definitions/quantity#Quantity" >}}">Quantity</a>)

          Requests представляють собою індивідуальні запити пристрою на окремі ресурси, які повинні бути надані пристроєм.

          Це значення використовується як додаткова умова фільтрації щодо доступної ємності на пристрої. Семантично це еквівалентно селектору CEL з `device.capacity[\<domain>].\<name>.compareTo(quantity(\<request quantity>)) >= 0`. Наприклад, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0.

          Коли визначено requestPolicy, запитувана кількість коригується в бік збільшення до найближчого допустимого значення на основі політики. Якщо запитувана кількість не може бути скоригована до допустимого значення, оскільки перевищує дозволене requestPolicy, пристрій вважається непридатним для розподілу.

          Для будь-якої ємності, яка не була явно запрошена:
          - Якщо requestPolicy не встановлено, використовується стандартне значення (тобто затребувано все обладнання).
          - Якщо requestPolicy встановлено, використовувана стандартна ємність визначається відповідно до цієї політики.

          Якщо пристрій дозволяє багаторазове виділення, сукупна сума за всіма запитами не повинна перевищувати значення ємності. Спожита ємність, яка може бути скоригована на основі requestPolicy, якщо вона визначена, записується в полі `status.devices[*].consumedCapacity` запиту ресурсів.

      - **devices.requests.firstAvailable.count** (int64)

        Поле Count використовується лише тоді, коли режим підрахунку — "ExactCount". Має бути більше нуля. Якщо AllocationMode встановлено як ExactCount і це поле не вказано, стандартне значення — один.

      - **devices.requests.firstAvailable.selectors** ([]DeviceSelector)

        *Atomic: буде замінено під час злиття*

        Селектори визначають критерії, які має задовольнити конкретний пристрій, щоб він був розглянутий для цього запиту. Усі селектори повинні бути виконані, щоб пристрій був прийнятий до розгляду.

        <a name="DeviceSelector"></a>
        *DeviceSelector повинен мати рівно одне встановлене поле.*

        - **devices.requests.firstAvailable.selectors.cel** (CELDeviceSelector)

          CCEL містить вираз CEL для вибору пристрою.

          <a name="CELDeviceSelector"></a>
          *CELDeviceSelector містить CEL-вираз для вибору пристрою.*

          - **devices.requests.firstAvailable.selectors.cel.expression** (string), обовʼязково

            Вираз є виразом CEL, який оцінює один пристрій. Він має оцінюватися як true, коли пристрій відповідає бажаним критеріям, і як false, коли не відповідає. Будь-який інший результат є помилкою і призводить до зупинки надання пристроїв.

            Вхідні дані виразу — це обʼєкт з назвою "device", який має наступні властивості:
            - driver (рядок): імʼя драйвера, який визначає цей пристрій.
            - attributes (map[string]object): атрибути пристрою, згруповані за префіксом (наприклад, device.attributes["dra.example.com"] оцінюється як обʼєкт з усіма атрибутами, які були префіксовані "dra.example.com").
            - capacity (map[string]object): обсяги пристрою, згруповані за префіксом.
            - allowMultipleAllocations (bool): властивість allowMultipleAllocations пристрою (v1.34+ з увімкненою функцією DRAConsumableCapacity).

            Приклад: Розглянемо пристрій з driver="dra.example.com", який надає два атрибути з назвою "model" та "ext.example.com/family" і один обсяг з назвою "modules". Вхідні дані для цього виразу будуть мати такі поля:

            ```none
            device.driver
            device.attributes["dra.example.com"].model
            device.attributes["ext.example.com"].family
            device.capacity["dra.example.com"].modules
            ```

            Поле device.driver можна використовувати для перевірки конкретного драйвера, або як загальну попередню умову (тобто ви хочете розглядати лише пристрої від цього драйвера), або як частину виразу з кількома умовами, який призначений для розгляду пристроїв з різних драйверів.

            Тип значення кожного атрибута визначається визначенням пристрою, і користувачі, які пишуть ці вирази, повинні звертатися до документації для своїх конкретних драйверів. Тип значення кожного обсягу — Quantity.

            Якщо невідомий префікс використовується для запиту в device.attributes або device.capacity, буде повернено порожній map. Будь-яке посилання на невідоме поле спричинить помилку оцінки і зупинку виділення.

            Робочий вираз має перевіряти наявність атрибутів перед їх використанням.

            Для зручності використання доступна функція cel.bind(), яка може бути використана для спрощення виразів, що звертаються до кількох атрибутів з одного домену. Наприклад:

            ```none
            cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
            ```

            Довжина виразу повинна бути меншою або дорівнювати 10 Ki. Вартість його обчислення також обмежена на основі передбачуваної кількості логічних кроків.

      - **devices.requests.firstAvailable.tolerations** ([]DeviceToleration)

        *Atomic: буде замінено під час злиття*

        Якщо вказано, допуски запиту.

        Допуски для NoSchedule необхідні для виділення пристрою, який має цей ефект. Те саме стосується і NoExecute.

        Крім того, якщо будь-який з виділених пристроїв буде позначено taint NoExecute після розподілу, і цей ефект не буде допущено, то всі podʼи, що споживають ResourceClaim, буде видалено, щоб виселити їх. Планувальник не дозволить новим podʼам зарезервувати заявку на ресурс, доки у нього є ці позначені taint пристрої. Після того, як всі podʼи будуть виселені, заявка буде перерозподілена.

        Максимальна кількість допусків - 16.

        Це альфа-поле і вимагає увімкнення воріт функції DRADeviceTaints.

        <a name="DeviceToleration"></a>
        *ResourceClaim, до якого прикріплено DeviceToleration, допускає будь-яке позначення taint, що відповідає трійці \<ключ,значення,ефект>, використовуючи оператор узгодження \<оператор>.*

        - **devices.requests.firstAvailable.tolerations.effect** (string)

          Effect вказує на ефект taint, який має мати збіг. Порожнє значення означає відповідність усім ефектам taint. Якщо вказано, допустимими значеннями є NoSchedule та NoExecute.

          Можливі значення переліку (enum):
          - `"NoExecute"` Виселяти всі вже запущені podʼи, які не толерантні до taint.
          - `"NoSchedule"` Не дозволяти новим podʼам планувати використання tainted пристроїв, якщо вони не толерантні до taint, але дозволяти всім podʼам, надісланим до Kubelet без проходження через планувальник, запускатися, і дозволяти всім вже запущеним podʼам продовжувати працювати.
          - `"None"` Немає ефекту, позначення taint є суто інформаційним.

        - **devices.requests.firstAvailable.tolerations.key** (string)

          Key є ключем taint, до якого застосовується толерантність. Порожній означає збіг з усіма ключами. Якщо ключ порожній, оператор повинен мати значення Exists; ця комбінація означає збіг всіх значень і всіх ключів. Має бути імʼя мітки.

        - **devices.requests.firstAvailable.tolerations.operator** (string)

          Operator представляє відношення ключа до значення. Допустимими операторами є Exists та Equal. Стандартно використовується Equal. Exists еквівалентний символу підстановки для значення, так що запит на ресурс може толерантно ставитися до всіх taint певної категорії.

          Можливі значення переліку (enum):
          - `"Equal"`
          - `"Exists"`

        - **devices.requests.firstAvailable.tolerations.tolerationSeconds** (int64)

          TolerationSeconds представляє період часу, протягом якого толерантність (яка повинна мати ефект NoExecute, інакше це поле ігнорується) буде толерувати taint. Стандартно це значення не задано, що означає, що толерантність буде зберігатися вічно (не виселяти). Нульові та відʼємні значення будуть розглядатися системою як 0 (виселити негайно). Якщо значення більше нуля, то час, коли pod потрібно виселити, обчислюється як \<час, коли було додано taint> + \<секунди толерантності>.

        - **devices.requests.firstAvailable.tolerations.value** (string)

          Value є значенням taint, якому відповідає толерантність. Якщо оператор має значення Exists, значення має бути порожнім, інакше — звичайним рядком. Має бути значенням мітки.

## ResourceClaimStatus {#ResourceClaimStatus}

ResourceClaimStatus відстежує, чи було виділено ресурс і яким був результат.

---

- **allocation** (AllocationResult)

  Allocation встановлюється після успішного розподілу заявки.

  <a name="AllocationResult"></a>
  *AllocationResult містить атрибути виділеного ресурсу.*

  - **allocation.allocationTimestamp** (Time)

    AllocationTimestamp зберігає час, коли були виділені ресурси. Не гарантується, що це поле буде встановлено, і в цьому випадку час невідомий.

    Це поле альфа-версії, і для його використання необхідно ввімкнути функціональні можливості DRADeviceBindingConditions та DRAResourceClaimDeviceStatus.

    <a name="Time"></a>
    *Time — це обгортка навколо time.Time, яка підтримує коректне перетворення у YAML та JSON. Для багатьох з функцій, які пропонує пакет time, надаються обгортки.*

  - **allocation.devices** (DeviceAllocationResult)

    Devices є результатом виділення пристроїів.

    <a name="DeviceAllocationResult"></a>
    *DeviceAllocationResult — результат виділення пристроїв.*

    - **allocation.devices.config** ([]DeviceAllocationConfiguration)

      *Atomic: буде замінено під час злиття*

      Це поле є комбінацією всіх параметрів конфігурації заявки та класу. Драйвери можуть розрізняти ці параметри за допомогою прапорця.

      Воно включає параметри конфігурації для драйверів, які не мають виділених пристроїв у результаті, оскільки драйвери самостійно визначають, які параметри конфігурації вони підтримують. Вони можуть мовчки ігнорувати невідомі параметри конфігурації.

      <a name="DeviceAllocationConfiguration"></a>
      *DeviceAllocationConfiguration gets embedded in an AllocationResult.*

      - **allocation.devices.config.source** (string), обовʼязково

        Source вказує, чи конфігурація походить з класу і, отже, не є чимось, що звичайний користувач міг би встановити, чи з заявки.

        Можливі значення переліку:
        - `"FromClaim"`
        - `"FromClass"`

      - **allocation.devices.config.opaque** (OpaqueDeviceConfiguration)

        Opaque надає специфічні для драйвера параметри конфігурації.

        <a name="OpaqueDeviceConfiguration"></a>
        *OpaqueDeviceConfiguration містить параметри конфігурації драйвера у форматі, визначеному постачальником драйвера.*

        - **allocation.devices.config.opaque.driver** (string), обовʼязково

          Драйвер використовується для визначення того, якому втулку kubelet потрібно передати ці конфігураційні параметри.

          Політика допуску, надана розробником драйвера, може використовувати цей параметр, щоб вирішити, чи потрібно їх перевіряти.

          Має бути субдоменом DNS і закінчуватися на DNS-домені, що належить постачальнику драйвера. Має складатись із смволів нижнього регістру.

        - **allocation.devices.config.opaque.parameters** (RawExtension), обовʼязково

          Параметри можуть містити довільні дані. Відповідальність за перевірку та керування версіями покладається на розробника драйверів. Зазвичай це включає самоідентифікацію та версію ("kind" + "apiVersion" для типів Kubernetes), а також конвертацію між різними версіями.

          Довжина вихідних даних повинна бути меншою або дорівнювати 10 Ki.

          <a name="RawExtension"></a>
          *RawExtension використовується для зберігання розширень у зовнішніх версіях.*

          Щоб використовувати це, створіть поле, яке має тип RawExtension у вашій зовнішній, версійованій структурі, і Object у вашій внутрішній структурі. Також потрібно зареєструвати ваші різні типи втулків.

          // Внутрішній пакунок:

            ```go
          	type MyAPIObject struct {
          		runtime.TypeMeta `json:",inline"`
          		MyPlugin runtime.Object `json:"myPlugin"`
          	}

          	type PluginA struct {
          		AOption string `json:"aOption"`
          	}
            ```

          // Зовнішній пакунок:

            ```go
          	type MyAPIObject struct {
          		runtime.TypeMeta `json:",inline"`
          		MyPlugin runtime.RawExtension `json:"myPlugin"`
          	}

          	type PluginA struct {
          		AOption string `json:"aOption"`
          	}
            ```

          // Готовий JSON буде виглядати приблизно так:

            ```json
          	{
          		"kind":"MyAPIObject",
          		"apiVersion":"v1",
          		"myPlugin": {
          			"kind":"PluginA",
          			"aOption":"foo",
          		},
          	}
            ```

          Що відбувається? Спочатку декодування використовує json або yaml для десеріалізації даних у ваш зовнішній MyAPIObject. Це призводить до зберігання необробленого JSON, але без розпакування. Наступний крок — копіювання (за допомогою pkg/conversion) у внутрішню структуру. Функції перетворення, встановлені в DefaultScheme пакета runtime, розпаковують JSON, збережений у RawExtension, перетворюючи його в правильний тип обʼєкта і зберігаючи його в Object. (TODO: У випадку, коли обʼєкт має невідомий тип, буде створено і збережено обʼєкт runtime.Unknown.)

      - **allocation.devices.config.requests** ([]string)

        *Atomic: буде замінено під час злиття*

        Requests перераховує назви запитів, до яких застосовується конфігурація. Якщо поле порожнє, конфігурація застосовується до всіх запитів.

        Посилання на підзапити повинні містити назву основного запиту і можуть містити підзапит у форматі \<основний запит>[/\<підзапит>]. Якщо вказано лише головний запит, конфігурація застосовується до всіх підзапитів.

    - **allocation.devices.results** ([]DeviceRequestAllocationResult)

      *Atomic: буде замінено під час злиття*

      Results — перелік віділених пристроїв.

      <a name="DeviceRequestAllocationResult"></a>
      *DeviceRequestAllocationResult містить результат розподілу для одного запиту.*

      - **allocation.devices.results.device** (string), обовʼязково

        Device посилається на один екземпляр пристрою за його імʼям в ресурсному пулі драйвера. Має бути міткою DNS.

      - **allocation.devices.results.driver** (string), обовʼязково

        Driver вказує імʼя драйвера DRA, чий втулок kubelet слід викликати для обробки виділення, коли заявка потрібна на вузлі.

        Має бути піддоменом DNS і закінчуватися доменом DNS, що належить постачальнику драйвера.

        Має складатись із смволів нижнього регістру.

      - **allocation.devices.results.pool** (string), обовʼязково

        Це імʼя разом з імʼям драйвера та полем імені пристрою ідентифікує, який пристрій був виділений (`\<імʼя драйвера>/\<імʼя пулу>/\<імʼя пристрою>`).

        Не повинно перевищувати 253 символи і може містити один або більше піддоменів DNS, розділених косими рисками.

      - **allocation.devices.results.request** (string), обовʼязково

        Request — це імʼя запиту в заявці, який спричинив виділення цього пристрою. Якщо він посилається на підзапит у списку firstAvailable у DeviceRequest, це поле має містити назву основного запиту і підзапиту у форматі \<основний запит>/\<підзапит>.

        Для одного запиту може бути призначено декілька пристроїв.

      - **allocation.devices.results.adminAccess** (boolean)

        AdminAccess вказує на те, що цей пристрій призначено для адміністративного доступу. Визначення режиму див. у відповідному полі запиту.

        Це поле є альфа-полем і вимагає увімкнення функціональної можливості DRAAdminAccess. Доступ адміністратора вимкнено, якщо це поле не встановлено або встановлено на false, інакше його увімкнено.

      - **allocation.devices.results.bindingConditions** ([]string)

        *Atomic: буде замінено під час злиття*

        BindingConditions містить копію BindingConditions з відповідного ResourceSlice на момент розподілу.

        Це поле альфа-версії, для якого необхідно ввімкнути функціональні можливості DRADeviceBindingConditions та DRAResourceClaimDeviceStatus.

      - **allocation.devices.results.bindingFailureConditions** ([]string)

        *Atomic: буде замінено під час злиття*

        BindingFailureConditions містить копію BindingFailureConditions з відповідного ResourceSlice на момент розподілу.

        Це поле альфа-версії, для якого необхідно ввімкнути функціональні можливості DRADeviceBindingConditions та DRAResourceClaimDeviceStatus.

      - **allocation.devices.results.consumedCapacity** (map[string]<a href="{{< ref "../common-definitions/quantity#Quantity" >}}">Quantity</a>)

        ConsumedCapacity відстежує обсяг спожитої ємності на кожному пристрої у рамках запиту на заявку. Спожитий обсяг може відрізнятися від запитуваного обсягу: він округлюється до найближчого дійсного значення на основі requestPolicy пристрою, якщо це застосовно (тобто не може бути меншим за запитуваний обсяг).

        Загальна спожита ємність для кожного пристрою не повинна перевищувати значення DeviceCapacity.

        Це поле заповнюється тільки для пристроїв, які дозволяють кілька розподілів. Включаються всі записи про ємність, навіть якщо спожита кількість дорівнює нулю.

      - **allocation.devices.results.shareID** (string)

        ShareID однозначно ідентифікує індивідуальну частку розподілу пристрою, яка використовується, коли пристрій підтримує кілька одночасних розподілів. Він служить додатковим  map key для розрізнення одночасних часток одного і того ж пристрою.

      - **allocation.devices.results.tolerations** ([]DeviceToleration)

        *Atomic: буде замінено під час злиття*

        Копія всіх допусків, зазначених у запиті на момент виділення пристрою.

        Максимальна кількість допусків - 16.

        Це альфа-поле і вимагає увімкнення функціональної можливості DRADeviceTaints.

        <a name="DeviceToleration"></a>
        *ResourceClaim, до якого прикріплено DeviceToleration, допускає будь-яке позначення taint, що відповідає трійці \<ключ,значення,ефект>, використовуючи оператор узгодження \<оператор>.*

        - **allocation.devices.results.tolerations.effect** (string)

          Effect вказує на ефект taint, який має мати збіг. Порожнє значення означає відповідність усім ефектам taint. Якщо вказано, допустимими значеннями є NoSchedule та NoExecute.

          Можливі значення переліку (enum):
          - `"NoExecute"` Виселяти всі вже запущені podʼи, які не толерантні до taint.
          - `"NoSchedule"` Не дозволяти новим podʼам планувати використання tainted пристроїв, якщо вони не толерантні до taint, але дозволяти всім podʼам, надісланим до Kubelet без проходження через планувальник, запускатися, і дозволяти всім вже запущеним podʼам продовжувати працювати.
          - `"None"` Немає ефекту, позначення taint є суто інформаційним.

        - **allocation.devices.results.tolerations.key** (string)

          Key є ключем taint, до якого застосовується толерантність. Порожній означає збіг з усіма ключами. Якщо ключ порожній, оператор повинен мати значення Exists; ця комбінація означає збіг всіх значень і всіх ключів. Має бути імʼя мітки.

        - **allocation.devices.results.tolerations.operator** (string)

          Operator представляє відношення ключа до значення. Допустимими операторами є Exists та Equal. Стандартно використовується Equal. Exists еквівалентний символу підстановки для значення, так що запит на ресурс може толерантно ставитися до всіх taint певної категорії.

          Можливі значення переліку (enum):
          - `"Equal"`
          - `"Exists"`

        - **allocation.devices.results.tolerations.tolerationSeconds** (int64)

          TolerationSeconds представляє період часу, протягом якого толерантність (яка повинна мати ефект NoExecute, інакше це поле ігнорується) буде толерувати taint. Стандартно це значення не задано, що означає, що толерантність буде зберігатися вічно (не виселяти). Нульові та відʼємні значення будуть розглядатися системою як 0 (виселити негайно). Якщо значення більше нуля, то час, коли pod потрібно виселити, обчислюється як \<час, коли було додано taint> + \<секунди толерантності>.

        - **allocation.devices.results.tolerations.value** (string)

          Value є значенням taint, якому відповідає толерантність. Якщо оператор має значення Exists, значення має бути порожнім, інакше — звичайним рядком. Має бути значенням мітки.

  - **allocation.nodeSelector** (NodeSelector)

    NodeSelector визначає, де доступні виділені ресурси. Якщо не встановлено, ресурси доступні скрізь.

    <a name="NodeSelector"></a>
    *Селектор вузлів представляє об'єднання результатів одного або кількох запитів міток над набором вузлів; тобто, він представляє логічне OR селекторів, які представлені термінами селектора вузлів.*

    - **allocation.nodeSelector.nodeSelectorTerms** ([]NodeSelectorTerm), обовʼязково

      *Atomic: буде замінено під час злиття*

      Обов’язкове поле. Список термінів селектора вузлів. Термінів застосовується логічне OR.

      <a name="NodeSelectorTerm"></a>
      *Null або порожній термін селектора вузла не відповідає жодному об'єкту. Вимоги до них складаються за принципом AND. Тип TopologySelectorTerm реалізує підмножину NodeSelectorTerm.*

      - **allocation.nodeSelector.nodeSelectorTerms.matchExpressions** ([]<a href="{{< ref "../common-definitions/node-selector-requirement#NodeSelectorRequirement" >}}">NodeSelectorRequirement</a>)

        *Atomic: буде замінено під час злиття*

        Список вимог селектора вузлів за мітками вузлів.

      - **allocation.nodeSelector.nodeSelectorTerms.matchFields** ([]<a href="{{< ref "../common-definitions/node-selector-requirement#NodeSelectorRequirement" >}}">NodeSelectorRequirement</a>)

        *Atomic: буде замінено під час злиття*

        Список вимог селектора вузлів за полями вузлів.

- **devices** ([]AllocatedDeviceStatus)

  *Map: унікальні значення ключів `driver, device, pool, shareID` будуть збережені під час злиття*

  Devices містить стан кожного пристрою, призначеного для цієї заявки, згідно з повідомленням драйвера. Це може включати інформацію конкретного драйвера. Записи належать відповідним драйверам.

  <a name="AllocatedDeviceStatus"></a>
  *AllocatedDeviceStatus містить стан виділеного пристрою, якщо драйвер вирішив повідомити про нього. Це може включати специфічну для драйвера інформацію.*

  _Комбінація Driver, Pool, Device та ShareID має збігатися з відповідним ключем у Status.Allocation.Devices._

  - **devices.device** (string), обовʼязково

    Device посилається на один екземпляр пристрою через його імʼя у пулі ресурсів драйвера. Це має бути мітка DNS.

  - **devices.driver** (string), обовʼязково

    Driver вказує імʼя драйвера DRA, чий втулок kubelet має бути викликаний для обробки розподілу, коли заявка буде необхідна на вузлі.

    Має бути субдоменом DNS і закінчуватися на DNS-домені, що належить постачальнику драйвера. Має складатись із смволів нижнього регістру.

  - **devices.pool** (string), обовʼязково

    Це імʼя разом з імʼям драйвера та полем імені пристрою визначає, який пристрій було виділено (`\<імʼя драйвера>/\<імʼя пулу>/\<імʼя пристрою>`).

    Має бути не довшим за 253 символи і може містити один або декілька субдоменів DNS, розділених косою рискою.

  - **devices.conditions** ([]Condition)

    *Map: унікальні значення ключа type будуть збережені під час злиття*

    Conditions містить останнє спостереження за станом пристрою. Якщо пристрій було сконфігуровано згідно з посиланнями на конфігурацію класу та вимоги, стан `Ready` має бути рівним True.

    Має містити не більше 8 елементів.

    <a name="Condition"></a>
    *Condition містить деталі для одного з аспектів поточного стану цього API-ресурсу.*

    - **devices.conditions.lastTransitionTime** (Time), обовʼязково

      lastTransitionTime - час останнього переходу стану з одного стану в інший. Це має бути час, коли змінюється базовий стан.  Якщо це невідомо, то можна використовувати час, коли змінилося поле API.

      <a name="Time"></a>
      *Time — це обгортка навколо time.Time, яка підтримує коректне перетворення у YAML та JSON. Для багатьох з функцій, які пропонує пакет time, надаються обгортки.*

    - **devices.conditions.message** (string), обовʼязково

      message - це повідомлення, зрозуміле людині, яке містить деталі про перехід. Це може бути порожній рядок.

    - **devices.conditions.reason** (string), обовʼязково

      reason містить програмний ідентифікатор, що вказує на причину останньої зміни стану . Розробники конкретних типів станів можуть визначати очікувані значення та значення для цього поля, а також те, чи вважатимуться ці значення гарантованим API. Значення має бути рядком у регістрі CamelCase. Це поле не може бути порожнім.

    - **devices.conditions.status** (string), обовʼязково

      status — статус стану умови, одне з True, False, Unknown.

    - **devices.conditions.type** (string), обовʼязково

      тип стану в CamelCase або в foo.example.com/CamelCase.

    - **devices.conditions.observedGeneration** (int64)

      observedGeneration представляє .metadata.generation, на основі якого було встановлено стан. Наприклад, якщо .metadata.generation наразі дорівнює 12, але .status.conditions[x].observedGeneration дорівнює 9, стан застарів по відношенню до поточного стану екземпляра.

  - **devices.data** (RawExtension)

    Дані містять довільні дані, специфічні для конкретного драйвера.

    Довжина вихідних даних повинна бути меншою або дорівнювати 10 Ki.

    <a name="RawExtension"></a>
    *RawExtension is used to hold extensions in external versions.*

    Щоб скористатися цим, створіть поле з типом RawExtension у вашій зовнішній, версійній структурі та Object у вашій внутрішній структурі. Вам також потрібно зареєструвати різні типи втулків.

    // Internal package:

    ```go
    type MyAPIObject struct {
      runtime.TypeMeta `json:",inline"`
      MyPlugin runtime.Object `json:"myPlugin"`
    }

    type PluginA struct {
      AOption string `json:"aOption"`
    }
    ```

    // External package:

    ```go
    type MyAPIObject struct {
      runtime.TypeMeta `json:",inline"`
      MyPlugin runtime.RawExtension `json:"myPlugin"`
    }

    type PluginA struct {
      AOption string `json:"aOption"`
    }
    ```

    // На екрані JSON буде виглядати приблизно так:

    ```json
    {
      "kind":"MyAPIObject",
      "apiVersion":"v1",
      "myPlugin": {
        "kind":"PluginA",
        "aOption":"foo",
      },
    }
    ```

    Що відбувається далі? Декодування спочатку використовує json або yaml для розбиття серіалізованих даних на частини у вашому зовнішньому обʼєкті MyAPIObject. Це призводить до того, що необроблений JSON зберігається, але не розпаковується. Наступним кроком буде копіювання (за допомогою pkg/conversion) у внутрішню структуру. У DefaultScheme пакета виконання встановлені функції перетворення, які розпакують JSON, що зберігається у RawExtension, перетворивши його у правильний тип обʼєкта, і збережуть його у Object. (TODO: У випадку, якщо обʼєкт має невідомий тип, буде створено та збережено обʼєкт runtime.Unknown).

  - **devices.networkData** (NetworkDeviceData)

    NetworkData містить інформацію, повʼязану з мережею, специфічну для пристрою.

    <a name="NetworkDeviceData"></a>
    *NetworkDeviceData містить мережеву інформацію про виділений пристрій. Цю інформацію може бути заповнено драйверами або іншими компонентами для конфігурування або ідентифікації пристрою у мережевому контексті.*

    - **devices.networkData.hardwareAddress** (string)

      HardwareAddress — апаратна адреса (наприклад, MAC-адреса) мережевого інтерфейсу пристрою.

      Не повинна бути довшою за 128 символів.

    - **devices.networkData.interfaceName** (string)

      InterfaceName вказує назву мережевого інтерфейсу, повʼязаного з виділеним пристроєм. Це може бути імʼя фізичного або віртуального мережевого інтерфейсу, який налаштовується у боді.

      Не повинно бути довшим за 256 символів.

    - **devices.networkData.ips** ([]string)

      *Atomic: буде замінено під час злиття*

      IPs перелічує мережеві адреси, призначені мережевому інтерфейсу пристрою. Сюди можуть входити адреси IPv4 і IPv6. IP-адреси подано у нотації CIDR, яка включає як адресу, так і повʼязану з нею маску підмережі, наприклад: "192.0.2.5/24" для IPv4 і "2001:db8::5/64" для IPv6.

  - **devices.shareID** (string)

    ShareID однозначно ідентифікує індивідуальну частку розподілу пристрою.

- **reservedFor** ([]ResourceClaimConsumerReference)

  *Patch strategy: обʼєднання за ключем `uid`*

  *Map: унікальні значення ключа uid будуть збережені під час злиття*

  ReservedFor вказує, які сутності в даний момент можуть використовувати заявку. Pod, який посилається на ResourceClaim, що не зарезервована для цього Podʼа, не буде запущений. Заявка, яка використовується або може бути використана, оскільки вона зарезервована, не повинна бути деалокована.

  У кластері з кількома екземплярами планувальника два podʼи можуть бути заплановані одночасно різними планувальниками. Коли вони посилаються на один і той же ResourceClaim, який вже досяг максимального числа споживачів, лише один pod може бути запланований.

  Обидва планувальники намагаються додати свій pod до поля claim.status.reservedFor, але лише оновлення, яке досягає API-сервера першим, зберігається. Інше оновлення зазнає помилки, і планувальник, який його надіслав, знає, що потрібно повернути pod у чергу, чекаючи, поки ResourceClaim знову стане доступним.

  Може бути не більше 256 таких резервувань. Це число може бути збільшено в майбутньому, але не зменшено.

  <a name="ResourceClaimConsumerReference"></a>
  *ResourceClaimConsumerReference містить достатньо інформації, щоб знайти споживача ResourceClaim. Користувач має бути ресурсом в тому ж просторі імен, що і ResourceClaim.*

  - **reservedFor.name** (string), обовʼязково

    Name — це імʼя ресурсу, на який посилаються.

  - **reservedFor.resource** (string), обовʼязково

    Resource — це тип ресурсу, на який посилаються, наприклад, "pods".

  - **reservedFor.uid** (string), обовʼязково

    UID ідентифікує саме одну інкарнацію ресурсу.

  - **reservedFor.apiGroup** (string)

    APIGroup — це група для ресурсу, на який посилаються. Вона порожня для основного API. Це відповідає групі в APIVersion, яка використовується при створенні ресурсів.

## ResourceClaimList {#ResourceClaimList}

ResourceClaimList — це колекція заявок.

---

- **apiVersion**: resource.k8s.io/v1

- **kind**: ResourceClaimList

- **metadata** (<a href="{{< ref "../common-definitions/list-meta#ListMeta" >}}">ListMeta</a>)

  Стандартні метадані списку

- **items** ([]<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>), обовʼязково

  Items — це список вимог на ресурси.

## Операції {#Operations}

---

### `get` отримати вказаний ResourceClaim {#get-read-the-specified-resourceclaim}

#### HTTP запит {#http-request}

GET /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims/{name}

#### Параметри {#parameters}

- **name** (*в шляху*): string, обовʼязково

  name of the ResourceClaim

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

#### Відповідь {#response}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): OK

401: Unauthorized

### `get` отримати статус вказаного ResourceClaim {#get-read-status-of-the-specified-resourceclaim}

#### HTTP запит {#http-request-1}

GET /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims/{name}/status

#### Параметри {#parameters-1}

- **name** (*в шляху*): string, обовʼязково

  name of the ResourceClaim

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

#### Відповідь {#response-1}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): OK

401: Unauthorized

### `list` перелік або перегляд обʼєктів типу ResourceClaim {#list-list-or-watch-objects-of-kind-resourceclaim}

#### HTTP запит {#http-request-2}

GET /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims

#### Параметри {#parameters-2}

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **allowWatchBookmarks** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#allowWatchBookmarks" >}}">allowWatchBookmarks</a>

- **continue** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#continue" >}}">continue</a>

- **fieldSelector** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldSelector" >}}">fieldSelector</a>

- **labelSelector** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#labelSelector" >}}">labelSelector</a>

- **limit** (*в запиті*): integer

  <a href="{{< ref "../common-parameters/common-parameters#limit" >}}">limit</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

- **resourceVersion** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#resourceVersion" >}}">resourceVersion</a>

- **resourceVersionMatch** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#resourceVersionMatch" >}}">resourceVersionMatch</a>

- **sendInitialEvents** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#sendInitialEvents" >}}">sendInitialEvents</a>

- **timeoutSeconds** (*в запиті*): integer

  <a href="{{< ref "../common-parameters/common-parameters#timeoutSeconds" >}}">timeoutSeconds</a>

- **watch** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#watch" >}}">watch</a>

#### Відповідь {#response-2}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaimList" >}}">ResourceClaimList</a>): OK

401: Unauthorized

### `list` перелік або перегляд обʼєктів типу ResourceClaim {#list-list-or-watch-objects-of-kind-resourceclaim-1}

#### HTTP запит {#http-request-3}

GET /apis/resource.k8s.io/v1/resourceclaims

#### Параметри {#parameters-3}

- **allowWatchBookmarks** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#allowWatchBookmarks" >}}">allowWatchBookmarks</a>

- **continue** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#continue" >}}">continue</a>

- **fieldSelector** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldSelector" >}}">fieldSelector</a>

- **labelSelector** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#labelSelector" >}}">labelSelector</a>

- **limit** (*в запиті*): integer

  <a href="{{< ref "../common-parameters/common-parameters#limit" >}}">limit</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

- **resourceVersion** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#resourceVersion" >}}">resourceVersion</a>

- **resourceVersionMatch** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#resourceVersionMatch" >}}">resourceVersionMatch</a>

- **sendInitialEvents** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#sendInitialEvents" >}}">sendInitialEvents</a>

- **timeoutSeconds** (*в запиті*): integer

  <a href="{{< ref "../common-parameters/common-parameters#timeoutSeconds" >}}">timeoutSeconds</a>

- **watch** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#watch" >}}">watch</a>

#### Відповідь {#response-3}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaimList" >}}">ResourceClaimList</a>): OK

401: Unauthorized

### `create` створення ResourceClaim {#create-create-a-resourceclaim}

#### HTTP запит {#http-request-4}

POST /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims

#### Параметри {#parameters-4}

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **body**: <a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>, обовʼязково

- **dryRun** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#dryRun" >}}">dryRun</a>

- **fieldManager** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldManager" >}}">fieldManager</a>

- **fieldValidation** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldValidation" >}}">fieldValidation</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

#### Відповідь {#response-4}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): OK

201 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): Created

202 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): Accepted

401: Unauthorized

### `update` заміна вказаного ResourceClaim {#update-replace-the-specified-resourceclaim}

#### HTTP запит {#http-request-5}
PUT /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims/{name}

#### Параметри {#parameters-5}

- **name** (*в шляху*): string, обовʼязково

  назва ResourceClaim

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **body**: <a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>, обовʼязково

- **dryRun** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#dryRun" >}}">dryRun</a>

- **fieldManager** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldManager" >}}">fieldManager</a>

- **fieldValidation** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldValidation" >}}">fieldValidation</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

#### Відповідь {#response-5}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): OK

201 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): Created

401: Unauthorized

### `update` заміна статусу вказаного ResourceClaim {#update-replace-status-of-the-specified-resourceclaim}

#### HTTP запит {#http-request-6}

PUT /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims/{name}/status

#### Параметри {#parameters-6}

- **name** (*в шляху*): string, обовʼязково

  назва ResourceClaim

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **body**: <a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>, обовʼязково

- **dryRun** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#dryRun" >}}">dryRun</a>

- **fieldManager** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldManager" >}}">fieldManager</a>

- **fieldValidation** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldValidation" >}}">fieldValidation</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

#### Відповідь {#response-6}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): OK

201 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): Created

401: Unauthorized

### `patch` часткове оновлення вказаного ResourceClaim {#patch-partially-update-the-specified-resourceclaim}

#### HTTP запит {#http-request-7}

PATCH /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims/{name}

#### Параметри {#parameters-7}

- **name** (*в шляху*): string, обовʼязково

  назва ResourceClaim

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **body**: <a href="{{< ref "../common-definitions/patch#Patch" >}}">Patch</a>, обовʼязково

- **dryRun** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#dryRun" >}}">dryRun</a>

- **fieldManager** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldManager" >}}">fieldManager</a>

- **fieldValidation** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldValidation" >}}">fieldValidation</a>

- **force** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#force" >}}">force</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

#### Відповідь {#response-7}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): OK

201 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): Created

401: Unauthorized

### `patch` часткове оновлення статусу вказаного ResourceClaim {#patch-partially-update-status-of-the-specified-resourceclaim}

#### HTTP запит {#http-request-8}


PATCH /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims/{name}/status

#### Параметри {#parameters-8}

- **name** (*в шляху*): string, обовʼязково

  name of the ResourceClaim

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **body**: <a href="{{< ref "../common-definitions/patch#Patch" >}}">Patch</a>, обовʼязково

- **dryRun** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#dryRun" >}}">dryRun</a>

- **fieldManager** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldManager" >}}">fieldManager</a>

- **fieldValidation** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldValidation" >}}">fieldValidation</a>

- **force** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#force" >}}">force</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

#### Відповідь {#response-8}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): OK

201 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): Created

401: Unauthorized

### `delete` видалення ResourceClaim {#delete-delete-a-resourceclaim}

#### HTTP запит {#http-request-9}

DELETE /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims/{name}

#### Параметри {#parameters-9}

- **name** (*в шляху*): string, обовʼязково

  назва ResourceClaim

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **body**: <a href="{{< ref "../common-definitions/delete-options#DeleteOptions" >}}">DeleteOptions</a>

- **dryRun** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#dryRun" >}}">dryRun</a>

- **gracePeriodSeconds** (*в запиті*): integer

  <a href="{{< ref "../common-parameters/common-parameters#gracePeriodSeconds" >}}">gracePeriodSeconds</a>

- **ignoreStoreReadErrorWithClusterBreakingPotential** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#ignoreStoreReadErrorWithClusterBreakingPotential" >}}">ignoreStoreReadErrorWithClusterBreakingPotential</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

- **propagationPolicy** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#propagationPolicy" >}}">propagationPolicy</a>

#### Відповідь {#response-9}

200 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): OK

202 (<a href="{{< ref "../workload-resources/resource-claim-v1#ResourceClaim" >}}">ResourceClaim</a>): Accepted

401: Unauthorized

### `deletecollection` видалення of ResourceClaim {#deletecollection-delete-collection-of-resourceclaim}

#### HTTP запит {#http-request-10}

DELETE /apis/resource.k8s.io/v1/namespaces/{namespace}/resourceclaims

#### Параметри {#parameters-10}

- **namespace** (*в шляху*): string, обовʼязково

  <a href="{{< ref "../common-parameters/common-parameters#namespace" >}}">namespace</a>

- **body**: <a href="{{< ref "../common-definitions/delete-options#DeleteOptions" >}}">DeleteOptions</a>

- **continue** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#continue" >}}">continue</a>

- **dryRun** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#dryRun" >}}">dryRun</a>

- **fieldSelector** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#fieldSelector" >}}">fieldSelector</a>

- **gracePeriodSeconds** (*в запиті*): integer

  <a href="{{< ref "../common-parameters/common-parameters#gracePeriodSeconds" >}}">gracePeriodSeconds</a>

- **ignoreStoreReadErrorWithClusterBreakingPotential** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#ignoreStoreReadErrorWithClusterBreakingPotential" >}}">ignoreStoreReadErrorWithClusterBreakingPotential</a>

- **labelSelector** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#labelSelector" >}}">labelSelector</a>

- **limit** (*в запиті*): integer

  <a href="{{< ref "../common-parameters/common-parameters#limit" >}}">limit</a>

- **pretty** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#pretty" >}}">pretty</a>

- **propagationPolicy** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#propagationPolicy" >}}">propagationPolicy</a>

- **resourceVersion** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#resourceVersion" >}}">resourceVersion</a>

- **resourceVersionMatch** (*в запиті*): string

  <a href="{{< ref "../common-parameters/common-parameters#resourceVersionMatch" >}}">resourceVersionMatch</a>

- **sendInitialEvents** (*в запиті*): boolean

  <a href="{{< ref "../common-parameters/common-parameters#sendInitialEvents" >}}">sendInitialEvents</a>

- **timeoutSeconds** (*в запиті*): integer

  <a href="{{< ref "../common-parameters/common-parameters#timeoutSeconds" >}}">timeoutSeconds</a>

#### Відповідь {#response-10}

200 (<a href="{{< ref "../common-definitions/status#Status" >}}">Status</a>): OK

401: Unauthorized
