---
title: Початкове завантаження TLS
content_type: concept
weight: 120
---

<!-- overview -->

У кластері Kubernetes компоненти на вузлах робочих навантажень, kubelet та kube-proxy, повинні взаємодіяти з компонентами панелі управління Kubernetes, зокрема з kube-apiserver. Для забезпечення приватності комунікації, її невтручання та переконання, що кожен компонент кластера спілкується з іншим довіреним компонентом, ми наполегливо рекомендуємо використовувати TLS-сертифікати клієнтів на вузлах.

Звичайний процес ініціалізації цих компонентів, особливо робочих вузлів, які потребують сертифікати для безпечної комунікації з kube-apiserver, може бути складним, оскільки він часто виходить за межі Kubernetes і вимагає значної додаткової роботи. Це, своєю чергою, може ускладнити ініціалізацію або масштабування кластера.

З метою спрощення процесу, починаючи з версії 1.4, Kubernetes ввів API запиту та підпису сертифікатів. Пропозицію можна знайти [тут](https://github.com/kubernetes/kubernetes/pull/20439).

У цьому документі описано процес ініціалізації вузла, спосіб налаштування початкового завантаження TLS-сертифікатів клієнтів для kubelet та його роботу.

<!-- body -->

## Процес ініціалізації {#initialization-process}

Коли робочий вузол запускається, kubelet виконує наступне:

1. Шукає свій файл `kubeconfig`.
1. Отримує URL-адресу сервера API та облікові дані, зазвичай ключ TLS та підписаний сертифікат з файлу `kubeconfig`.
1. Намагається спілкуватися з сервером API, використовуючи облікові дані.

Припускаючи, що kube-apiserver успішно перевіряє облікові дані kubelet, він буде вважати kubelet дійсним вузлом та почне призначати для нього Podʼи.

Зауважте, що вищевказаний процес залежить від:

* Існування ключа та сертифіката на локальному хості у `kubeconfig`.
* Підписання сертифіката центром сертифікації (CA), якому довіряє kube-apiserver.

Всі перелічені нижче обовʼязки покладаються на того, хто налаштовує та керує кластером:

1. Створення ключа та сертифіката CA.
2. Розповсюдження сертифіката CA на вузли панелі управління, де запущений kube-apiserver.
3. Створення ключа та сертифіката для кожного kubelet; наполегливо рекомендується мати унікальний ключ з унікальним CN для кожного kubelet.
4. Підписання сертифіката kubelet за допомогою ключа CA.
5. Розповсюдження ключа та підписаного сертифіката kubelet на конкретний вузол, на якому працює kubelet.

Початкове завантаження TLS, описане у цьому документі, призначене спростити та частково або повністю автоматизувати кроки з 3 по 14, оскільки вони є найбільш поширеними при ініціалізації або масштабуванні кластера.

### Ініціалізація початкового завантаження {#bootstrap-initialization}

Під час процесу ініціалізації початкового завантаження відбувається наступне:

1. kubelet починає роботу.
1. kubelet бачить, що у нього _немає_ файлу `kubeconfig`.
1. kubelet шукає та знаходить файл `bootstrap-kubeconfig`.
1. kubelet читає свій файл ініціалізації початкового завантаження, отримуючи URL-адресу сервера API та обмежений "токен".
1. kubelet підключається до сервера API, автентифікується за допомогою токена.
1. у kubelet тепер є обмежені облікові дані для створення та отримання запиту на підпис сертифіката (CSR).
1. kubelet створює CSR для себе з встановленим signerName `kubernetes.io/kube-apiserver-client-kubelet`.
1. CSR затверджується одним з двох способів:
   * Якщо налаштовано, kube-controller-manager автоматично затверджує CSR.
   * Якщо налаштовано, зовнішній процес, можливо, людина, затверджує CSR за допомогою API Kubernetes або через `kubectl`.
1. Сертифікат створюється для kubelet.
1. Сертифікат видано для kubelet.
1. kubelet отримує сертифікат.
1. kubelet створює належний `kubeconfig` з ключем та підписаним сертифікатом.
1. kubelet починає нормальну роботу.
1. Опціонально: якщо налаштовано, kubelet автоматично запитує поновлення сертифіката, коли той наближається до закінчення строку дії.
1. Поновлений сертифікат затверджується та видається, або автоматично, або вручну, залежно від налаштувань.

Усі інші розділи цього документу описують необхідні кроки для налаштування початкового завантаження TLS та його обмежень.

## Налаштування {#configuration}

Для налаштування початкового завантаження TLS та опціонального автоматичного затвердження потрібно налаштувати параметри на наступних компонентах:

* kube-apiserver
* kube-controller-manager
* kubelet
* ресурси в кластері: `ClusterRoleBinding` та, можливо, `ClusterRole`

Крім того, вам потрібен ваш центр сертифікації Kubernetes (CA).

## Центр сертифікації {#certificate-authority}

Як і без початкового завантаження, вам знадобиться ключ та сертифікат центру сертифікації (CA). Як і раніше, вони будуть використовуватися для підпису сертифіката kubelet. Як і раніше, ваша відповідальність полягає в їх розповсюджені на вузли панелі управління.

Для цілей цього документу ми припускаємо, що вони розповсюджені на вузли панелі управління за шляхом `/var/lib/kubernetes/ca.pem` (сертифікат) та `/var/lib/kubernetes/ca-key.pem` (ключ). Ми будемо посилатися на них як "сертифікат та ключ CA Kubernetes".

Всі компоненти Kubernetes, які використовують ці сертифікати — kubelet, kube-apiserver, kube-controller-manager — припускають, що ключ та сертифікат закодовані у PEM-форматі.

## Налаштування kube-apiserver {#kube-apiserver-configuration}

У kube-apiserver є кілька вимог для активації початкового завантаження TLS:

* Визнання CA, який підписує сертифікат клієнта
* Автентифікація початкового завантаження kubelet у групу `system:bootstrappers`
* Авторизація початкового завантаження kubelet для створення запиту на підпис сертифіката (CSR)

### Визнання сертифікатів клієнтів {#recognizing-client-certificates}

Це є нормою для всієї автентифікації сертифікатів клієнтів. Якщо це ще не налаштовано, додайте прапорець `--client-ca-file=ФАЙЛ` до команди kube-apiserver, щоб активувати автентифікацію за сертифікатом клієнта, посилаючись на пакет сертифікатів центру сертифікації, наприклад `--client-ca-file=/var/lib/kubernetes/ca.pem`.

### Початкова автентифікація початкового завантаження {#initial-bootstrap-authentication}

Для того, щоб процес початкового завантаження kubelet міг підʼєднатися до kube-apiserver та запросити сертифікат, спочатку йому потрібно автентифікуватися на сервері. Ви можете використовувати будь-який [автентифікатор](/docs/reference/access-authn-authz/authentication/), який може автентифікувати kubelet.

Хоча будь-яка стратегія автентифікації може бути використана для початкових облікових даних kubelet, рекомендується використовувати наступні два автентифікатори для полегшення надання прав.

1. [Токени початкового завантаження](#bootstrap-tokens)
1. [Файл автентифікації токенів](#token-authentication-file)

Використання токенів початкового завантаження є простішим та зручнішим способом автентифікації kubelet і не вимагає додаткових прапорів при запуску kube-apiserver.

Який би метод ви не обрали, вимога полягає в тому, щоб kubelet міг автентифікуватися як користувач з правами на:

1. створення та отримання CSRs
2. автоматичне затвердження запиту клієнтських сертифікатів вузлів, якщо увімкнено автоматичне затвердження.

Kubelet, який автентифікується за допомогою початкових токенів, автентифікується як користувач у групі `system:bootstrappers`, що є стандартним методом використання.

Оскільки ця функція вдосконалюється, вам слід переконатися, що токени привʼязані до політики управління доступом на основі ролей (RBAC), яка обмежує запити (використовуючи [початковий токен](/docs/reference/access-authn-authz/bootstrap-tokens/)) виключно клієнтськими запитами, повʼязаними з наданням сертифікатів. З RBAC можна гнучко налаштовувати обмеження для токенів за групами. Наприклад, ви можете вимкнути доступ певної початкової групи після завершення розгортання вузлів.

#### Токени початкового завантаження {#bootstrap-tokens}

Токени початкового завантаження докладно описані [тут](/docs/reference/access-authn-authz/bootstrap-tokens/). Це токени, які зберігаються як секрети в кластері Kubernetes і потім видаються окремим kubelet. Ви можете використовувати один токен для всього кластера або видавати по одному на кожен робочий вузол.

Процес складається з двох етапів:

1. Створити Secret Kubernetes з ідентифікатором токена, секретом і областю(ями).
2. Видати токен kubelet.

З погляду kubelet, один токен такий самий, як інший і не має особливого значення. З погляду kube-apiserver, однак, початковий токен є особливим. Завдяки його `type`, `namespace` і `name`, kube-apiserver розпізнає його як спеціальний токен і надає будь-кому, хто автентифікується з цим токеном, особливі права початкового завантаження, зокрема, розглядаючи їх як члена групи `system:bootstrappers`. Це виконує основну вимогу для початкового завантаження TLS.

Деталі щодо створення секрету доступні [тут](/docs/reference/access-authn-authz/bootstrap-tokens/).

Якщо ви хочете використовувати токени початкового завантаження, ви повинні увімкнути їх на kube-apiserver з прапорцем:

```console
--enable-bootstrap-token-auth=true
```

#### Файл автентифікації токенів {#token-authentication-file}

kube-apiserver має можливість приймати токени для автентифікації. Ці токени можуть бути довільними, але повинні представляти щонайменше 128 біт ентропії, отриманих з надійного генератора випадкових чисел (наприклад, `/dev/urandom` у більшості сучасних Linux-систем). Є кілька способів генерації токена. Наприклад:

```shell
head -c 16 /dev/urandom | od -An -t x | tr -d ' '
```

Це згенерує токени, які виглядають так: `02b50b05283e98dd0fd71db496ef01e8`.

Файл токенів повинен виглядати як у наступному прикладі, де перші три значення можуть бути будь-якими, а імʼя групи в лапках повинно бути таким, як показано:

```console
02b50b05283e98dd0fd71db496ef01e8,kubelet-bootstrap,10001,"system:bootstrappers"
```

Додайте прапорець `--token-auth-file=FILENAME` до команди kube-apiserver (можливо, у вашому файлі systemd), щоб увімкнути файл токенів. Докладніше дивіться [тут](/docs/reference/access-authn-authz/authentication/#static-token-file).

### Авторизація kubelet на створення CSR {#authorize-kubelet-to-create-csr}

Тепер, коли вузол початкового завантаження _автентифікований_ як частина групи `system:bootstrappers`, його потрібно _авторизувати_ на створення запиту на підпис сертифіката (CSR), а також на його отримання після завершення. На щастя, Kubernetes постачається з `ClusterRole`, який має саме ці (і тільки ці) дозволи, `system:node-bootstrapper`.

Щоб зробити це, потрібно лише створити `ClusterRoleBinding`, що звʼязує групу `system:bootstrappers` з кластерною роллю `system:node-bootstrapper`.

```yaml
# увімкнення створення CSR для вузлів початкового завантаження
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: create-csrs-for-bootstrapping
subjects:
- kind: Group
  name: system:bootstrappers
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: system:node-bootstrapper
  apiGroup: rbac.authorization.k8s.io
```

## Налаштування kube-controller-manager {#kube-controller-manager-configuration}

Поки apiserver отримує запити на сертифікати від kubelet і автентифікує ці запити, controller-manager відповідає за видачу фактичних підписаних сертифікатів.

Controller-manager виконує цю функцію через цикл управління видачею сертифікатів. Це реалізується у вигляді локального підписувача [cfssl](https://blog.cloudflare.com/introducing-cfssl/), який використовує активи на диску. Зараз всі видані сертифікати стандартно мають один рік дійсності та набір ключів для використання.

Для того, щоб controller-manager міг підписувати сертифікати, йому потрібно наступне:

* доступ до "ключа та сертифіката Kubernetes CA", який ви створили та розповсюдили
* увімкнення підписування CSR

### Доступ до ключа та сертифіката {#access-to-key-and-certificate}

Як описано раніше, вам потрібно створити ключ і сертифікат Kubernetes CA і розповсюдити їх на вузли панелі управління. Ці сертифікати будуть використовуватися controller-manager для підписування сертифікатів kubelet.

Оскільки ці підписані сертифікати, своєю чергою, будуть використовуватися kubelet для автентифікації як звичайного kubelet до kube-apiserver, важливо, щоб CA, наданий controller-manager на цьому етапі, також був довірений kube-apiserver для автентифікації. Це надається kube-apiserver за допомогою прапорця `--client-ca-file=FILENAME` (наприклад, `--client-ca-file=/var/lib/kubernetes/ca.pem`), як описано в розділі конфігурації kube-apiserver.

Щоб надати ключ і сертифікат Kubernetes CA для kube-controller-manager, використовуйте наступні прапорці:

```shell
--cluster-signing-cert-file="/etc/path/to/kubernetes/ca/ca.crt" --cluster-signing-key-file="/etc/path/to/kubernetes/ca/ca.key"
```

Наприклад:

```shell
--cluster-signing-cert-file="/var/lib/kubernetes/ca.pem" --cluster-signing-key-file="/var/lib/kubernetes/ca-key.pem"
```

Тривалість дійсності підписаних сертифікатів можна налаштувати за допомогою прапорця:

```shell
--cluster-signing-duration
```

### Затвердження {#approval}

Щоб затвердити CSR, потрібно вказати controller-manager, що їх можна затверджувати. Це робиться шляхом надання прав доступу RBAC потрібній групі.

Існують два різні набори дозволів:

* `nodeclient`: Якщо вузол створює новий сертифікат для вузла, тоді у нього ще немає сертифіката. Він автентифікується за допомогою одного з токенів, зазначених вище, і таким чином є частиною групи `system:bootstrappers`.
* `selfnodeclient`: Якщо вузол оновлює свій сертифікат, тоді у нього вже є сертифікат (за визначенням), який він використовує для автентифікації як частина групи `system:nodes`.

Щоб дозволити kubelet запитувати та отримувати новий сертифікат, створіть `ClusterRoleBinding`, що звʼязує групу, в якій є членом вузол початкового завантаження, `system:bootstrappers`, з `ClusterRole`, що надає їй дозвіл, `system:certificates.k8s.io:certificatesigningrequests:nodeclient`:

```yaml
# Затвердження всіх CSR для групи "system:bootstrappers"
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: auto-approve-csrs-for-group
subjects:
- kind: Group
  name: system:bootstrappers
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient
  apiGroup: rbac.authorization.k8s.io
```

Щоб дозволити kubelet оновлювати власний клієнтський сертифікат, створіть `ClusterRoleBinding`, що звʼязує групу, в якій є членом повнофункціональний вузол, `system:nodes`, з `ClusterRole`, що
надає їй дозвіл, `system:certificates.k8s.io:certificatesigningrequests:selfnodeclient`:
```yaml
# Затвердження запитів на оновлення CSR для групи "system:nodes"
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: auto-approve-renewals-for-nodes
subjects:
- kind: Group
  name: system:nodes
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient
  apiGroup: rbac.authorization.k8s.io
```

Контролер `csrapproving`, який постачається як частина [kube-controller-manager](/docs/reference/command-line-tools-reference/kube-controller-manager/), стандартно увімкнено. Контролер використовує [API `SubjectAccessReview`](/docs/reference/access-authn-authz/authorization/#checking-api-access) для визначення, чи авторизований користувач для запиту CSR, а потім затверджує на основі результатів авторизації. Щоб уникнути конфліктів з іншими затверджувачами, вбудований затверджувач не відхиляє CSR явним чином. Він лише ігнорує неавторизовані запити. Контролер також видаляє прострочені сертифікати в рамках збору сміття.

## Налаштування kubelet {#kubelet-configuration}

Нарешті, з правильно налаштованими вузлами панелі управління та всією необхідною автентифікацією та авторизацією, ми можемо налаштувати kubelet.

Для початкового завантаження kubelet потрібна наступна конфігурація:

* Шлях для зберігання ключа та сертифіката, які він генерує (опціонально, можна використовувати стандартні)
* Шлях до файлу `kubeconfig`, який ще не існує; тут буде збережено конфігураційний файл після початкового завантаження
* Шлях до початкового файлу `kubeconfig`, що містить URL сервера та початкові облікові дані, наприклад, початковий токен
* Опціонально: інструкції щодо ротації сертифікатів

Початковий файл `kubeconfig` має бути в шляху, доступному для kubelet, наприклад `/var/lib/kubelet/bootstrap-kubeconfig`.

Його формат ідентичний звичайному файлу `kubeconfig`. Приклад файлу може виглядати наступним чином:

```yaml
apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority: /var/lib/kubernetes/ca.pem
    server: https://my.server.example.com:6443
  name: bootstrap
contexts:
- context:
    cluster: bootstrap
    user: kubelet-bootstrap
  name: bootstrap
current-context: bootstrap
preferences: {}
users:
- name: kubelet-bootstrap
  user:
    token: 07401b.f395accd246ae52d
```

Важливі елементи:

* `certificate-authority`: шлях до файлу CA, використовується для перевірки сертифіката сервера, представленого kube-apiserver
* `server`: URL до kube-apiserver
* `token`: токен для використання

Формат токена не має значення, головне, щоб він відповідав очікуванням kube-apiserver. У наведеному прикладі ми використали початковий токен. Як зазначалося раніше, _будь-який_ дійсний метод автентифікації може бути використаний, а не тільки токени.

Оскільки початковий `kubeconfig` _є_ стандартним `kubeconfig`, ви можете використовувати `kubectl` для його створення. Щоб створити вищезазначений приклад файлу:

```shell
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-cluster bootstrap --server='https://my.server.example.com:6443' --certificate-authority=/var/lib/kubernetes/ca.pem
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-credentials kubelet-bootstrap --token=07401b.f395accd246ae52d
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-context bootstrap --user=kubelet-bootstrap --cluster=bootstrap
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig use-context bootstrap
```

Щоб вказати kubelet використовувати початковий `kubeconfig`, використовуйте наступний прапорець:

```config
--bootstrap-kubeconfig="/var/lib/kubelet/bootstrap-kubeconfig" --kubeconfig="/var/lib/kubelet/kubeconfig"
```

Під час запуску kubelet, якщо файл, вказаний через `--kubeconfig`, не існує, початковий kubeconfig, вказаний через `--bootstrap-kubeconfig`, використовується для запиту клієнтського сертифіката від API сервера. Після затвердження запиту на сертифікат і його отримання kubelet, конфігураційний файл kubeconfig, що посилається на згенерований ключ і отриманий сертифікат, буде записаний у шлях, вказаний за допомогою `--kubeconfig`. Файл сертифіката і ключа буде розміщено в теці, вказаній прапорцем `--cert-dir`.

### Клієнтські та серверні сертифікати {#client-and-server-certificates}

Все вищезазначене стосується _клієнтських_ сертифікатів kubelet, зокрема сертифікатів, які kubelet використовує для автентифікації до kube-apiserver.

kubelet також може використовувати _серверні_ сертифікати. Сам kubelet відкриває https-точку доступу для певних функцій. Для їх захисту, kubelet може робити одне з наступного:

* використовувати наданий ключ та сертифікат через прапорці `--tls-private-key-file` та `--tls-cert-file`
* створити самопідписаний ключ та сертифікат, якщо ключ та сертифікат не надані
* запитати серверні сертифікати у сервера кластера через API CSR

Клієнтський сертифікат, наданий під час початкового завантаження TLS, стандартно підписується лише для `client auth` і, отже, не може використовуватися як серверний сертифікат, або `server auth`.

Однак, ви _можете_ увімкнути його серверний сертифікат, принаймні частково, через ротацію сертифікатів.

### Ротація сертифікатів {#certificate-rotation}

З версії Kubernetes v1.8 та вище kubelet реалізує функції для увімкнення ротації його клієнтських і/або серверних сертифікатів. Зверніть увагу, що ротація серверного сертифіката є __бета__ функцією та потребує функціональної можливості `RotateKubeletServerCertificate` на kubelet (стандартно увімкнено).

Ви можете налаштувати kubelet для ротації його клієнтських сертифікатів, створюючи нові CSRs при закінченні терміну дії його поточних облікових даних. Щоб увімкнути цю функцію, використовуйте поле `rotateCertificates` у [файлі конфігурації kubelet](/docs/tasks/administer-cluster/kubelet-config-file/) або передайте наступний аргумент командного рядка kubelet (застаріло):

```none
--rotate-certificates
```

Увімкнення `RotateKubeletServerCertificate` призводить до того, що kubelet __одночасно__
запитує серверний сертифікат після початкового завантаження своїх клієнтських облікових даних __і__ ротує цей сертифікат. Щоб увімкнути цю поведінку, використовуйте поле `serverTLSBootstrap` у [файлі конфігурації kubelet](/docs/tasks/administer-cluster/kubelet-config-file/) або передайте наступний аргумент командного рядка kubelet (застаріло):

```none
--rotate-server-certificates
```

{{< note >}}
Контролери, що затверджують CSR, реалізовані в ядрі Kubernetes, не затверджують серверні сертифікати вузла з міркувань [безпеки](https://github.com/kubernetes/community/pull/1982). Для використання `RotateKubeletServerCertificate` операторам потрібно запустити власний контролер затвердження або вручну затвердити запити на серверні сертифікати.

Процес затвердження серверних сертифікатів kubelet, специфічний для розгортання, зазвичай повинен затверджувати лише CSRs, які:

1. запитані вузлами (забезпечте, що поле `spec.username` має форму `system:node:<nodeName>` і `spec.groups` містить `system:nodes`)
2. запитують використання для серверного сертифіката (забезпечте, що `spec.usages` містить `server auth`, додатково містить `digital signature` та `key encipherment`, і не містить інших використань)
3. мають лише IP та DNS subjectAltNames, які належать запитуючому вузлу, і не мають URI та Email subjectAltNames (розібрати x509 Certificate Signing Request в `spec.request`, щоб перевірити `subjectAltNames`)

{{< /note >}}

## Інші складові автентифікації {#other-authentication-components}

Усі процеси завантаження TLS, описані у цьому документі, стосуються kubelet. Однак інші компоненти можуть потребувати прямого звʼязку з kube-apiserver. Особливо важливим є kube-proxy, який є частиною компонентів вузла Kubernetes і запускається на кожному вузлі, але може також включати інші компоненти, такі як моніторинг чи роботу з мережею.

Подібно до kubelet, цим іншим компонентам також потрібен метод автентифікації у kube-apiserver. У вас є кілька варіантів для генерації цих облікових даних:

* Традиційний спосіб: Створіть і розповсюдьте сертифікати так само як ви це робили для kubelet перед завантаженням TLS.
* DaemonSet: Оскільки сам kubelet завантажується на кожний вузол і достатньо для запуску базових служб, ви можете запускати kube-proxy та інші служби, специфічні для вузла, не як самостійний процес, а як daemonset у просторі імен `kube-system`. Оскільки він буде в кластері, ви можете надати йому відповідний службовий обліковий запис з відповідними дозволами для виконання своїх дій. Це може бути найпростішим способом налаштування таких служб.

## Затвердження за допомогою kubectl {#kubectl-approval}

Запити на сертифікати можна затвердити поза процесом затвердження, вбудованим у контролер
керування.

Контролер підпису не негайно підписує всі запити на сертифікати. Замість цього він чекає, доки вони не будуть позначені статусом "Approved" відповіднbv привілейованим користувачем. Цей процес призначений для того, щоб дозволити автоматичне затвердження, яке обробляється зовнішнім контролером затвердження або controller-manager, реалізованим в основному controller-manager. Однак адміністратори кластера також можуть вручну затверджувати запити на сертифікати за допомогою kubectl. Адміністратор може отримати перелік CSRs за допомогою `kubectl get csr` та детально описати один з них за допомогою `kubectl describe csr <name>`. Адміністратор може затвердити або відхилити CSR за допомогою `kubectl certificate approve <name>` та `kubectl certificate deny <name>`.
