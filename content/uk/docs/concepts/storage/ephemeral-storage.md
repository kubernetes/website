---
title: Локальне тимчасове сховище
content_type: concept
weight: 95
---

Вузли мають локальне тимчасове сховище, яке підтримується локально підключеними пристроями з можливістю запису або, інколи, оперативною памʼяттю. «Тимчасове» означає, що немає довгострокової гарантії щодо довговічності.

Podʼи використовують тимчасове локальне сховище для тимчасового простору, кешування та журналів. Kubelet може надавати тимчасовий простір для Podʼів, використовуючи локальне тимчасове сховище для монтування {{< glossary_tooltip term_id="volume" text="томів" >}}  [`emptyDir`](/docs/concepts/storage/volumes/#emptydir) у контейнери.

Kubelet також використовує цей тип сховища для зберігання [журналів контейнерів на рівні вузлів](/docs/concepts/cluster-administration/logging/#logging-at-the-node-level), образів контейнерів та шарів з можливістю запису запущених контейнерів.

{{< caution >}}
Якщо вузол виходить з ладу, дані в його тимчасовому сховищі можуть бути втрачені. Ваші застосунки не можуть очікувати жодних SLA щодо продуктивності (наприклад, дискових операцій введення-виведення за секунду) від локального тимчасового сховища.
{{< /caution >}}

{{< note >}}
Щоб квота ресурсів працювала на ephemeral-storage, потрібно виконати дві дії:

* Адміністратор встановлює квоту ресурсів для ephemeral-storage в просторі імен.
* Користувач повинен вказати обмеження для ресурсу ephemeral-storage у специфікації Podʼа.

Якщо користувач не вказав обмеження ресурсу ephemeral-storage у специфікації Podʼа, квота ресурсів не застосовується до ephemeral-storage.

{{< /note >}}

Kubernetes дозволяє відстежувати, резервувати та обмежувати обсяг тимчасового локального сховища, яке може використовувати Pod.

## Конфігурації для локального тимчасового сховища {#configurations}

Kubernetes підтримує два способи налаштування локального тимчасового сховища на вузлі:

{{< tabs name="local_storage_configurations" >}}
{{% tab name="Одинарна файлова система" %}}
У цій конфігурації ви розміщуєте всі різні типи тимчасових локальних даних (томи `emptyDir`, записувані шари, образи контейнерів, журнали) в одній файловій системі. Найефективніший спосіб налаштування kubelet — це виділення цієї файлової системи для даних Kubernetes (kubelet).

Kubelet також записує [журнали контейнерів на рівні вузла](/docs/concepts/cluster-administration/logging/#logging-at-the-node-level) і обробляє їх аналогічно тимчасовому локальному сховищу.

Kubelet записує журнали у файли всередині своєї налаштованої теки журналів (типово `/var/log`) і має базову теку для інших локально збережених даних (типово `/var/lib/kubelet`).

Зазвичай і `/var/lib/kubelet`, і `/var/log` знаходяться в кореневій файловій системі, і kubelet розроблений з урахуванням такої структури.

Ваш вузол може мати стільки інших файлових систем, які не використовуються для Kubernetes, скільки вам заманеться.
{{% /tab %}}
{{% tab name="Дві файлові системи" %}}
На вузлі, який ви використовуєте для тимчасових даних, що надходять від запущених Podʼів, є файлова система: журнали та томи `emptyDir`. Ви можете використовувати цю файлову систему для інших даних (наприклад, системних журналів, не повʼязаних з Kubernetes); вона може бути навіть кореневою файловою системою.

Kubelet також записує [журнали контейнерів на рівні вузла](/docs/concepts/cluster-administration/logging/#logging-at-the-node-level) у першу файлову систему і обробляє їх аналогічно тимчасовому локальному сховищу.

Ви також використовуєте окрему файлову систему, підкріплену іншим логічним пристроєм зберігання даних. У цій конфігурації тека, в якій ви вказуєте kubelet розміщувати шари образів контейнерів та шари, що підлягають запису, знаходиться в цій другій файловій системі.

Перша файлова система не містить жодних шарів образів або шарів, що підлягають запису.

Ваш вузол може мати стільки інших файлових систем, які не використовуються для Kubernetes, скільки вам заманеться.
{{% /tab %}}
{{< /tabs >}}

Kubelet може вимірювати, скільки локального сховища він використовує. Він робить це за умови, що ви налаштували вузол, використовуючи одну з підтримуваних конфігурацій для локального тимчасового сховища.

Якщо у вас інша конфігурація, kubelet не застосовує обмеження ресурсів для тимчасового локального сховища.

{{< note >}}
Kubelet відстежує томи `tmpfs` emptyDir як використання памʼяті контейнера, а не як локальне тимчасове сховище.
{{< /note >}}

{{< note >}}
Kubelet буде відстежувати лише кореневу файлову систему для тимчасового сховища. Розкладки ОС, які монтують окремий диск до `/var/lib/kubelet` або `/var/lib/containers`, не будуть правильно повідомляти про тимчасове сховище.
{{< /note >}}

## Встановлення запитів та обмежень для локального тимчасового сховища {#requests-limits}

Ви можете вказати `ephemeral-storage` для управління локальним тимчасовим сховищем. Кожен контейнер Podʼа може вказати одне або обидва з наступного:

* `spec.containers[].resources.limits.ephemeral-storage`
* `spec.containers[].resources.requests.ephemeral-storage`

Обмеження та запити для `ephemeral-storage` вимірюються в байтах. Ви можете виразити обсяг сховища як просте ціле число або як число з фіксованою комою, використовуючи один із таких суфіксів: E, P, T, G, M, k. Ви також можете використовувати еквіваленти степеня двійки: Ei, Pi, Ti, Gi, Mi, Ki. Наприклад, усі наведені нижче величини мають приблизно однакове значення:

- `128974848`
- `129e6`
- `129M`
- `123Mi`

Зверніть увагу на регістр суфіксів. Якщо ви запитуєте `400m` тимчасового сховища, це запит на 0,4 байта. Той, хто це ввів, мабуть, мав на увазі 400 мебібайтів (`400Mi`) або 400 мегабайтів (`400M`).

У наступному прикладі Pod має два контейнери. Кожен контейнер має запит на 2 ГБ локального тимчасового сховища. Кожен контейнер має обмеження в 4 ГБ локального тимчасового сховища. Отже, Pod має запит на 4 ГБ локального тимчасового сховища та обмеження в 8 ГБ локального тимчасового сховища. 500 Mi цього обмеження може бути використано томом `emptyDir`.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: app
    image: images.my-company.example/app:v4
    resources:
      requests:
        ephemeral-storage: "2Gi"
      limits:
        ephemeral-storage: "4Gi"
    volumeMounts:
    - name: ephemeral
      mountPath: "/tmp"
  - name: log-aggregator
    image: images.my-company.example/log-aggregator:v6
    resources:
      requests:
        ephemeral-storage: "2Gi"
      limits:
        ephemeral-storage: "4Gi"
    volumeMounts:
    - name: ephemeral
      mountPath: "/tmp"
  volumes:
    - name: ephemeral
      emptyDir:
        sizeLimit: 500Mi
```

## Як плануються Podʼи з запитами на тимчасове сховище {#how-pods-with-ephemeral-storage-requests-are-scheduled}

Коли ви створюєте Pod, планувальник Kubernetes вибирає вузол, на якому буде працювати Pod. Кожен вузол має максимальний обсяг локального тимчасового сховища, який він може надати для Podʼів. Докладнішу інформацію див. у розділі [Node Allocatable](/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable).

Планувальник гарантує, що сума запитів на ресурси запланованих контейнерів буде меншою за місткість вузла.

## Управління споживанням тимчасового сховища {#resource-emphemeralstorage-consumption}

Якщо kubelet управляє локальним тимчасовим сховищем як ресурсом, то kubelet вимірює використання сховища в:

- томах `emptyDir`, за винятком томів _tmpfs_ `emptyDir`
- теках, що містять журнали на рівні вузла
- шарах контейнерів, доступних для запису

Якщо Pod використовує більше тимчасового сховища, ніж ви дозволяєте, kubelet встановлює сигнал виселення, який запускає виселення Pod.

Для ізоляції на рівні контейнера, якщо шар контейнера з можливістю запису та використання журналів перевищує його обмеження сховища, kubelet позначає Pod для виселення.

Для ізоляції на рівні Podʼа kubelet обчислює загальний ліміт памʼяті Podʼа, підсумовуючи ліміти для контейнерів у цьому Pod. У цьому випадку, якщо сума використання локальної тимчасової памʼяті з усіх контейнерів, а також томів `emptyDir` Podʼа перевищує загальний ліміт памʼяті Podʼа, то kubelet також позначає Pod для виселення.

{{< caution >}}
Якщо kubelet не вимірює локальне тимчасове сховище, то Pod, який перевищує свій локальний ліміт сховища, не буде вилучений за порушення лімітів локальних ресурсів сховища.

Однак, якщо простір файлової системи для записуваних шарів контейнерів, журналів на рівні вузла або томів `emptyDir` стає недостатнім, вузол сам позначає себе {{< glossary_tooltip text="taints" term_id="taint" >}} як такий, що має недостатньо локального сховища, і ця позначка викликає вилучення будь-яких Podʼів, які не толерують цю позначку.

Дивіться підтримувані [конфігурації](#configurations) для тимчасового локального сховища.
{{< /caution >}}

Kubelet підтримує різні способи вимірювання використання сховища Podʼа:

{{< tabs name="resource-emphemeralstorage-measurement" >}}

{{% tab name="Періодичне сканування" %}}

Kubelet виконує регулярні, заплановані перевірки, які сканують кожен том `emptyDir`, теку журналів контейнера та записуваний шар контейнера.

Сканування вимірює, скільки місця використовується.

{{< note >}}
У цьому режимі kubelet не відстежує відкриті дескриптори файлів для видалених файлів.

Якщо ви (або контейнер) створюєте файл у томі `emptyDir`, щось відкриває цей файл, а ви видаляєте файл, поки він ще відкритий, то інод для видаленого файлу залишається, поки ви не закриєте цей файл, але kubelet не класифікує простір як використовуваний.

{{< /note >}}

{{% /tab %}}

{{% tab name="Квота на файлову систему проєкту" %}}

{{< feature-state feature_gate_name="LocalStorageCapacityIsolationFSQuotaMonitoring" >}}

Квоти проєктів — це функція на рівні операційної системи для управління використанням сховища у файлових системах. За допомогою Kubernetes ви можете увімкнути квоти проєктів для моніторингу використання сховища. Переконайтеся, що файлова система, яка підтримує томи `emptyDir` на вузлі, забезпечує підтримку квот проєктів. Наприклад, XFS та ext4fs пропонують квоти проєктів.

{{< note >}}
Квоти проєктів дозволяють моніторити використання сховища; вони не застосовують обмеження.
{{< /note >}}

Kubernetes використовує ідентифікатори проєктів, починаючи з `1048576`. Використовувані ідентифікатори зареєстровані в `/etc/projects` та `/etc/projid`. Якщо ідентифікатори проєктів у цьому діапазоні використовуються в системі для інших цілей, їх необхідно зареєструвати в `/etc/projects` та `/etc/projid`, щоб Kubernetes не використовував їх.

Квоти є швидшими та точнішими, ніж сканування тек. Коли тека призначається проєкту, всі файли, створені в цій теці, створюються в цьому проєкті, і ядро має лише відстежувати, скільки блоків використовується файлами в цьому проєкті. Якщо файл створено та видалено, але він має відкритий дескриптор файлу, він продовжує споживати простір. Відстеження квот точно фіксує цей простір, тоді як сканування тек пропускає простір, який використовують видалені файли.

Щоб використовувати квоти для відстеження використання ресурсів подом, под повинен знаходитися в просторі імен користувача. У просторі імен користувача ядро обмежує зміни projectID у файловій системі, забезпечуючи надійність метрик зберігання, розрахованих за допомогою квот.

Якщо ви хочете використовувати квоти проєкту, вам слід:

* Увімкнути [функціональну можливість](/docs/reference/command-line-tools-reference/feature-gates/#LocalStorageCapacityIsolationFSQuotaMonitoring) `LocalStorageCapacityIsolationFSQuotaMonitoring=true` за допомогою поля `featureGates` у [конфігурації kubelet](/docs/reference/config-api/kubelet-config.v1beta1/).

* Переконатися, що [функціональна можливість](/docs/reference/command-line-tools-reference/feature-gates/#UserNamespacesSupport) `UserNamespacesSupport` увімкнена, а ядро, реалізація CRI та середовище виконання OCI підтримують простори імен користувачів.

* Переконайтеся, що в кореневій файловій системі (або опціональній файловій системі виконання) увімкнено квоти проєктів. Усі файлові системи XFS підтримують квоти проєктів. Для файлових систем ext4 потрібно увімкнути функцію відстеження квот проєктів, коли файлова система не підключена.

  ```bash
  # For ext4, with /dev/block-device not mounted
  sudo tune2fs -O project -Q prjquota /dev/block-device
  ```

* Переконайтеся, що коренева файлова система (або опціональна файлова система виконання) змонтована з увімкненими квотами проєкту. Для XFS і ext4fs опція монтування називається `prjquota`.

Якщо ви не хочете використовувати квоти проєкту, вам слід:

* Вимкнути [функціональну можливість](/docs/reference/command-line-tools-reference/feature-gates/#LocalStorageCapacityIsolationFSQuotaMonitoring) `LocalStorageCapacityIsolationFSQuotaMonitoring` за допомогою поля `featureGates` у [конфігурації kubelet](/docs/reference/config-api/kubelet-config.v1beta1/).
{{% /tab %}}
{{< /tabs >}}

## {{% heading "whatsnext" %}}

* Прочитайте про [квоти проєктів](https://www.linux.org/docs/man8/xfs_quota.html) у XFS.
