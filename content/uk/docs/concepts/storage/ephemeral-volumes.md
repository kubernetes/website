---
title: Ефемерні томи
content_type: concept
weight: 30
---

<!-- overview -->

Цей документ описує _ефемерні томи_ в Kubernetes. Рекомендується мати знайомство
з [томами](/docs/concepts/storage/volumes/), зокрема з PersistentVolumeClaim та PersistentVolume.

<!-- body -->

Деякі застосунки потребують додаткових ресурсів зберігання, але їм не важливо, чи зберігаються ці дані постійно між перезавантаженнями. Наприклад, служби кешування часто обмежені обсягом памʼяті та можуть переміщувати рідко використовувані дані в ресурси зберігання, які є повільнішими за памʼять з мінімальним впливом на загальну продуктивність.

Інші застосунки очікують, що деякі дані тільки-для-читання будуть присутні в файлах, таких як конфігураційні дані або секретні ключі.

_Ефемерні томи_ призначені для таких сценаріїв використання. Оскільки томи слідкують за життєвим циклом Podʼа та створюються і видаляються разом з Podʼом, Podʼи можуть бути зупинені та перезапущені, не обмежуючись тим, чи доступний будь-який постійний том.

Ефемерні томи вказуються _inline_ в специфікації Podʼа, що спрощує розгортання та управління застосунками.

### Типи ефемерних томів {#types-of-ephemeral-volumes}

Kubernetes підтримує кілька різновидів ефемерних томів для різних цілей:

- [emptyDir](/docs/concepts/storage/volumes/#emptydir): порожній при запуску Podʼа, зберігання здійснюється локально з базової теки kubelet (зазвичай кореневий диск) або в ОЗП
- [configMap](/docs/concepts/storage/volumes/#configmap), [downwardAPI](/docs/concepts/storage/volumes/#downwardapi), [secret](/docs/concepts/storage/volumes/#secret): впровадження різних видів даних Kubernetes в Podʼі
- [image](/docs/concepts/storage/volumes/#image): дозволяє монтувати файли образів контейнерів або артефактів, безпосередньо у Pod.
- [CSI ефемерні томи](#csi-ephemeral-volumes):  схожі на попередні види томів, але надаються спеціальними драйверами {{< glossary_tooltip text="CSI" term_id="csi" >}}, які спеціально [підтримують цю функцію](https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html)
- [загальні ефемерні томи](#generic-ephemeral-volumes), які можуть бути надані всіма драйверами зберігання, які також підтримують постійні томи

`emptyDir`, `configMap`, `downwardAPI`, `secret` надаються як [локальне тимчасове сховище](/docs/concepts/storage/ephemeral-storage/). Вони керуються kubelet на кожному вузлі.

CSI ефемерні томи _обовʼязково_ повинні надаватися сторонніми драйверами зберігання CSI.

Загальні ефемерні томи _можуть_ надаватися сторонніми драйверами зберігання CSI, але також будь-яким іншим драйвером зберігання, який підтримує динамічне виділення томів. Деякі драйвери CSI написані спеціально для ефемерних томів CSI та не підтримують динамічного виділення: їх тоді не можна використовувати для загальних ефемерних томів.

Перевагою використання сторонніх драйверів є те, що вони можуть пропонувати функціональність, яку Kubernetes сам не підтримує, наприклад сховища з іншими характеристиками продуктивності, ніж диск, яким керує kubelet, або впровадження різних даних.

### Ефемерні томи CSI {#csi-ephemeral-volumes}

{{< feature-state for_k8s_version="v1.25" state="stable" >}}

{{< note >}}
CSI ефемерні томи підтримуються лише певною підмножиною драйверів CSI. [Список драйверів](https://kubernetes-csi.github.io/docs/drivers.html) CSI Kubernetes показує, які драйвери підтримують ефемерні томи.
{{< /note >}}

Концептуально, ефемерні томи CSI схожі на типи томів `configMap`, `downwardAPI` та `secret`: ресурси зберігання керується локально на кожному вузлі та створюються разом з іншими локальними ресурсами після того, як Pod було
заплановано на вузол. Kubernetes не має поняття про перепланування Podʼів на цьому етапі. Створення тому має бути малоймовірним, інакше запуск Podʼа застрягне. Зокрема, [планування Podʼів з урахуванням потужності ресурсів зберігання](/docs/concepts/storage/storage-capacity/) *не* підтримується для цих томів. Наразі вони також не входять до обмежень використання томів зберігання Podʼа, оскільки це є чимось, що kubelet може забезпечити лише для ресурсу зберігання, яким він управляє самостійно.

Ось приклад маніфесту для Podʼа, який використовує ефемерне зберігання CSI:

```yaml
kind: Pod
apiVersion: v1
metadata:
  name: my-csi-app
spec:
  containers:
    - name: my-frontend
      image: busybox:1.28
      volumeMounts:
      - mountPath: "/data"
        name: my-csi-inline-vol
      command: [ "sleep", "1000000" ]
  volumes:
    - name: my-csi-inline-vol
      csi:
        driver: inline.storage.kubernetes.io
        volumeAttributes:
          foo: bar
```

Атрибути тому визначають, який том підготовлює драйвер. Ці атрибути є специфічними для кожного драйвера і не стандартизовані. Дивіться документацію кожного драйвера CSI для отримання додаткових інструкцій.

### Обмеження драйверів CSI {#csi-driver-restrictions}

Ефемерні томи CSI дозволяють користувачам передавати `volumeAttributes` прямо до драйвера CSI як частину специфікації Podʼа. Драйвер CSI, який дозволяє використання `volumeAttributes`, які зазвичай обмежені для адміністраторів, НЕ підходить для використання в ефемерному томі всередині Podʼа. Наприклад, параметри, які зазвичай визначаються в StorageClass, не повинні використовуватися користувачами через ефемерні томи всередині.

Адміністратори кластера, яким потрібно обмежити драйвери CSI, які дозволяють використання вбудованих томів всередині специфікації Podʼа, можуть зробити це, виконавши наступне:

- Видаліть `Ephemeral` із `volumeLifecycleModes` в специфікації CSIDriver, що перешкоджає використанню драйвера в якості вбудованого ефемерного тому.
- Використання [admission webhook](/docs/reference/access-authn-authz/extensible-admission-controllers/) для обмеження того, як цей драйвер використовується.

### Загальні ефемерні томи {#generic-ephemeral-volumes}

{{< feature-state for_k8s_version="v1.23" state="stable" >}}

Загальні ефемерні томи схожі на томи `emptyDir` в тому сенсі, що вони надають директорію на кожен Pod для тимчасових даних, які, як правило, порожні після створення. Але вони також можуть мати додаткові функції:

- Зберігання може бути локальним або мережевим.
- Томи можуть мати фіксований розмір, який Podʼи не можуть перевищити.
- У томів може бути певні початкові дані, залежно від драйвера та параметрів.
- Підтримуються типові операції з томами, за умови, що драйвер їх підтримує, включаючи [створення знімків](/docs/concepts/storage/volume-snapshots/), [клонування](/docs/concepts/storage/volume-pvc-datasource/), [зміну розміру](/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims) та [відстеження місткості томів](/docs/concepts/storage/storage-capacity/).

Приклад:

```yaml
kind: Pod
apiVersion: v1
metadata:
  name: my-app
spec:
  containers:
    - name: my-frontend
      image: busybox:1.28
      volumeMounts:
      - mountPath: "/scratch"
        name: scratch-volume
      command: [ "sleep", "1000000" ]
  volumes:
    - name: scratch-volume
      ephemeral:
        volumeClaimTemplate:
          metadata:
            labels:
              type: my-frontend-volume
          spec:
            accessModes: [ "ReadWriteOnce" ]
            storageClassName: "scratch-storage-class"
            resources:
              requests:
                storage: 1Gi
```

### Життєвий цикл та PersistentVolumeClaim {#lifecycle-and-persistentvolumeclaim}

Ключова концепція дизайну полягає в тому, що [параметри для вимог тому](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#ephemeralvolumesource-v1-core) дозволені всередині джерела тому Podʼа. Підтримуються мітки, анотації та весь набір полів для PersistentVolumeClaim. Коли такий Pod створюється, контролер ефемерних томів створює фактичний обʼєкт PersistentVolumeClaim в тому ж просторі імен, що і Pod, та забезпечує видалення PersistentVolumeClaim
при видаленні Podʼа.

Це викликає привʼязку та/або резервування тому, або негайно, якщо {{< glossary_tooltip text="StorageClass" term_id="storage-class" >}} використовує негайне звʼязування тому, або коли Pod тимчасово запланований на вузол (`WaitForFirstConsumer` volume binding mode). Останній варіант рекомендований для загальних ефемерних томів, оскільки тоді планувальник може вибрати відповідний вузол для Podʼа. При негайному звʼязуванні планувальник змушений вибрати вузол, який має доступ до тому, якщо він доступний.

З погляду [прав власності на ресурси](/docs/concepts/architecture/garbage-collection/#owners-dependents), Pod, який має загальний ефемерний том, є власником PersistentVolumeClaim(s), які забезпечують цей ефемерний том. При видаленні Podʼа, збирач сміття Kubernetes видаляє PVC, що, як правило, спричиняє видалення тому через типову політику повторного використання класів зберігання — видалення томів. Ви можете створити квазі-ефемерне локальне зберігання за допомогою StorageClass з політикою повторного використання `retain`: ресурс зберігання існує поза життєвим циклом Podʼа, і в цьому випадку потрібно забезпечити, що очищення тому відбувається окремо.

Поки ці PVC існують, їх можна використовувати, подібно до будь-якого іншого PVC. Зокрема, їх можна вказати як джерело даних для клонування томів або створення знімків. Обʼєкт PVC також містить поточний статус тому.

### Найменування PersistentVolumeClaim {#persistentvolumeclaim-naming}

Найменування автоматично створених PVC є детермінованим: назва є комбінацією назви Podʼа і назви тому, з дефісом (`-`) посередині. У вищезазначеному прикладі назва PVC буде `my-app-scratch-volume`. Це детерміноване найменування полегшує
взаємодію з PVC, оскільки не потрібно шукати її, якщо відомі назва Podʼа та назва тому.

Детерміноване найменування також вводить потенційний конфлікт між різними Podʼами (Pod "pod-a" з томом "scratch" і інший Pod з імʼям "pod" і томом "a-scratch" обидва отримають однакове найменування PVC "pod-a-scratch") і між Podʼами та PVC, створеними вручну.

Такі конфлікти виявляються: PVC використовується лише для ефемерного тому, якщо він був створений для Podʼа. Ця перевірка базується на стосунках власності на ресурси. Наявний PVC не перезаписується або не змінюється. Проте це не вирішує конфлікт, оскільки без відповідного PVC Pod не може стартувати.

{{< caution >}}
Будьте уважні при найменуванні Podʼів та томів в тому ж просторі імен, щоб уникнути таких конфліктів.
{{< /caution >}}

### Безпека {#security}

Використання загальних ефемерних томів дозволяє користувачам створювати PVC непрямо, якщо вони можуть створювати Podʼи, навіть якщо у них немає дозволу на створення PVC безпосередньо. Адміністраторам кластера слід бути обізнаними щодо цього. Якщо це не відповідає їхньому зразку безпеки, вони повинні використовувати [admission webhook](/docs/reference/access-authn-authz/extensible-admission-controllers/), який відхиляє обʼєкти, такі як Podʼи, які мають загальний ефемерний том.

Звичайне [обмеження квоти для PVC в просторі імен](/docs/concepts/policy/resource-quotas/#storage-resource-quota) все ще застосовується, тому навіть якщо користувачам дозволено використовувати цей новий механізм, вони не можуть використовувати його для оминання інших політик.

## {{% heading "whatsnext" %}}

### Ефемерні томи, керовані kubelet {#ephemeral-volumes-managed-by-kubelet}

Див. [локальне тимчасове сховище](/docs/concepts/storage/ephemeral-storage/).

### Ефемерні томи CSI {#csi-ephemeral-volumes-1}

- Докладніша інформація про дизайн доступна у [Ефемерних Inline CSI томах KEP](https://github.com/kubernetes/enhancements/blob/ad6021b3d61a49040a3f835e12c8bb5424db2bbb/keps/sig-storage/20190122-csi-inline-volumes.md).
- Для отримання докладнішої інформації про подальший розвиток цієї функції див. [тікет #596](https://github.com/kubernetes/enhancements/issues/596).

### Загальні ефемерні томи {#generic-ephemeral-volumes-1}

- Для отримання докладнішої інформації про дизайн див. [Ефемерні загальні томи з потоковим доступом KEP](https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1698-generic-ephemeral-volumes/README.md).
