---
title: Власники та Залежності
content_type: concept
weight: 90
---

<!-- overview -->

В Kubernetes деякі {{< glossary_tooltip text="обʼєкти" term_id="object" >}} є
*власниками* інших обʼєктів. Наприклад, {{<glossary_tooltip text="ReplicaSet" term_id="replica-set">}} є власником групи Podʼів. Ці обʼєкти, якими володіють, є *залежними* від свого власника.

Власність відрізняється від [механізму міток та селекторів](/docs/concepts/overview/working-with-objects/labels/), який також використовують деякі ресурси. Наприклад, розгляньте Service, який створює обʼєкти `EndpointSlice`. Service використовує {{<glossary_tooltip text="мітки" term_id="label">}} щоби панель управління могла
визначити, які обʼєкти `EndpointSlice` використовуються для цього Service. Крім того, до міток, кожен `EndpointSlice`, який керується від імені Service, має
посилання на власника. Посилання на власника допомагають різним частинам Kubernetes уникати втручання в обʼєкти, якими вони не керують.

## Посилання на власника в специфікаціях обʼєктів {#owner-references-in-object-specifications}

Залежні обʼєкти мають поле `metadata.ownerReferences`, яке містить посилання на їх власника. Дійсне посилання на власника складається з назви обʼєкта та {{<glossary_tooltip text="UID" term_id="uid">}} в межах того ж {{<glossary_tooltip text="простору імен" term_id="namespace">}}, що й залежний обʼєкт. Kubernetes автоматично встановлює значення цього поля для обʼєктів, які є залежностями інших обʼєктів, таких як ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, та ReplicationControllers. Ви також можете налаштувати ці звʼязки вручну, змінивши значення цього поля. Однак зазвичай цього не потрібно робити, і можна дозволити Kubernetes автоматично керувати цими звʼязками.

Залежні обʼєкти також мають поле `ownerReferences.blockOwnerDeletion`, яке має булеве значення і контролює, чи можуть певні залежні обʼєкти блокувати збір сміття, що видаляє їх власника. Kubernetes автоматично встановлює це поле в `true`, якщо {{<glossary_tooltip text="контролер" term_id="controller">}} (наприклад, контролер Deployment) встановлює значення поля `metadata.ownerReferences`. Ви також можете встановити значення поля `blockOwnerDeletion` вручну, щоб контролювати, які залежні обʼєкти блокують збір сміття.

Контролер доступу Kubernetes контролює доступ користувачів для зміни цього поля для залежних ресурсів на основі прав видалення власника. Це керування перешкоджає несанкціонованим користувачам затримувати видалення обʼєкта-власника.

{{< note >}}
Посилання на власника поза межами простору імен заборонені. Залежні обʼєкти в просторі імен можуть вказувати власників або на рівні кластера, або в тому ж просторі імен. Якщо цього не відбувається, посилання на власника розглядається як відсутнє, і залежний обʼєкт може бути видалений, якщо всі власники визначено як відсутні.

Обʼєкти в просторі імен можуть вказувати тільки власників в межах кластера. У версії v1.20+, якщо обʼєкт в просторі імен вказує обʼєкт кластера як власника, він розглядається як обʼєкт з нерозвʼязаним посиланням на власника і не може бути вилучений.

У v1.20+, якщо збирач сміття виявляє недійсний перехресний простір імен `ownerReference` або залежний обʼєкт на рівні кластера з `ownerReference`, що посилається на тип простору імен, зʼявляється повідомлення з попередженням з причиною `OwnerRefInvalidNamespace` та `involvedObject` про недійсного залежного. Ви можете перевірити наявність такого роду подій (Event), запустивши `kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace`.
{{< /note >}}

## Власність та завершувачі {#ownership-and-finalizers}

Коли ви наказуєте Kubernetes видалити ресурс, сервер API дозволяє керуючому контролеру обробити будь-які [правила завершувача](/docs/concepts/overview/working-with-objects/finalizers/) для ресурсу. {{<glossary_tooltip text="Завершувачі" term_id="finalizer">}} запобігають випадковому видаленню ресурсів, які вашому кластеру можуть ще бути потрібні для коректної роботи. Наприклад, якщо ви намагаєтеся видалити [PersistentVolume](/docs/concepts/storage/persistent-volumes/), який все ще використовується Podʼом, видалення не відбувається негайно, оскільки `PersistentVolume` має завершувач `kubernetes.io/pv-protection`. Замість цього [том](/docs/concepts/storage/volumes/) залишається в стані `Terminating` до тих пір, поки Kubernetes не очистить завершувач, що відбувається тільки після того, як `PersistentVolume` більше не привʼязаний до Podʼа.

Kubernetes також додає завершувачів до ресурсу-власника, коли ви використовуєте або [переднє або інше каскадне видалення](/docs/concepts/architecture/garbage-collection/#cascading-deletion). При передньому видаленні додається завершувач `foreground`, так що контролер повинен видалити залежні ресурси, які також мають `ownerReferences.blockOwnerDeletion=true`, перш ніж він видалить власника. Якщо ви вказуєте політику видалення покинутих ресурсів (сиріт), Kubernetes додає завершувач `orphan`, так що контролер ігнорує залежні ресурси після того, як він видаляє обʼєкт-власника.

## {{% heading "whatsnext" %}}

* Дізнайтеся більше про [завершувачі Kubernetes](/docs/concepts/overview/working-with-objects/finalizers/).
* Дізнайтеся про [збір сміття](/docs/concepts/architecture/garbage-collection).
* Прочитайте API-довідник про [метадані обʼєкта](/docs/reference/kubernetes-api/common-definitions/object-meta/#System).
