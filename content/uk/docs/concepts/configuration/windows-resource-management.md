---
title: Управління ресурсами для вузлів Windows
content_type: concept
weight: 75
---

<!-- overview -->

Ця сторінка надає огляд різниці у способах управління ресурсами між Linux та Windows.

<!-- body -->

На Linux-вузлах використовуються {{< glossary_tooltip text="cgroups" term_id="cgroup" >}} як межа Pod для керування ресурсами. Контейнери створюються в межах цих груп для ізоляції мережі, процесів та файлової системи. API cgroup для Linux може використовуватися для збору статистики використання процесора, введення/виведення та памʼяті.

Натомість, у Windows використовується [_job object_](https://docs.microsoft.com/windows/win32/procthread/job-objects) на кожен контейнер з фільтром системного простору імен, щоб обмежити всі процеси в контейнері та забезпечити логічну ізоляцію від хосту. (Обʼєкти завдань є механізмом ізоляції процесів Windows і відрізняються від того, що Kubernetes називає {{< glossary_tooltip term_id="job" text="завданням" >}}).

Не існує можливості запуску контейнера Windows без фільтрації простору імен. Це означає, що системні привілеї не можуть бути встановлені в контексті хосту, і, отже, привілейовані контейнери не доступні в Windows. Контейнери не можуть припускати ідентичність хосту, оскільки менеджер облікових записів безпеки (Security Account Manager, SAM) є окремим.

## Управління памʼяттю {#resource-management-memory}

Windows не має спеціального процесу припинення процесів з обмеженням памʼяті, як у Linux. Windows завжди трактує всі виділення памʼяті в режимі користувача як віртуальні, і сторінкові файли є обовʼязковими.

Вузли Windows не перевантажують памʼять для процесів. Основний ефект полягає в тому, що Windows не досягне умов нестачі памʼяті так само як Linux, і процеси будуть перенесені на диск замість виявлення випадків нестачі памʼяті (OOM). Якщо памʼять перевантажена, і всю фізичну памʼять вичерпано, то запис на диск може знизити продуктивність.

## Управління CPU {#resource-management-cpu}

Windows може обмежувати кількість часу CPU, виділену для різних процесів, але не може гарантувати мінімальну кількість часу CPU.

У Windows kubelet підтримує прапорець командного рядка для встановлення [пріоритету планування](https://docs.microsoft.com/windows/win32/procthread/scheduling-priorities) процесу kubelet: `--windows-priorityclass`. Цей прапорець дозволяє процесу kubelet отримувати більше часових сегментів процесора порівняно з іншими процесами, які виконуються на хості Windows. Додаткову інформацію про допустимі значення та їх значення можна знайти за посиланням [Класи пріоритетів Windows](https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities#priority-class). Щоб забезпечити, що запущені Podʼи не позбавлять kubelet циклів CPU, встановіть цей прапорець на `ABOVE_NORMAL_PRIORITY_CLASS` або вище.

## Резервування ресурсів {#resource-reservation}

Щоб врахувати памʼять і CPU, які використовуються операційною системою, середовищем виконання контейнерів і процесами хосту Kubernetes, такими як kubelet, ви можете (і повинні) зарезервувати ресурси памʼяті та CPU за допомогою прапорців kubelet `--kube-reserved` та/або `--system-reserved`. У Windows ці значення використовуються лише для розрахунку [доступних](/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable) ресурсів вузла.

{{< caution >}}
При розгортанні навантажень встановлюйте ліміти ресурсів памʼяті та процесора на контейнери. Це також віднімає від `NodeAllocatable` та допомагає глобальному планувальнику кластера визначити, які Podʼи розмістити на яких вузлах.

Планування Podʼів без лімітів може перевантажити вузли Windows, і в екстремальних випадках може призвести до того, що вузли стануть несправними.
{{< /caution >}}

У Windows доброю практикою є резервування принаймні 2ГБ памʼяті.

Щоб визначити, скільки CPU резервувати, ідентифікуйте максимальну щільність Podʼів для кожного вузла та відстежуйте використання процесора системними службами, що працюють там, а потім виберіть значення, яке відповідає потребам вашої робочого навантаження.
