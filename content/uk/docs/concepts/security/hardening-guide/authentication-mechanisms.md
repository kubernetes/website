---
title: Поради з посилення безпеки — Механізми автентифікації
description: >
  Інформація про варіанти автентифікації в Kubernetes та їх властивості безпеки.
content_type: concept
weight: 90
---

<!-- overview -->

Вибір відповідного механізму автентифікації — це ключовий аспект забезпечення безпеки вашого кластера. Kubernetes надає кілька вбудованих механізмів, кожен з власними перевагами та недоліками, які потрібно ретельно розглядати при виборі найкращого механізму автентифікації для вашого кластера.

Загалом рекомендується увімкнути як можливо менше механізмів автентифікації для спрощення управління користувачами та запобігання ситуаціям, коли користувачі мають доступ до кластера, який вже не потрібен.

Важливо зауважити, що Kubernetes не має вбудованої бази даних користувачів у межах кластера. Замість цього він бере інформацію про користувача з налаштованої системи автентифікації та використовує її для прийняття рішень щодо авторизації. Тому для аудиту доступу користувачів вам потрібно переглянути дані автентифікації з кожного налаштованого джерела автентифікації.

Для операційних кластерів з кількома користувачами, які безпосередньо отримують доступ до API Kubernetes, рекомендується використовувати зовнішні джерела автентифікації, такі як OIDC. Внутрішні механізми автентифікації, такі як сертифікати клієнта та токени службових облікових записів, описані нижче, не підходять для цього випадку використання.

<!-- body -->

## Автентифікація сертифіката клієнта X.509 {#x509-client-certificate-authentication}

Kubernetes використовує [автентифікацію сертифіката клієнта X.509](/docs/reference/access-authn-authz/authentication/#x509-client-certificates) для системних компонентів, наприклад, коли Kubelet автентифікується на сервері API. Хоча цей механізм також можна використовувати для автентифікації користувачів, він може бути непридатним для операційного використання через кілька обмежень:

- Сертифікати клієнта не можуть бути індивідуально скасовані. Після компрометації сертифікат може бути використаний зловмисником до тих пір, поки не закінчиться строк його дії. Для зменшення цього ризику рекомендується налаштувати короткі строки дії для автентифікаційних даних користувача, створених за допомогою клієнтських сертифікатів.
- Якщо сертифікат потрібно анулювати, то потрібно змінити ключ сертифікації, що може призвести до ризиків доступності для кластера.
- В кластері відсутній постійний запис про створені клієнтські сертифікати. Тому всі видані сертифікати повинні бути зафіксовані, якщо вам потрібно відстежувати їх.
- Приватні ключі, що використовуються для автентифікації за допомогою клієнтського сертифіката, не можуть бути захищені паролем. Хто завгодно, хто може прочитати файл із ключем, зможе його використовувати.
- Використання автентифікації за допомогою клієнтського сертифіката потребує прямого зʼєднання від клієнта до API-сервера без будь-яких проміжних точок TLS, що може ускладнити архітектуру мережі.
- Групові дані вбудовані в значення `O` клієнтського сертифіката, що означає, що членство користувача в групах не може бути змінено впродовж дії сертифіката.

## Файл статичних токенів {#static-token-file}

Хоча Kubernetes дозволяє завантажувати облікові дані зі [файлу статичних токенів](/docs/reference/access-authn-authz/authentication/#static-token-file), розташованого на дисках вузлів панелі управління, цей підхід не рекомендується для операційних серверів з кількох причин:

- Облікові дані зберігаються у відкритому вигляді на дисках вузлів панелі управління, що може представляти ризик для безпеки.
- Зміна будь-яких облікових даних потребує перезапуску процесу API-сервера для набуття чинності, що може вплинути на доступність.
- Не існує механізму, доступного для того, щоб дозволити користувачам змінювати свої облікові дані. Для зміни облікових даних адміністратор кластера повинен змінити токен на диску та розповсюдити його серед користувачів.
- Відсутність механізму блокування, який би запобігав атакам методом підбору.

## Токени bootstrap {#bootstrap-tokens}

[Токени bootstrap](/docs/reference/access-authn-authz/bootstrap-tokens/) використовуються для приєднання вузлів до кластерів і не рекомендуються для автентифікації користувачів з кількох причин:

- Вони мають затверджені членства у групах, які не підходять для загального використання, що робить їх непридатними для цілей автентифікації.
- Ручне створення токенів bootstrap може призвести до створення слабких токенів, які може вгадати зловмисник, що може бути ризиком для безпеки.
- Відсутність механізму блокування, який би запобігав атакам методом підбору, спрощує завдання зловмисникам для вгадування або підбору токена.

## Secret токени ServiceAccount {#serviceaccount-secret-tokens}

[Secretʼи службових облікових записів](/docs/reference/access-authn-authz/service-accounts-admin/#manual-secret-management-for-serviceaccounts) доступні як опція для того, щоб дозволити робочим навантаженням, що працюють в кластері, автентифікуватися на сервері API. У версіях Kubernetes < 1.23 вони були типовою опцією, однак, їх замінюють токени API TokenRequest. Хоча ці Secretʼи можуть бути використані для автентифікації користувачів, вони, як правило, не підходять з кількох причин:
- Їм неможливо встановити термінм дії, і вони залишатимуться чинними до тих пір, поки повʼязаний з ними службовий обліковий запис не буде видалений.
- Токени автентифікації видимі будь-якому користувачеві кластера, який може читати Secretʼи в просторі імен, в якому вони визначені.
- Службові облікові записи не можуть бути додані до довільних груп, ускладнюючи управління RBAC там, де вони використовуються.

## Токени API TokenRequest {#tokenrequest-api-tokens}

API TokenRequest є корисним інструментом для генерації обмежених за часом існування автентифікаційних даних для автентифікації служб на сервері API або сторонніх системах. Проте, загалом не рекомендується використовувати їх для автентифікації користувачів, оскільки не існує методу скасування, і розподіл облікових даних користувачам у безпечний спосіб може бути складним.

При використанні токенів TokenRequest для автентифікації служб рекомендується встановити короткий термін їх дії, щоб зменшити можливі наслідки скомпрометованих токенів.

## Автентифікація з використанням токенів OpenID Connect {#openid-connect-token-authentication}

Kubernetes підтримує інтеграцію зовнішніх служб автентифікації з API Kubernetes, використовуючи [OpenID Connect (OIDC)](/docs/reference/access-authn-authz/authentication/#openid-connect-tokens). Існує велика кількість програмного забезпечення, яке можна використовувати для інтеграції Kubernetes з постачальником ідентифікації. Однак, при використанні автентифікації OIDC для Kubernetes, важливо враховувати такі заходи з забезпечення безпеки:

- Програмне забезпечення, встановлене в кластері для підтримки автентифікації OIDC, повинно бути відокремлене від загальних робочих навантажень, оскільки воно буде працювати з високими привілеями.
- Деякі керовані Kubernetes сервіси обмежені в постачальниках OIDC, які можна використовувати.
- Як і у випадку з токенами TokenRequest, токени OIDC повинні мати короткий термін дії, щоб зменшити наслідки скомпрометованих токенів.

## Автентифікація з використанням вебхуків {#webhook-token-authentication}

[Автентифікація з використанням вебхуків](/docs/reference/access-authn-authz/authentication/#webhook-token-authentication) є ще одним варіантом інтеграції зовнішніх постачальників автентифікації в Kubernetes. Цей механізм дозволяє звертатися до служби автентифікації, яка працює в кластері або зовнішньо, для прийняття рішення щодо автентифікації через вебхук. Важливо зазначити, що придатність цього механізму, ймовірно, залежатиме від програмного забезпечення, використаного для служби автентифікації, і є деякі специфічні для Kubernetes аспекти, які варто врахувати.

Для налаштування автентифікації за допомогою вебхуків потрібний доступ до файлових систем серверів панелі управління. Це означає, що це не буде можливо з керованим Kubernetes, якщо постачальник не зробить це специфічно доступним. Крім того, будь-яке програмне забезпечення, встановлене в кластері для підтримки цього доступу, повинно бути відокремлене від загальних робочих навантажень, оскільки воно буде працювати з високими привілеями.

## Автентифікуючий проксі {#authenticating-proxy}

Ще один варіант інтеграції зовнішніх систем автентифікації в Kubernetes — використання [автентифікуючого проксі](/docs/reference/access-authn-authz/authentication/#authenticating-proxy). У цьому механізмі Kubernetes очікує отримати запити від проксі з встановленими конкретними значеннями заголовків, які вказують імʼя користувача та членство в групах для призначення для цілей авторизації. Важливо зазначити, що існують певні аспекти, які слід врахувати при використанні цього механізму.

По-перше, для зменшення ризику перехоплення трафіку або атак типу sniffing між проксі та сервером API Kubernetes між ними має бути використане безпечне налаштування TLS. Це забезпечить безпеку комунікації між проксі та сервером API Kubernetes.

По-друге, важливо знати, що зловмисник, який може змінити заголовки запиту, може отримати неавторизований доступ до ресурсів Kubernetes. Тому важливо забезпечити належний захист заголовків та переконатися, що їх не можна підробити.

## {{% heading "whatsnext" %}}

- [Автентифікація користувачів](/docs/reference/access-authn-authz/authentication/)
- [Автентифікація за допомогою Bootstrap-токенів](/docs/reference/access-authn-authz/bootstrap-tokens/)
- [Автентифікація kubelet](/docs/reference/access-authn-authz/kubelet-authn-authz/#kubelet-authentication)
- [Автентифікація за допомогою токенів службових облікових записів](/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-tokens)
