---
title: "Безпека хмарних середовищ та Kubernetes"
linkTitle: "Безпека хмарних середовищ"
weight: 10

# Індекс розділу це явно вказує
hide_summary: true

description: >
  Концепції забезпечення безпеки вашого робочого навантаження в хмарному середовищі.
---

Kubernetes базується на архітектурі, орієнтованій на хмару, та використовує поради від
{{< glossary_tooltip text="CNCF" term_id="cncf" >}} щодо найкращих практик з безпеки
інформації в хмарних середовищах.

Прочитайте далі цю сторінку для отримання огляду того, як Kubernetes призначений
допомагати вам розгортати безпечну хмарну платформу.

## Інформаційна безпека хмарних середовищ {#cloud-native-information-security}

{{< comment >}}
Існують локалізовані версії цього документу; якщо ви можете посилатися на одну з них під час локалізації, це ще краще.
{{< /comment >}}

У документів CNCF [white paper](https://github.com/cncf/tag-security/tree/main/security-whitepaper) про безпеку хмарних середовищ визначаються компоненти та практики безпеки, які відповідають різним _фазам життєвого циклу_.

## Фаза життєвого циклу _Розробка_ {#lifecycle-phase-develop}

- Забезпечте цілісність середовищ розробки.
- Проєктуйте застосунки відповідно до найкращих практик інформаційної безпеки, які відповідають вашому контексту.
- Враховуйте безпеку кінцевого користувача як частину проєктного рішення.

Для досягнення цього ви можете:

1. Використовуйте архітектуру, таку як [нульова довіра](https://glossary.cncf.io/zero-trust-architecture/), яка мінімізує сферу атак, навіть для внутрішніх загроз.
2. Визначте процес перевірки коду, який враховує питання безпеки.
3. Створіть _модель загроз_ вашої системи або застосунку, яка ідентифікує межі довіри. Використовуйте цю модель, щоб ідентифікувати ризики та допомогти знайти способи їх вирішення.
4. Включіть розширену безпекову автоматизацію, таку як _fuzzing_ та [інжиніринг безпеки хаосу](https://glossary.cncf.io/security-chaos-engineering/), де це обґрунтовано.

## Фаза життєвого циклу _Розповсюдження_ {#lifecycle-phase-distribute}

- Забезпечте безпеку ланцюга постачання образів контейнерів, які ви виконуєте.
- Забезпечте безпеку ланцюга постачання кластера та інших компонентів, що виконують ваш застосунок. Прикладом іншого компонента може бути зовнішня база даних, яку ваше хмарне застосування використовує для стійкості.

Для досягнення цього:

1. Скануйте образи контейнерів та інші артефакти на наявність відомих уразливостей.
2. Забезпечте, що розповсюдження програмного забезпечення використовує шифрування у русі, з ланцюгом довіри до джерела програмного забезпечення.
3. Ухвалюйте та дотримуйтесь процесів оновлення залежностей, коли оновлення доступні особливо повʼязані з оголошеннями про безпеку.
4. Використовуйте механізми перевірки, такі як цифрові сертифікати для гарантій безпеки ланцюга постачання.
5. Підписуйтесь на стрічки та інші механізми, щоб отримувати сповіщення про безпекові ризики.
6. Обмежуйте доступ до артефактів. Розміщуйте образи контейнерів у [приватному реєстрі](/docs/concepts/containers/images/#using-a-private-registry), який дозволяє тільки авторизованим клієнтам отримувати образи.

## Фаза життєвого циклу _Розгортання_ {#lifecycle-phase-deploy}

Забезпечте відповідні обмеження на те, що можна розгортати, хто може це робити, та куди це може бути розгорнуто. Ви можете застосовувати заходи з фази _розповсюдження_, такі як перевірка криптографічної ідентичності артефактів образів контейнерів.

При розгортанні Kubernetes ви також створюєте основу для робочого середовища ваших застосунків: кластер Kubernetes (або кілька кластерів). Ця ІТ-інфраструктура повинна забезпечувати гарантії безпеки на найвищому рівні.

## Фаза життєвого циклу _Виконання_ {#lifecycle-phase-runtime}

Фаза Виконання включає три критичні області: [обчислення](#protection-runtime-compute), [доступ](#protection-runtime-access), та [зберігання](#protection-runtime-storage).

### Захист під час виконання: доступ {#protection-runtime-access}

API Kubernetes — це те, що робить ваш кластер робочим. Захист цього API є ключовим для забезпечення ефективної безпеки кластера.

Інші сторінки документації Kubernetes містять більше деталей щодо того, як налаштувати конкретні аспекти контролю доступу. [Перелік перевірок безпеки](/docs/concepts/security/security-checklist/) містить набір рекомендованих базових перевірок для вашого кластера.

Поза цим, захист вашого кластера означає впровадження ефективних [способів автентифікації](/docs/concepts/security/controlling-access/#authentication) та [авторизації](/docs/concepts/security/controlling-access/#authorization) для доступу до API. Використовуйте [ServiceAccounts](/docs/concepts/security/service-accounts/), щоб забезпечити та керувати перевірками безпеки для робочих навантажень та компонентів кластера.

Kubernetes використовує TLS для захисту трафіку API; переконайтеся, що кластер розгорнуто за допомогою TLS (включаючи трафік між вузлами та панеллю управління), та захистіть ключі шифрування. Якщо ви використовуєте власний API Kubernetes для [CertificateSigningRequests](/docs/reference/access-authn-authz/certificate-signing-requests/#certificate-signing-requests), приділіть особливу увагу обмеженню зловживань там.

### Захист під час виконання: обчислення {#protection-runtime-compute}

{{< glossary_tooltip text="Контейнери" term_id="container" >}} надають дві речі: ізоляцію між різними застосунками та механізм для комбінування цих ізольованих застосунків для запуску на одному і тому ж хост-компʼютері. Ці два аспекти, ізоляція та агрегація, означають, що безпека виконання включає компроміси та пошук відповідного балансу.

Kubernetes покладається на {{< glossary_tooltip text="програмне забезпечення виконання контейнерів" term_id="container-runtime" >}}, щоб фактично налаштувати та запустити контейнери. Проєкт Kubernetes не рекомендує конкретне програмне забезпечення виконання контейнерів, і вам слід переконатися, що вибране вами середовище виконання контейнерів відповідає вашим потребам у сфері інформаційної безпеки.

Для захисту обчислень під час виконання ви можете:

1. Застосовувати [стандарти безпеки для Pod](/docs/concepts/security/pod-security-standards/) для застосунків, щоб забезпечити їх запуск лише з необхідними привілеями.
2. Запускати спеціалізовану операційну систему на ваших вузлах, яка призначена конкретно для виконання контейнеризованих робочих навантажень. Зазвичай це базується на операційній системі з доступом тільки для читання (_незмінні образи_), яка надає тільки послуги, необхідні для виконання контейнерів.

   Операційні системи, спеціально призначені для контейнерів, допомагають ізолювати компоненти системи та представляють зменшену осяг елементів для атаки в разі "втечі" з контейнера.
3. Визначати [ResourceQuotas](/docs/concepts/policy/resource-quotas/) для справедливого розподілу спільних ресурсів та використовувати механізми, такі як [LimitRanges](/docs/concepts/policy/limit-range/) для забезпечення того, що Podʼи вказують свої вимоги до ресурсів.
4. Розподіляти робочі навантаження по різних вузлах. Використовуйте механізми [ізоляції вузлів](/docs/concepts/scheduling-eviction/assign-pod-node/#node-isolation-restriction), як від самого Kubernetes, так і від екосистеми, щоб гарантувати, що Pod з різними контекстами довіри виконуються на окремих наборах вузлів.
5. Використовуйте {{< glossary_tooltip text="програмне забезпечення виконання контейнерів" term_id="container-runtime" >}}, яке надає обмеження для підтримання безпеки.
6. На вузлах Linux використовуйте модуль безпеки Linux, такий як [AppArmor](/docs/tutorials/security/apparmor/) (бета) або [seccomp](/docs/tutorials/security/seccomp/).

### Захист під час виконання: зберігання {#protection-runtime-storage}

Для захисту сховища для вашого кластера та застосунків, що працюють там:

1. Інтегруйте свій кластер з зовнішнім втулком сховища, який надає шифрування в стані спокою для томів.
2. Увімкніть [шифрування в стані спокою](/docs/tasks/administer-cluster/encrypt-data/) для обʼєктів API.
3. Захистіть стійкість даних за допомогою резервних копій. Перевірте, що ви можете відновити їх, коли це необхідно.
4. Автентифікуйте зʼєднання між вузлами кластера та будь-яким мережевим сховищем, на яке вони спираються.
5. Впровадить шифрування даних у межах вашого власного застосунку.

Для ключів шифрування, їх генерація у спеціалізованому обладнанні забезпечує найкращий захист від ризиків розголошення. _Апаратний модуль безпеки_ може дозволити виконувати криптографічні операції без можливості копіювання
ключа безпеки в інше місце.

### Мережа та безпека {#network-and-security}

Ви також повинні врахувати заходи мережевої безпеки, такі як [NetworkPolicy](/docs/concepts/services-networking/network-policies/) або [сервісна мережа](https://glossary.cncf.io/service-mesh/). Деякі мережеві втулки для Kubernetes надають шифрування для вашої мережі кластера, використовуючи технології, такі як прошарок віртуальної приватної мережі (VPN). За концепцією, Kubernetes дозволяє використовувати власний мережевий втулок для вашого кластера (якщо ви використовуєте керований Kubernetes, особа або організація, яка керує вашим кластером, може вибрати мережевий втулок за вас).

Мережевий втулок, який ви виберете, та спосіб його інтеграції можуть сильно вплинути на безпеку інформації під час її передачі.

### Спостережність та безпека виконання {#observability-and-runtime-security}

Kubernetes дозволяє розширювати ваш кластер додатковими інструментами. Ви можете налаштувати сторонні рішення, щоб допомогти вам моніторити або усувати неполадки ваших застосунків та кластерів, на яких вони працюють. Ви також отримуєте деякі базові можливості спостережуваності, вбудовані в сам Kubernetes. Ваш код, що працює в контейнерах, може генерувати логи, публікувати метрики або надавати інші дані спостережуваності; при розгортанні вам потрібно переконатися, що ваш кластер забезпечує відповідний рівень захисту там.

Якщо ви налаштовуєте інформаційну панель метрик (дашбоард) або щось схоже, перегляньте ланцюжок компонентів, які передають дані в цю панель метрик, а також саму панель метрик. Переконайтеся, що весь ланцюжок розроблено з достатньою стійкістю та достатнім захистом цілісності, щоб ви могли покластися на нього навіть під час інциденту, коли ваш кластер може деградувати.

У відповідних випадках розгорніть заходи безпеки нижче рівня самого Kubernetes, такі як криптографічно захищений початок роботи або автентифікований розподіл часу (що допомагає забезпечити відповідність логів та записів аудиту).

Для середовища з високим рівнем безпеки розгорніть криптографічний захист, щоб переконатися, що логи є як захищеними від несанкціонованого доступу, так і конфіденційними.

## {{% heading "whatsnext" %}}

### Безпека хмарного середовища {#further-reading-cloud-native}

- Біла книга CNCF [на тему безпеки хмарного середовища](https://github.com/cncf/tag-security/tree/main/security-whitepaper).
- Біла книга CNCF [з належними практиками забезпечення безпеки ланцюга постачання програмного забезпечення](https://github.com/cncf/tag-security/blob/f80844baaea22a358f5b20dca52cd6f72a32b066/supply-chain-security/supply-chain-security-paper/CNCF_SSCP_v1.pdf).
- [Виправлення хаосу Kubernetes: розуміння безпеки починаючи від ядра і далі](https://archive.fosdem.org/2020/schedule/event/kubernetes/) (FOSDEM 2020)
- [Найкращі практики з безпеки Kubernetes](https://www.youtube.com/watch?v=wqsUfvRyYpw) (Kubernetes Forum Seoul 2019)
- [Шлях до вимірюваного завантаження з коробки](https://www.youtube.com/watch?v=EzSkU3Oecuw) (Linux Security Summit 2016)

### Kubernetes та інформаційна безпека {#further-reading-k8s}

- [Безпека Kubernetes](/docs/concepts/security/)
- [Забезпечення безпеки вашого кластера](/docs/tasks/administer-cluster/securing-a-cluster/)
- [Шифрування даних під час передачі](/docs/tasks/tls/managing-tls-in-a-cluster/) для площини керування
- [Шифрування даних в стані спокою](/docs/tasks/administer-cluster/encrypt-data/)
- [Secret в Kubernetes](/docs/concepts/configuration/secret/)
- [Керування доступом до API Kubernetes](/docs/concepts/security/controlling-access)
- [Мережеві політики](/docs/concepts/services-networking/network-policies/) для Pod-ів
- [Стандарти безпеки для Pod-ів](/docs/concepts/security/pod-security-standards/)
- [RuntimeClasses](/docs/concepts/containers/runtime-class)
