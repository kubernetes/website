---
title: Фреймворк планування
content_type: concept
weight: 60
---

<!-- overview -->

{{< feature-state for_k8s_version="v1.19" state="stable" >}}

_Фреймворк планування_ — це розширювана архітектура для планувальника Kubernetes. Вона складається з набору "втулків" API, які компілюються безпосередньо в планувальник. Ці API дозволяють реалізувати більшість функцій планування у вигляді втулків, зберігаючи при цьому основне ядро планування легким та зручним у використанні. Для отримання більш технічної інформації про дизайн цієї архітектури зверніться до [пропозиції проєкту дизайну системи планування][kep].

[kep]: https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework/README.md

## Робота фреймворку {#framework-workflow}

Фреймворк планування визначає кілька точок розширення. Втулки планувальника реєструються для виклику в одній або кількох таких точках розширення. Деякі з цих втулків можуть змінювати рішення щодо планування, а деякі надають тільки інформаційний вміст.

Кожна спроба запланувати один Pod розділяється на два етапи: **цикл планування** та **цикл привʼязки**.

### Цикл планування та цикл привʼязки {#scheduling-cycle-binding-cycle}

Цикл планування вибирає вузол для Podʼа, а цикл привʼязки застосовує це рішення до кластера. Разом цикл планування та цикл привʼязки називаються "контекстом планування".

Цикли планування виконуються послідовно, тоді як цикли привʼязки можуть виконуватися паралельно.

Цикл планування або привʼязки може бути перерваний, якщо виявлено, що Pod не може бути запланованим або якщо відбувається внутрішня помилка. Pod буде повернуто у чергу і спроба буде повторена.

## Інтерфейси {#interfaces}

Наступне зображення показує контекст планування Podʼа та інтерфейси, які надає фреймворк планування.

Один втулок може реалізовувати кілька інтерфейсів для виконання складніших завдань або завдань зі збереженням стану.

Деякі інтерфейси відповідають точкам розширення планувальника, які можна налаштувати через [Конфігурацію Планувальника](/docs/reference/scheduling/config/#extension-points).

{{< figure src="/images/docs/scheduling-framework-extensions.png" title="Точки розширення фреймворку планування" class="diagram-large">}}

### PreEnqueue {#pre-enqueue}

Ці втулки викликаються перед додаванням Podʼів до внутрішньої активної черги, де Podʼи відзначаються як готові до планування.

Тільки коли всі втулки PreEnqueue повертають `Success`, Pod допускається до внутрішньої активної черги. В іншому випадку він поміщається у відсортований список незапланованих Podʼів і не отримує умову `Unschedulable`.

Для отримання докладнішої інформації про те, як працюють внутрішні черги планувальника, прочитайте [Черга планування в kube-scheduler](https://github.com/kubernetes/community/blob/f03b6d5692bd979f07dd472e7b6836b2dad0fd9b/contributors/devel/sig-scheduling/scheduler_queues.md).

### EnqueueExtension

EnqueueExtension — це інтерфейс, де втулок може контролювати, чи потрібно повторно спробувати планування Podʼів, відхилені цим втулком, на основі змін у кластері. Втулки, які реалізують PreEnqueue, PreFilter, Filter, Reserve або Permit, повинні реалізувати цей інтерфейс.

### QueueingHint

{{< feature-state feature_gate_name="SchedulerQueueingHints" >}}

QueueingHint — це функція зворотного виклику для вирішення того, чи можна повторно включити Pod до активної черги або черги відстрочки. Вона виконується кожного разу, коли в кластері відбувається певний вид події або зміна. Коли QueueingHint виявляє, що подія може зробити Pod запланованим, Pod поміщається в активну чергу або чергу відстрочки, щоб планувальник повторно спробував спланувати Pod.

### QueueSort {#queue-sort}

Ці втулки використовуються для сортування Podʼів у черзі планування. Втулок сортування черги надає функцію `Less(Pod1, Pod2)`. Одночасно може бути включений лише один втулок сортування черги.

### PreFilter {#pre-filter}

Ці втулки використовуються для попередньої обробки інформації про Pod, або для перевірки певних умов, яким мають відповідати кластер або Pod. Якщо втулок PreFilter повертає помилку, цикл планування переривається.

### Filter

Ці втулки використовуються для відфільтрування вузлів, на яких не можна запустити Pod. Для кожного вузла планувальник буде викликати втулки фільтрації в налаштованому порядку. Якщо будь-який втулок фільтра позначає вузол як неспроможний, для цього вузла не буде викликано інші втулки. Оцінка вузлів може відбуватися паралельно.

### PostFilter {#post-filter}

Ці втулки викликаються після фази фільтрації, але лише тоді, коли не було знайдено жодного можливого вузла для Podʼа. Втулки викликаються в налаштованому порядку. Якщо будь-який втулок postFilter позначає вузол як `Schedulable`, інші втулки не будуть викликані. Типовою реалізацією PostFilter є preemption, яка намагається зробити Pod запланованим, випереджаючи інші Pods.

### PreScore {#pre-score}

Ці втулки використовуються для виконання "попередньої оцінки", яка генерує загальний стан для використання втулками Score. Якщо втулок попередньої оцінки повертає помилку, цикл планування переривається.

### Score {#scoring}

Ці втулки використовуються для ранжування вузлів, які пройшли фазу фільтрації. Планувальник викликає кожен втулок оцінювання для кожного вузла. Існує чіткий діапазон цілих чисел, який представляє мінімальні та максимальні оцінки. Після фази [NormalizeScore](#normalize-scoring), планувальник поєднує оцінки вузла з усіх втулків згідно з налаштованими коефіцієнтами втулків.

#### Оцінка сховища {#scoring-capacity}

{{< feature-state feature_gate_name="StorageCapacityScoring" >}}

У версії 1.32 для підтримки сховищ зі статичним резервуванням використовувався елемент `VolumeCapacityPriority`. Починаючи з версії 1.33, новий елемент `StorageCapacityScoring` замінює старий елемент `VolumeCapacityPriority` з додатковою підтримкою сховищ з динамічним резервуванням. Коли `StorageCapacityScoring` увімкнено, втулок VolumeBinding у kube-scheduler розширено, щоб оцінювати вузли на основі ємності сховища на кожному з них. Ця функція застосовується до томів CSI, які підтримують [Обсяг сховища](/docs/concepts/storage/storage-capacity/), включно з локальним сховищем, яке підтримується драйвером CSI.

### NormalizeScore {#normalize-scoring}

Ці втулки використовуються для модифікації оцінок перед тим, як планувальник обчислить кінцеве ранжування Вузлів. Втулок, який реєструється для цієї точки розширення, буде викликаний з результатами [Score](#scoring) від того ж втулка. Це робиться один раз для кожного втулка на один цикл планування.

Наприклад, припустимо, що втулок `BlinkingLightScorer` ранжує вузли на основі того, скільки лампочок, що блимають, в них є.

```go
func ScoreNode(_ *v1.pod, n *v1.Node) (int, error) {
    return getBlinkingLightCount(n)
}
```

Однак максимальна кількість лампочок, що блимають, може бути невеликою порівняно з `NodeScoreMax`. Щоб виправити це, `BlinkingLightScorer` також повинен реєструватися для цієї точки розширення.

```go
func NormalizeScores(scores map[string]int) {
    highest := 0
    for _, score := range scores {
        highest = max(highest, score)
    }
    for node, score := range scores {
        scores[node] = score*NodeScoreMax/highest
    }
}
```

Якщо будь-який втулок NormalizeScore повертає помилку, цикл планування припиняється.

{{< note >}}
Втулки, які бажають виконати "pre-reserve", повинні використовувати точку розширення NormalizeScore.
{{< /note >}}

### Reserve {#reserve}

Втулок, який реалізує інтерфейс Reserve, має два методи, а саме `Reserve` та `Unreserve`, які підтримують дві інформаційні фази планування, які називаються Reserve та Unreserve, відповідно. Втулки, які підтримують стан виконання (так звані "статичні втулки"), повинні використовувати ці фази для повідомлення планувальнику про те, що ресурси на вузлі резервуються та скасовуються для вказаного Podʼа.

Фаза резервування (Reserve) відбувається перед тим, як планувальник фактично привʼязує Pod до призначеного вузла. Це робиться для запобігання виникненню умов перегонів (race condition) під час очікування на успішне привʼязування. Метод `Reserve` кожного втулка Reserve може бути успішним або невдалим; якщо один виклик методу `Reserve` не вдасться, наступні втулки не виконуються, і фаза резервування вважається невдалою. Якщо метод `Reserve` всіх втулків успішний, фаза резервування вважається успішною, виконується решта циклу планування та циклу привʼязки.

Фаза скасування резервування (Unreserve) спрацьовує, якщо фаза резервування або пізніша фаза виявиться невдалою. У такому випадку метод `Unreserve` **всіх** втулків резервування буде виконано у порядку зворотному виклику методів `Reserve`. Ця фаза існує для очищення стану, повʼязаного з зарезервованим Podʼом.

{{< caution >}}
Реалізація методу `Unreserve` у втулках Reserve повинна бути ідемпотентною і не може зазнавати невдачі.
{{< /caution >}}

### Permit

Втулки _Permit_ викликаються в кінці циклу планування для кожного Podʼа, щоб запобігти або затримати привʼязку до вузла-кандидата. Втулок дозволу може робити одну з трьох речей:

1.  **approve** \
    Якщо всі втулки Permit схвалюють Pod, він відправляється для привʼязки.

2.  **deny** \
    Якщо будь-який втулок Permit відхиляє Pod, він повертається до черги планування. Це спричинить запуск фази Unreserve у [втулках Reserve](#reserve).

3.  **wait** (із таймаутом) \
    Якщо втулок Permit повертає "wait", тоді Pod залишається у внутрішньому списком "очікуючих" Podʼів, і цикл привʼязки цього Podʼа починається, але безпосередньо блокується, поки він не буде схвалений. Якщо виникає таймаут, **wait** стає **deny** і Pod повертається до черги планування, спричиняючи запуск фази Unreserve у [втулках  Reserve](#reserve).

{{< note >}}
Хоча будь-який втулок може мати доступ до списку "очікуючих" Podʼів та схвалювати їх (див. [`FrameworkHandle`](https://git.k8s.io/enhancements/keps/sig-scheduling/624-scheduling-framework#frameworkhandle)), ми очікуємо, що лише втулки Permit схвалюватимуть привʼязку зарезервованих Podʼів, які перебувають у стані "wait". Після схвалення Podʼа він відправляється до фази [PreBind](#pre-bind).
{{< /note >}}

### PreBind {#pre-bind}

Ці втулки використовуються для виконання будь-яких необхідних операцій перед привʼязкою Podʼа. Наприклад, втулок PreBind може надавати мережевий том і монтувати його на цільовому вузлі перед тим, як дозволити Podʼа запускатися там.

Якщо будь-який втулок PreBind повертає помилку, Pod [відхиляється](#reserve) і повертається до черги планування.

### Bind

Ці втулки використовуються для привʼязки Podʼа до Вузла. Втулки Bind не будуть викликані, поки всі втулки PreBind не завершаться. Кожен втулок привʼязки викликається в налаштованому порядку. Втулок привʼязки може вибрати, чи обробляти вказаний Pod. Якщо втулок привʼязки обирає Pod для опрацювання, **решта втулків привʼязки пропускаються**.

### PostBind {#post-bind}

Це інформаційний інтерфейс. Втулки PostBind викликаються після успішної привʼязки Podʼа. Це завершення циклу привʼязки та може бути використано для очищення повʼязаних ресурсів.

## API втулку {#plugin-api}

Існують два кроки в API втулку. По-перше, втулки повинні зареєструватися та отримати налаштування, а потім вони використовують інтерфейси точок розширення. Інтерфейси точок розширення мають наступну форму.

```go
type Plugin interface {
    Name() string
}

type QueueSortPlugin interface {
    Plugin
    Less(*v1.pod, *v1.pod) bool
}

type PreFilterPlugin interface {
    Plugin
    PreFilter(context.Context, *framework.CycleState, *v1.pod) error
}

// ...
```

## Налаштування втулків {#plugin-configuration}

Ви можете увімкнути або вимкнути втулки у конфігурації планувальника. Якщо ви використовуєте Kubernetes v1.18 або пізнішу версію, більшість втулків планування використовуються та є стандартно увімкненими.

Окрім стандартних втулків, ви також можете реалізувати власні втулки планування та налаштувати їх разом з стандартними втулками. Ви можете дізнатися більше на [scheduler-plugins](https://github.com/kubernetes-sigs/scheduler-plugins).

Якщо ви використовуєте Kubernetes v1.18 або пізнішу версію, ви можете налаштувати набір втулків як профіль планувальника, а потім визначити кілька профілів для різних видів робочих навантажень. Дізнайтеся більше за про [декілька профілів](/docs/reference/scheduling/config/#multiple-profiles).
