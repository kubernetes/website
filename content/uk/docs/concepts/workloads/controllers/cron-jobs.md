---
title: CronJob
api_metadata:
- apiVersion: "batch/v1"
  kind: "CronJob"
content_type: concept
description: >-
  Обʼєкт CronJob запускає Job за повторюваним графіком.
weight: 80
hide_summary: true # Listed separately in section index
---

<!-- overview -->

{{< feature-state for_k8s_version="v1.21" state="stable" >}}

_**CronJob**_ створює {{< glossary_tooltip term_id="job" text="Jobs" >}} за повторюваним графіком.

CronJob призначений для виконання регулярних запланованих дій, таких як резервне копіювання, генерація звітів та інше. Один обʼєкт CronJob подібний до одного рядка файлу _crontab_ (таблиця cron) на системі Unix. Він запускає Job періодично за заданим графіком, записаним у форматі [Cron](https://en.wikipedia.org/wiki/Cron).

У CronJob є обмеження та особливості. Наприклад, в певних обставинах один CronJob може створювати кілька одночасних Jobs. Див. [обмеження](#cron-job-limitations) нижче.

Коли планувальник створює нові Jobs і (відповідно) Podʼи для CronJob, `.metadata.name` CronJob є частиною основи для імені цих Podʼів. Назва CronJob повинна бути дійсним значенням [DNS-піддомену](/docs/concepts/overview/working-with-objects/names#dns-subdomain-names), але це може призводити до неочікуваних результатів для імен хостів Podʼів. Для найкращої сумісності назва повинна відповідати більш обмеженим правилам [DNS-мітки](/docs/concepts/overview/working-with-objects/names#dns-label-names). Навіть коли імʼя є DNS-піддоменом, імʼя не повинно бути довше 52 символів. Це тому, що контролер CronJob автоматично додає 11 символів до наданого вами імені, і існує обмеження на довжину імені Job, яке не повинно перевищувати 63 символи.

<!-- body -->

## Приклад {#example}

У цьому прикладі маніфест CronJob виводить поточний час та вітання кожну хвилину:

{{% code_sample file="application/job/cronjob.yaml" %}}

([Виконання автоматизованих завдань за допомогою CronJob](/docs/tasks/job/automated-tasks-with-cron-jobs/) докладніше описує цей приклад).

## Написання специфікації CronJob {#writing-a-cronjob-spec}

### Синтаксис розкладу {#schedule-syntax}

Поле `.spec.schedule` є обовʼязковим. Значення цього поля відповідає синтаксису [Cron](https://en.wikipedia.org/wiki/Cron):

```none
# ┌───────────── хвилина (0 - 59)
# │ ┌───────────── година (0 - 23)
# │ │ ┌───────────── день місяця (1 - 31)
# │ │ │ ┌───────────── місяць (1 - 12)
# │ │ │ │ ┌───────────── день тижня (0 - 6) (Неділя - Субота)
# │ │ │ │ │                                   АБО неділя, понеділок, вівторок, середа, четвер, пʼятниця, субота
# │ │ │ │ │
# │ │ │ │ │
# * * * * *
```

Наприклад, `0 3 * * 1` означає, що це завдання планується запускати щотижня в понеділок о 3 ранку.

Формат також включає розширені значення кроків "Vixie cron". Як пояснено в [документації FreeBSD](https://www.freebsd.org/cgi/man.cgi?crontab%285%29):

> Значення кроків можна використовувати разом із діапазонами. Після діапазону з `/ <number>` вказує пропуски значення числа через діапазон. Наприклад, `0-23/2` можна використовувати в годинах для вказівки виконання команди кожну другу годину (альтернативою в стандарті V7 є `0,2,4,6,8,10,12,14,16,18,20,22`). Після зірочки також допускаються кроки, тому, якщо ви хочете сказати "кожні дві години", просто використовуйте `*/2`.

{{< note >}}
Знак питання (`?`) у розкладі має той же зміст, що й зірочка `*`, тобто позначає будь-яке доступне значення для даного поля.
{{< /note >}}

Окрім стандартного синтаксису, також можна використовувати деякі макроси, такі як `@monthly`:

| Запис 										| Опис																												| Еквівалентно |
| ------------- 						| ------------- 																							|-------------  |
| @yearly (або @annually)		| Виконувати один раз на рік о півночі 1 січня											| 0 0 1 1 * 		|
| @monthly 									| Виконувати один раз на місяць о півночі першого дня місяця			| 0 0 1 * * 		|
| @weekly 									| Виконувати один раз на тиждень о півночі в неділю								| 0 0 * * 0 		|
| @daily (або @midnight)			| Виконувати один раз на день о півночі													| 0 0 * * * 		|
| @hourly 									| Виконувати один раз на годину на початку години								| 0 * * * * 		|

Для генерації виразів розкладу CronJob можна також використовувати вебінструменти, наприклад [crontab.guru](https://crontab.guru/).

### Шаблон завдання {#job-template}

Поле `.spec.jobTemplate` визначає шаблон для завдань, які створює CronJob, і воно обовʼязкове. Воно має точно таку ж схему, як [Job](/docs/concepts/workloads/controllers/job/), за винятком того, що воно вкладене і не має `apiVersion` або `kind`. Ви можете вказати загальні метадані для завдань, створених за шаблоном, такі як {{< glossary_tooltip text="labels" term_id="label" >}} або {{< glossary_tooltip text="annotations" term_id="annotation" >}}. Щодо інформації щодо написання `.spec` завдання, дивіться [Написання специфікації завдання](/docs/concepts/workloads/controllers/job/#writing-a-job-spec).

### Термін відстрочення для відкладеного запуску завдання {#starting-deadline}

Поле `.spec.startingDeadlineSeconds` є необовʼязковим. Це поле визначає термін (в повних секундах) для запуску завдання, якщо це завдання пропускає свій запланований час з будь-якої причини.

Після пропуску терміну CronJob пропускає цей екземпляр завдання (майбутні випадки все ще заплановані). Наприклад, якщо у вас є завдання резервного копіювання, яке запускається двічі на день, ви можете дозволити йому запускатися з запізненням до 8 годин, але не пізніше, оскільки резервна копія, виконана пізніше, буде неактуальною: ви замість цього віддавали б перевагу чекати на наступний запланований запуск.

Для завдань, які пропускають свій термін, налаштований час відстрочення, Kubernetes вважає їх завданнями, що не вдалися. Якщо ви не вказали `startingDeadlineSeconds` для CronJob, екземпляри завдань не мають терміну.

Якщо поле `.spec.startingDeadlineSeconds` встановлено (не є нульовим), контролер CronJob вимірює час між тим, коли очікується створення завдання, і зараз. Якщо різниця вище за цей ліміт, він пропускає це виконання.

Наприклад, якщо воно встановлене на `200`, це дозволяє створити завдання протягом 200 секунд після фактичного часу.

### Політика паралелізму {#concurrency-policy}

Також необовʼязкове поле `.spec.concurrencyPolicy`. Воно визначає, як обробляти паралельні виконання завдання, яке створюється цим CronJob. Специфікація може вказувати лише одну з наступних політик паралельності:

* `Allow` (станадартно): CronJob дозволяє паралельні запуски завдань
* `Forbid`: CronJob не дозволяє паралельні запуски; якщо настав час для нового запуску завдання і попередній запуск завдання ще не завершився, CronJob пропускає новий запуск завдання. Також слід зауважити, що коли попередній запуск завдання завершиться, враховується `.spec.startingDeadlineSeconds` і може призвести до нового запуску завдання.
* `Replace`: Якщо час для нового запуску завдання і попередній запуск завдання ще не завершився, CronJob замінює поточний запуск завдання новим запуском завдання.

Зверніть увагу, що політика паралелізму застосовується лише до завдань, створених цим самим CronJob. Якщо є кілька CronJob, їхні відповідні завдання завжди можуть виконуватися паралельно.

### Призупинення розкладу {#schedule-suspension}

Ви можете призупинити виконання завдань для CronJob, встановивши необовʼязкове поле `.spec.suspend` в значення true. Стандартно поле має значення false.

Це налаштування _не_ впливає на завдання, які CronJob вже розпочав.

Якщо ви встановите це поле в значення true, всі наступні виконання будуть призупинені (вони залишаються запланованими, але контролер CronJob не запускає завдання для виконання завдань), поки ви не призупините CronJob.

{{< caution >}}
Виконання, які призупинені під час запланованого часу, вважаються пропущеними завданнями. Коли `.spec.suspend` змінюється з `true` на `false` для наявного CronJob без [строку початку](#starting-deadline), пропущені завдання заплановані негайно.
{{< /caution >}}

### Обмеження історії завдань {#job-history-limit}

Поля `.spec.successfulJobsHistoryLimit` та `.spec.failedJobsHistoryLimit` вказують, скільки завершених успішних та невдалих завдань потрібно зберігати. Обидва поля є необовʼязковими.

* `.spec.successfulJobsHistoryLimit`: Це поле вказує кількість успішно завершених завдань, які слід зберігати. Стандартне значення — `3`. Встановлення цього поля на `0` не буде зберігати жодних успішних завдань.

* `.spec.failedJobsHistoryLimit`: Це поле вказує кількість невдало завершених завдань, які слід зберігати. Стандартне значення — `1`. Встановлення цього поля на `0` не буде зберігати жодних невдало завершених завдань.

Для іншого способу автоматичного прибирання завершених Завдань, дивіться [Автоматичне прибирання завершених завдань](/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically).

### Часові пояси {#time-zones}

{{< feature-state for_k8s_version="v1.27" state="stable" >}}

Для CronJob без вказаного часового поясу {{< glossary_tooltip term_id="kube-controller-manager" text="kube-controller-manager" >}} інтерпретує розклад відносно свого локального часового поясу.

Ви можете вказати часовий пояс для CronJob, встановивши `.spec.timeZone` на назву дійсного [часового поясу](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). Наприклад, встановлення `.spec.timeZone: "Etc/UTC"` вказує Kubernetes інтерпретувати графік відносно Координованого універсального часу.

В базових бінарниках включена база даних часових поясів зі стандартної бібліотеки Go і використовується як запасний варіант у разі, якщо зовнішня база даних недоступна на системі.

### Обмеження CronJob {#cron-job-limitations}

### Непідтримувані специфікації часових поясів {#unsupported-timezone-specification}

Зазначення часового поясу за допомогою змінних `CRON_TZ` або `TZ` всередині `.spec.schedule` **офіційно не підтримується** (і ніколи не підтримувалася). Якщо ви намагаєтеся встановити розклад, який включає вказівку часового поясу `TZ` або `CRON_TZ`, Kubernetes не зможе створити чи оновити ресурс і сповістить про помилку. Замість цього слід вказати часові пояси, використовуючи [поле часового поясу](#time-zones).

### Зміна параметрів CronJob {#modifying-a-cronjob}

За концепцією, у CronJob є шаблоном для _нових_ Jobs. Якщо ви модифікуєте наявний CronJob, зміни застосовуватимуться до нових Job, які почнуть виконуватися після завершення вашої модифікації. Job (і їх Podʼи), які вже почали виконуватися, продовжують працювати без змін. Іншими словами, CronJob не оновлює поточні Job, навіть якщо вони ще продовжують виконуватися.

### Створення Job {#job-creation}

CronJob створює обʼєкт Job приблизно один раз за час виконання свого розкладу. Запуск є приблизним через те, що є обставини, коли може бути створено два Job або жодного. Kubernetes намагається уникати таких ситуацій, але не повністю запобігає їм. Таким чином, Job, які ви визначаєте, повинні бути _ідемпотентними_.

Починаючи з Kubernetes v1.32, CronJobs застосовує анотацію `batch.kubernetes.io/cronjob-scheduled-timestamp` до створених завдань. Ця анотація вказує початковий запланований час створення завдання і має формат RFC3339.

Якщо `startingDeadlineSeconds` встановлено на велике значення або залишено не встановленим (типово), і якщо `concurrencyPolicy` встановлено на `Allow`, Jobs завжди будуть запускатися принаймні один раз.

{{< caution >}}
Якщо `startingDeadlineSeconds` встановлено у значення менше ніж 10 секунд, CronJob може не бути заплановано. Це повʼязано з тим, що контролер CronJob перевіряє стан справ кожні 10 секунд.
{{< /caution >}}

Для кожного CronJob контролер CronJob {{< glossary_tooltip term_id="controller" >}} перевіряє, скільки розкладів він пропустив протягом часу від його останнього запланованого часу до теперішнього часу. Якщо пропущено понад 100 розкладів, то Job не запускається, і виводиться помилка в лог.

```none
Cannot determine if job needs to be started. Too many missed start time (> 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.
```

Важливо відзначити, що якщо поле `startingDeadlineSeconds` встановлено (не є `nil`), контролер враховує, скільки пропущених Job сталося від значення `startingDeadlineSeconds` до теперішнього часу, а не від останнього запланованого часу до теперішнього часу. Наприклад, якщо `startingDeadlineSeconds` дорівнює `200`, контролер враховує, скільки Job було пропущено за останні 200 секунд.

CronJob вважається пропущеним, якщо не вдалося створити Job в запланований час. Наприклад, якщо `concurrencyPolicy` встановлено на `Forbid` і CronJob було спробовано запланувати, коли попередній Job все ще працював, то це буде враховуватися як пропущено.

Наприклад, припустимо, що CronJob встановлено для запуску нового Job кожну хвилину, починаючи з `08:30:00`, і його поле `startingDeadlineSeconds` не встановлено. Якщо контролер CronJob випадково був вимкнений з `08:29:00` по `10:21:00`, Job не буде запущено, оскільки кількість пропущених Jobs, які пропустили свій розклад, понад 100.

Для того, щоб краще проілюструвати цей концепт, припустимо, що CronJob встановлено для запуску нового Job кожну хвилину, починаючи з `08:30:00`, і його поле `startingDeadlineSeconds` встановлено на 200 секунд. Якщо контролер CronJob випадково був вимкнений протягом того ж періоду, що й у попередньому прикладі (`08:29:00` до `10:21:00`) Job все одно запуститься о 10:22:00. Це трапляється тому, що тепер контролер перевіряє, скільки пропущених розкладів сталося за останні 200 секунд (тобто 3 пропущені розклади), а не від останнього запланованого часу до теперішнього часу.

CronJob відповідає лише за створення Job, які відповідають його розкладу, а Job, зs свого боку, відповідає за управління Podʼами, які він представляє.

## {{% heading "whatsnext" %}}

* Дізнайтесь про [Podʼи](/docs/concepts/workloads/pods/) та [Job](/docs/concepts/workloads/controllers/job/), два поняття, які використовуються в CronJobs.
* Дізнайтеся більше про [формат](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-CRON_Expression_Format) поля `.spec.schedule` в CronJob.
* Щодо інструкцій зі створення та роботи з CronJobs, а також для прикладу маніфесту CronJob, дивіться [Виконання автоматизованих завдань за допомогою CronJobs](/docs/tasks/job/automated-tasks-with-cron-jobs/).
* `CronJob` є частиною Kubernetes REST API. Читайте {{< api-reference page="workload-resources/cron-job-v1" >}} API посилання для отримання докладних деталей.
