---
title: Класи якості обслуговування (Quality of Service) Podʼів
content_type: concept
weight: 85
---

<!-- overview -->

Ця сторінка вводить _класи обслуговування (Quality of Service, QoS)_ в Kubernetes та пояснює, як Kubernetes присвоює кожному Podʼа клас QoS як наслідок обмежень ресурсів, які ви вказуєте для контейнерів у цьому Podʼі. Kubernetes покладається на цю класифікацію для прийняття рішень про те, які Podʼи виводити при відсутності достатньої кількості ресурсів на вузлі.

<!-- body -->

## Класи обслуговування (QoS) {#quality-of-service-classes}

Kubernetes класифікує Podʼи, які ви запускаєте, і розподіляє кожен Pod в певний _клас обслуговування (Quality of Service, QoS)_. Kubernetes використовує цю класифікацію для впливу на те, як різні Podʼи обробляються. Kubernetes робить цю класифікацію на основі [резервів ресурсів](/docs/concepts/configuration/manage-resources-containers/) контейнерів у цьому Podʼі, а також того, як ці резерви стосуються обмежень ресурсів. Це відомо як _клас обслуговування (Quality of Service, QoS)_. Kubernetes присвоює кожному Podʼу клас QoS на основі запитів та лімітів ресурсів його складових контейнерів. Класи QoS використовуються Kubernetes для вирішення того, які Podʼи виводити з вузла, який переживає [високий тиск на вузол](/docs/concepts/scheduling-eviction/node-pressure-eviction/). Можливі класи QoS: `Guaranteed`, `Burstable` та `BestEffort`.

### Guaranteed

Podʼи, які мають клас `Guaranteed`, мають найстрогіші обмеження ресурсів і найменшу ймовірність бути виселеними. Гарантується, що їх не буде примусово завершено, доки вони не перевищать свої ліміти або доки не буде інших Podʼів з меншим пріоритетом, які можна витіснити з вузла. Вони можуть не отримувати ресурси поза вказаними лімітами. Ці Podʼи також можуть використовувати виключно власні CPU, використовуючи [політику управління CPU](/docs/tasks/administer-cluster/cpu-management-policies/#static-policy-configuration) типу `static`.

#### Критерії {#criteria}

Щоб Pod отримав клас QoS `Guaranteed`:

* У кожному контейнері Podʼа повинен бути ліміт та запит на памʼять.
* Для кожного контейнера у Podʼі ліміт памʼяті повинен дорівнювати запиту памʼяті.
* У кожному контейнері Podʼа повинен бути ліміт та запит на CPU.
* Для кожного контейнера у Podʼі ліміт CPU повинен дорівнювати запиту CPU.

Якщо ж Pod використовує [ресурси на рівні Podʼа](/docs/concepts/configuration/manage-resources-containers/#pod-level-resource-specification):

{{< feature-state feature_gate_name="PodLevelResources" >}}

* Pod повинен мати обмеження памʼяті на рівні Podʼа і запит на памʼять, і їхні значення повинні бути рівними.
* Pod повинен мати обмеження та запит на використання процесора на рівні Podʼа, і їхні значення повинні бути рівними.

### Burstable

Podʼи, які мають клас `Burstable`, мають гарантії ресурсів на основі запиту, але не вимагають конкретного ліміту. Якщо ліміт не вказано, він типово встановлюється рівним потужності вузла, що дозволяє Podʼам гнучко збільшувати свої ресурси, якщо це можливо. У разі виселення Podʼа через високий тиск на вузол ці Podʼи виселяються лише після виселення всіх Podʼів з класом `BestEffort`. Оскільки `Burstable` Pod може містити контейнер, який не має лімітів чи запитів ресурсів, Pod з класом `Burstable` може намагатися використовувати будь-яку кількість ресурсів вузла.

#### Критерії {#criteria-1}

Pod отримує клас QoS `Burstable`, якщо:

* Pod не відповідає критеріям класу QoS `Guaranteed`.
* Принаймні один Контейнер у Podʼі має запит або обмеження щодо памʼіяті чи CPU, або Pod має запит або обмеження щодо памʼяті чи CPU на рівні Pod.

### BestEffort

Podʼи в класі `BestEffort` можуть використовувати ресурси вузла, які не призначені спеціально для Podʼів інших класів QoS. Наприклад, якщо у вузлі є 16 ядер CPU, і ви призначили 4 ядра CPU під Pod із класом `Guaranteed`, тоді Pod з класом `BestEffort` може намагатися використовувати будь-яку кількість решти з 12 ядер CPU.

Kubelet віддає перевагу виселенню Podʼів з класом `BestEffort`, якщо вузол потрапляє в стан тиску на ресурси.

#### Критерії {#criteria-2}

Pod має клас QoS `BestEffort`, якщо він не відповідає критеріям а ні `Guaranteed`, а ні `Burstable`. Іншими словами, Pod має клас `BestEffort` лише в тому випадку, якщо жоден з контейнерів у Podʼі не має ліміту або запиту памʼяті, і жоден з контейнерів у Podʼі не має ліміту або запиту CPU, а Pod не має жодних обмежень або запитів щодо памʼяті або CPU на рівні Podʼа. Контейнери в Podʼі можуть запитувати інші ресурси (не CPU чи памʼять) і все одно класифікуватися як `BestEffort`.

## QoS памʼяті з cgroup v2 {#memory-qos-with-cgroup-v2}

{{< feature-state feature_gate_name="MemoryQoS" >}}

QoS памʼяті використовує контролер памʼяті cgroup v2 для гарантування ресурсів памʼяті в Kubernetes. Запити та ліміти памʼяті контейнерів у Podʼі використовуються для встановлення конкретних інтерфейсів `memory.min` та `memory.high`, які надає контролер памʼяті. Коли `memory.min` встановлено на запити памʼяті, ресурси памʼяті резервуються і ніколи не звільняються ядром; саме так QoS памʼяті забезпечує наявність памʼяті для Podʼів Kubernetes. Якщо в контейнері встановлено ліміти памʼяті, це означає, що системі потрібно обмежити використання памʼяті контейнера; QoS памʼяті використовує `memory.high` для обмеження роботи навантаження, що наближається до свого ліміту памʼяті, забезпечуючи, що систему не перевантажено миттєвим виділенням памʼяті.

QoS памʼяті покладається на клас QoS для визначення того, які налаштування застосовувати; проте це різні механізми, які обидва надають контроль за якістю обслуговування.

## Деяка поведінка незалежна від класу QoS {#class-independent-behavior}

Деяка поведінка є незалежною від класу QoS, який визначає Kubernetes. Наприклад:

* Будь-який контейнер, що перевищує ліміт ресурсів, буде завершено та перезапущено kubelet без впливу на інші контейнери в цьому Podʼі.

* Якщо контейнер перевищує свій запит ресурсу і вузол, на якому він працює, стикається з нестачею ресурсів, Pod, в якому він перебуває, стає кандидатом для [виселення](/docs/concepts/scheduling-eviction/node-pressure-eviction/). Якщо це станеться, всі контейнери в цьому Podʼі будуть завершені. Kubernetes може створити новий Pod, зазвичай на іншому вузлі.

* Запит ресурсів Podʼа дорівнює сумі запитів ресурсів його компонентних контейнерів, а ліміт Podʼа дорівнює сумі лімітів ресурсів його контейнерів.

* Планувальник kube-scheduler не враховує клас QoS при виборі того, які Podʼи [випереджати](/docs/concepts/scheduling-eviction/pod-priority-preemption/#preemption). Випередження може відбуватися, коли кластер не має достатньо ресурсів для запуску всіх визначених вами Podʼів.

* Клас QoS визначається під час створення Podʼа і залишається незмінним протягом усього терміну існування Podʼа. Якщо пізніше ви спробуєте виконати [зміну розміру на місці](/docs/concepts/workloads/pods/pod-lifecycle/#pod-resize), що призведе до зміни класу QoS, зміна розміру буде відхилена під час перевірки допуску.

## {{% heading "whatsnext" %}}

* Дізнайтеся про [управління ресурсами для Podʼів та контейнерів](/docs/concepts/configuration/manage-resources-containers/).
* Дізнайтеся про [виселення через тиск на вузол](/docs/concepts/scheduling-eviction/node-pressure-eviction/).
* Дізнайтеся про [пріоритет Podʼів та випередження](/docs/concepts/scheduling-eviction/pod-priority-preemption/).
* Дізнайтеся про [розлад Podʼів](/docs/concepts/workloads/pods/disruptions/).
* Дізнайтеся, як [призначати ресурси памʼяті контейнерам та Podʼам](/docs/tasks/configure-pod-container/assign-memory-resource/).
* Дізнайтеся, як [призначати ресурси CPU контейнерам та Podʼам](/docs/tasks/configure-pod-container/assign-cpu-resource/).
* Дізнайтеся, як [налаштовувати клас обслуговування для Podʼів](/docs/tasks/configure-pod-container/quality-service-pod/).
