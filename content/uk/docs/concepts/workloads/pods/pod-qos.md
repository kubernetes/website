---
title: Класи якості обслуговування (Quality of Service) Podʼів
content_type: concept
weight: 85
---

<!-- overview -->

Ця сторінка вводить _класи обслуговування (Quality of Service, QoS)_ в Kubernetes та пояснює, як Kubernetes присвоює кожному Podʼу клас QoS як наслідок обмежень ресурсів, які ви вказуєте для контейнерів у цьому Podʼі. Kubernetes покладається на цю класифікацію для прийняття рішень про те, які Podʼи виводити при відсутності достатньої кількості ресурсів на вузлі.

<!-- body -->

## Класи обслуговування (QoS) {#quality-of-service-classes}

Kubernetes класифікує Podʼи, які ви запускаєте, і розподіляє кожен Pod в певний _клас обслуговування (Quality of Service, QoS)_. Kubernetes використовує цю класифікацію для впливу на те, як різні Podʼи обробляються. Kubernetes робить цю класифікацію на основі [резервів ресурсів](/docs/concepts/configuration/manage-resources-containers/) контейнерів у цьому Podʼі, а також того, як ці резерви стосуються обмежень ресурсів. Це відомо як _клас обслуговування (Quality of Service, QoS)_. Kubernetes присвоює кожному Podʼу клас QoS на основі запитів та лімітів ресурсів його складових контейнерів. Класи QoS використовуються Kubernetes для вирішення того, які Podʼи виводити з вузла, який переживає [високий тиск на вузол](/docs/concepts/scheduling-eviction/node-pressure-eviction/). Можливі класи QoS: `Guaranteed`, `Burstable` та `BestEffort`.

### Guaranteed

Podʼи, які мають клас `Guaranteed`, мають найстрогіші обмеження ресурсів і найменше ймовірності бути виведеними. Гарантується, що їх не буде примусово завершено, доки вони не перевищать свої ліміти або доки не буде інших Podʼів з меншим пріоритетом, які можна витіснити з вузла. Вони можуть не отримувати ресурси поза вказаними лімітами. Ці Podʼи також можуть використовувати виключно власні CPU, використовуючи [політику управління CPU](/docs/tasks/administer-cluster/cpu-management-policies/#static-policy) типу `static`.

#### Критерії {#criteria}

Щоб Pod отримав клас QoS `Guaranteed`:

* У кожному контейнері Podʼа повинен бути ліміт та запит на памʼять.
* Для кожного контейнера у Podʼі ліміт памʼяті повинен дорівнювати запиту памʼяті.
* У кожному контейнері Podʼа повинен бути ліміт та запит на CPU.
* Для кожного контейнера у Podʼі ліміт CPU повинен дорівнювати запиту CPU.

### Burstable

Podʼи, які мають клас `Burstable`, мають гарантії ресурсів на основі запиту, але не вимагають конкретного ліміту. Якщо ліміт не вказано, він типово встановлюється рівним потужності вузла, що дозволяє Podʼам гнучко збільшувати свої ресурси, якщо це можливо. У разі виведення Podʼа через високий тиск на вузол ці Podʼи виводяться лише після виведення всіх Podʼів з класом `BestEffort`. Оскільки `Burstable` Pod може містити контейнер, який не має лімітів чи запитів ресурсів, Pod з класом `Burstable` може намагатися використовувати будь-яку кількість ресурсів вузла.

#### Критерії {#criteria-1}

Pod отримує клас QoS `Burstable`, якщо:

* Pod не відповідає критеріям класу QoS `Guaranteed`.
* Принаймні один контейнер у Podʼі має запит або ліміт пам\яті або CPU.

### BestEffort

Podʼи в класі `BestEffort` можуть використовувати ресурси вузла, які не призначені спеціально для Podʼів інших класів QoS. Наприклад, якщо у вузлі є 16 ядер CPU, і ви призначили 4 ядра CPU під Pod із класом `Guaranteed`, тоді Pod з класом `BestEffort` може намагатися використовувати будь-яку кількість решти з 12 ядер CPU.

Kubelet віддає перевагу виведенню Podʼів з класом `BestEffort`, якщо вузол потрапляє в стан тиску на ресурси.

#### Критерії {#criteria-2}

Pod має клас QoS `BestEffort`, якщо він не відповідає критеріям ані `Guaranteed`, ані `Burstable`. Іншими словами, Pod має клас `BestEffort` лише в тому випадку, якщо жоден з контейнерів у Podʼі не має ліміту або запиту памʼяті, і жоден з контейнерів у Podʼі не має ліміту або запиту CPU. Контейнери в Podʼі можуть запитувати інші ресурси (не CPU чи памʼять) і все одно класифікуватися як `BestEffort`.

## QoS памʼяті з cgroup v2 {#memory-qos-with-cgroup-v2}

{{< feature-state feature-gate-name="MemoryQoS" >}}

QoS памʼяті використовує контролер памʼяті cgroup v2 для гарантування ресурсів памʼяті в Kubernetes. Запити та ліміти памʼяті контейнерів у Podʼі використовуються для встановлення конкретних інтерфейсів `memory.min` та `memory.high`, які надає контролер памʼяті. Коли `memory.min` встановлено на запити памʼяті, ресурси памʼяті резервуються і ніколи не звільняються ядром; саме так QoS памʼяті забезпечує наявність памʼяті для Podʼів Kubernetes. Якщо в контейнері встановлено ліміти памʼяті, це означає, що системі потрібно обмежити використання памʼяті контейнера; QoS памʼяті використовує `memory.high` для обмеження роботи навантаження, що наближається до свого ліміту памʼяті, забезпечуючи, що систему не перевантажено миттєвим виділенням памʼяті.

QoS памʼяті покладається на клас QoS для визначення того, які налаштування застосовувати; проте це різні механізми, які обидва надають контроль за якістю обслуговування.

## Деяка поведінка незалежна від класу QoS {#class-independent-behavior}

Деяка поведінка є незалежною від класу QoS, який визначає Kubernetes. Наприклад:

* Будь-який контейнер, що перевищує ліміт ресурсів, буде завершено та перезапущено kubelet без впливу на інші контейнери в цьому Podʼі.

* Якщо контейнер перевищує свій запит ресурсу і вузол, на якому він працює, стикається з нестачею ресурсів, Pod, в якому він перебуває, стає кандидатом для [виведення](/docs/concepts/scheduling-eviction/node-pressure-eviction/). Якщо це станеться, всі контейнери в цьому Podʼі будуть завершені. Kubernetes може створити новий Pod, зазвичай на іншому вузлі.

* Запит ресурсів Podʼа дорівнює сумі запитів ресурсів його компонентних контейнерів, а ліміт Podʼа дорівнює сумі лімітів ресурсів його контейнерів.

* Планувальник kube-scheduler не враховує клас QoS при виборі того, які Podʼи [витісняти](/docs/concepts/scheduling-eviction/pod-priority-preemption/#preemption). Витіснення може відбуватися, коли кластер не має достатньо ресурсів для запуску всіх визначених вами Podʼів.

## {{% heading "whatsnext" %}}

* Дізнайтеся про [управління ресурсами для Podʼів та контейнерів](/docs/concepts/configuration/manage-resources-containers/).
* Дізнайтеся про [виведення через тиск на вузол](/docs/concepts/scheduling-eviction/node-pressure-eviction/).
* Дізнайтеся про [пріоритет Podʼів та витіснення](/docs/concepts/scheduling-eviction/pod-priority-preemption/).
* Дізнайтеся про [виведення Podʼів](/docs/concepts/workloads/pods/disruptions/).
* Дізнайтеся, як [призначати ресурси памʼяті контейнерам та Podʼам](/docs/tasks/configure-pod-container/assign-memory-resource/).
* Дізнайтеся, як [призначати ресурси CPU контейнерам та Podʼам](/docs/tasks/configure-pod-container/assign-cpu-resource/).
* Дізнайтеся, як [налаштовувати клас обслуговування для Podʼів](/docs/tasks/configure-pod-container/quality-service-pod/).
