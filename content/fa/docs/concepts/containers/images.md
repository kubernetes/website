---
reviewers:
- xirehat
title: ایمیج‌ها
content_type: concept
weight: 10
hide_summary: true # Listed separately in section index
---

<!-- overview -->

یک ایمیج کانتینر نشان‌دهندهٔ داده‌های باینری است که یک برنامه و همهٔ وابستگی‌های نرم‌افزاری آن را در بر می‌گیرد. ایمیج‌های کانتینر بسته‌های نرم‌افزاری اجرایی هستند که می‌توانند به‌صورت مستقل اجرا شوند و مفروضات بسیار دقیقی دربارهٔ محیط اجرای خود داشته باشند.

شما معمولاً ایمیج کانتینر برنامهٔ خود را ایجاد و آن را به یک رجیستری پوش می‌کنید، سپس پیش از ارجاع به آن در یک {{< glossary_tooltip text="Pod" term_id="pod" >}}، از آن استفاده می‌کنید.

این صفحه نمای کلی‌ای از مفهوم ایمیج کانتینر ارائه می‌دهد.

{{< note >}}
اگر به دنبال ایمیج‌های کانتینر برای یک نسخهٔ کوبرنتیز (مانند v{{< skew latestVersion >}}، آخرین ریزنسخه) هستید، به [دانلود کوبرنتیز](https://kubernetes.io/releases/download/) مراجعه کنید.
{{< /note >}}
<!-- body -->

## نام‌های ایمیج

به ایمیج‌های کانتینر معمولاً نام‌هایی مانند `pause`، `example/mycontainer` یا `kube-apiserver` اختصاص داده می‌شود.  
ایمیج‌ها می‌توانند شامل نام میزبان رجیستری نیز باشند؛ برای مثال:  
`fictional.registry.example/imagename`  
و حتی ممکن است یک شماره پورت نیز اضافه شود؛ برای مثال:  
`fictional.registry.example:10443/imagename`

اگر نام میزبان رجیستری را مشخص نکنید، Kubernetes فرض می‌کند که منظور شما [رجیستری عمومی Docker](https://hub.docker.com/) است.  
می‌توانید این رفتار را با تنظیم یک رجیستری ایمیج پیش‌فرض در پیکربندی  
[زمان‌اجرای کانتینر](/docs/setup/production-environment/container-runtimes/)  
تغییر دهید.

پس از بخش نام ایمیج، می‌توانید یک _tag_ یا _digest_ اضافه کنید (دقیقا مانند زمانی که با دستورات `docker` یا `podman` کار می‌کنید).  
تگ‌ها به شما امکان می‌دهند نسخه‌های مختلف از یک سری ایمیج را شناسایی کنید.  
دایجست‌ها (digests) شناسه‌ای یکتا برای یک نسخهٔ مشخص از ایمیج هستند.  
دایجست‌ها هش محتوای ایمیج بوده و تغییرناپذیرند.  
تگ‌ها می‌توانند به ایمیج‌های مختلف اشاره کنند، اما دایجست‌ها ثابت هستند.

تگ‌های ایمیج از حروف کوچک و بزرگ، ارقام، زیرخط (`_`)، نقطه (`.`) و خط تیره (`-`) تشکیل شده‌اند.  
طول تگ می‌تواند تا ۱۲۸ نویسه باشد و باید با الگوی زیر مطابق باشد:  

[a-zA-Z0-9_][a-zA-Z0-9._-]{0,127}

برای مطالعهٔ بیشتر و مشاهدهٔ عبارت باقاعدهٔ اعتبارسنجی، به  
[OCI Distribution Specification](https://github.com/opencontainers/distribution-spec/blob/master/spec.md#workflow-categories)  
مراجعه کنید.  
اگر تگی مشخص نکنید، Kubernetes فرض می‌کند منظور شما تگ `latest` است.

دایجست‌های ایمیج شامل یک الگوریتم هش (مانند `sha256`) و یک مقدار هش هستند. برای مثال:  

sha256:1ff6c18fbef2045af6b9c16bf034cc421a29027b800e4f9b68ae9b1cb3e9ae07

برای اطلاعات بیشتر دربارهٔ فرمت دایجست، به  
[OCI Image Specification](https://github.com/opencontainers/image-spec/blob/master/descriptor.md#digests)  
مراجعه کنید.

نمونه‌هایی از نام‌های ایمیجی که Kubernetes می‌تواند استفاده کند:

- `busybox` — فقط نام ایمیج، بدون تگ یا دایجست. Kubernetes از رجیستری عمومی Docker و تگ latest استفاده می‌کند. معادل `docker.io/library/busybox:latest`.  
- `busybox:1.32.0` — نام ایمیج به‌علاوه تگ. Kubernetes از رجیستری عمومی Docker استفاده می‌کند. معادل `docker.io/library/busybox:1.32.0`.  
- `registry.k8s.io/pause:latest` — نام ایمیج با رجیستری سفارشی و تگ latest.  
- `registry.k8s.io/pause:3.5` — نام ایمیج با رجیستری سفارشی و تگ غیر-latest.  
- `registry.k8s.io/pause@sha256:1ff6c18fbef2045af6b9c16bf034cc421a29027b800e4f9b68ae9b1cb3e9ae07` — نام ایمیج به‌همراه دایجست.  
- `registry.k8s.io/pause:3.5@sha256:1ff6c18fbef2045af6b9c16bf034cc421a29027b800e4f9b68ae9b1cb3e9ae07` — نام ایمیج با تگ و دایجست. در زمان pull، فقط دایجست استفاده می‌شود.  

## به‌روزرسانی ایمیج‌ها

هنگامی که برای اولین بار یک {{< glossary_tooltip text="Deployment" term_id="deployment" >}}، {{< glossary_tooltip text="StatefulSet" term_id="statefulset" >}}، پاد یا هر شیء دیگری که شامل یک PodTemplate است را ایجاد می‌کنید و سیاست کشیدن (pull policy) به‌طور صریح مشخص نشده باشد، به‌طور پیش‌فرض سیاست کشیدن تمام کانتینرهای آن پاد روی `IfNotPresent` تنظیم می‌شود. این سیاست باعث می‌شود kubelet در صورتی که ایمیج قبلاً وجود داشته باشد، از کشیدن آن صرف‌نظر کند.

### سیاست دریافت ایمیج

مقدار `imagePullPolicy` برای یک کانتینر و تگ ایمیج هر دو بر _زمانی_ که kubelet تلاش می‌کند ایمیج مشخص‌شده را بکشد (دانلود کند) تأثیر می‌گذارند.

در اینجا فهرستی از مقادیری که می‌توانید برای `imagePullPolicy` تنظیم کنید و تأثیرات هر یک آمده است:

`IfNotPresent`  
: ایمیج تنها در صورتی کشیده می‌شود که قبلاً به‌صورت محلی موجود نباشد.

`Always`  
: هر بار که kubelet یک کانتینر را راه‌اندازی می‌کند، kubelet از رجیستری ایمیج کانتینر برای حل نام به یک  
  [دایجست](https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier)  
  استفاده می‌کند. اگر kubelet قبلاً ایمیجی با آن دایجست دقیق را در کش محلی داشته باشد، از همان کش استفاده می‌کند؛  
  در غیر این صورت، ایمیجی با دایجست حل‌شده را می‌کشد و با آن کانتینر را راه‌اندازی می‌کند.

`Never`  
: kubelet تلاش به دریافت ایمیج نمی‌کند. اگر ایمیج به‌هرصورت قبلاً به‌صورت محلی موجود باشد، kubelet سعی می‌کند کانتینر را  
  اجرا کند؛ در غیر این صورت، راه‌اندازی با شکست مواجه می‌شود. برای جزئیات بیشتر به بخش [ایمیج‌های از پیش کش‌شده](#pre-pulled-images) مراجعه کنید.

سمانتیک کشing (cache) ارائه‌دهندهٔ ایمیج زیرین باعث می‌شود حتی `imagePullPolicy: Always` نیز کارآمد باشد  
تا زمانی که رجیستری به‌طور قابل‌اعتمادی در دسترس باشد. زمان‌اجرای کانتینر شما می‌تواند تشخیص دهد که لایه‌های  
ایمیج قبلاً روی نود وجود دارند تا دوباره دانلود نشوند.

{{< note >}}  
در محیط تولید از تگ `:latest` خودداری کنید، زیرا ردیابی نسخهٔ در حال اجرا دشوارتر است و بازگشت به نسخهٔ قبلی پیچیده‌تر می‌شود.  

به جای آن از تگی معنادار مانند `v1.42.0` و/یا دایجست استفاده کنید.  
{{< /note >}}

برای اطمینان از اینکه پاد همیشه از یک نسخهٔ مشخص از ایمیج استفاده کند، می‌توانید دایجست ایمیج را مشخص کنید؛  
`<image-name>:<tag>` را با `<image-name>@<digest>` جایگزین کنید  
(مثال: `image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2`).

هنگام استفاده از تگ‌ها، اگر رجیستری ایمیج کد مربوط به آن تگ را تغییر دهد، ممکن است پادهای شما ترکیبی از کد قدیمی و جدید اجرا کنند.  
دایجست ایمیج یک نسخهٔ یکتا را مشخص می‌کند، بنابراین هر بار که Kubernetes با آن نام و دایجست ایمیج، کانتینری را اجرا کند،  
کد یکسانی راه‌اندازی خواهد شد. مشخص کردن ایمیج با دایجست باعث قفل شدن کدی می‌شود که اجرا می‌کنید،  
به‌طوری که تغییر در رجیستری نتواند منجر به اجرای همزمان نسخه‌های متفاوت شود.

کنترل‌کننده‌های ورود ثالث ([admission controllers](/docs/reference/access-authn-authz/admission-controllers/)) وجود دارند که  
هنگام ایجاد پاد (و PodTemplate) آن‌ها را اصلاح می‌کنند تا بارکاری در حال اجرا بر اساس دایجست ایمیج  
و نه تگ تعریف شود. این ممکن است مفید باشد اگر بخواهید تمام بارکاری خود را تضمین کنید  
که همیشه کد یکسانی اجرا کند، صرف‌نظر از تغییرات تگ در رجیستری.

#### سیاست پیش‌فرض کشیدن ایمیج {#imagepullpolicy-defaulting}

وقتی شما (یا یک کنترلر) پادی جدید را به API سرور ارسال می‌کنید، خوشه زمانی که شرایط مشخصی برقرار باشد، فیلد `imagePullPolicy` را تنظیم می‌کند:

- اگر فیلد `imagePullPolicy` را حذف کنید و دایجست ایمیج کانتینر را مشخص کنید، `imagePullPolicy` به‌طور خودکار روی `IfNotPresent` تنظیم می‌شود.
- اگر فیلد `imagePullPolicy` را حذف کنید و تگ ایمیج کانتینر `:latest` باشد، `imagePullPolicy` به‌طور خودکار روی `Always` تنظیم می‌شود.
- اگر فیلد `imagePullPolicy` را حذف کنید و تگی برای ایمیج کانتینر مشخص نکنید، `imagePullPolicy` به‌طور خودکار روی `Always` تنظیم می‌شود.
- اگر فیلد `imagePullPolicy` را حذف کنید و تگی غیر از `:latest` برای ایمیج کانتینر مشخص کنید، `imagePullPolicy` به‌طور خودکار روی `IfNotPresent` تنظیم می‌شود.

{{< note >}}
مقدار `imagePullPolicy` کانتینر همیشه هنگام _ایجاد_ اولیهٔ شیء تنظیم می‌شود و در صورت تغییر بعدی تگ یا دایجست ایمیج، به‌روزرسانی نمی‌گردد.

برای مثال، اگر یک Deployment با ایمیجی ایجاد کنید که تگش _نه_ `:latest` باشد و سپس آن Deployment را بروزرسانی کنید تا تگش به `:latest` تغییر یابد، فیلد `imagePullPolicy` _تغییر نخواهد کرد_ تا `Always`. برای تغییر سیاست کشیدن، باید پس از ایجاد اولیهٔ هر شیء به‌صورت دستی آن را تنظیم کنید.
{{< /note >}}

#### کشیدن اجباری ایمیج

اگر می‌خواهید همیشه کشیدن ایمیج را اجباری کنید، می‌توانید یکی از اقدامات زیر را انجام دهید:

- `imagePullPolicy` کانتینر را روی `Always` تنظیم کنید.  
- `imagePullPolicy` را حذف کنید و از `:latest` به‌عنوان تگ ایمیج استفاده کنید؛ Kubernetes هنگام ارسال پاد، سیاست را به `Always` تنظیم می‌کند.  
- `imagePullPolicy` و تگ ایمیج را حذف کنید؛ Kubernetes هنگام ارسال پاد، سیاست را به `Always` تنظیم می‌کند.  
- کنترل‌کننده admission [AlwaysPullImages](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) را فعال کنید.

### ImagePullBackOff

وقتی kubelet برای پاد کانتینر می‌سازد، ممکن است کانتینر در وضعیت [Waiting](/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting) به‌خاطر `ImagePullBackOff` قرار گیرد.

وضعیت `ImagePullBackOff` به این معنی است که کانتینر نتوانسته شروع به کار کند زیرا Kubernetes نتوانسته ایمیج کانتینر را بکشد (برای دلایلی مانند نام نامعتبر ایمیج یا تلاش برای دریافت از رجیستری خصوصی بدون `imagePullSecret`). قسمت `BackOff` نشان می‌دهد که Kubernetes با تأخیر افزایشی همچنان تلاش به دریافت ایمیج خواهد کرد.

Kubernetes تأخیر بین هر تلاش را افزایش می‌دهد تا به حد مشخصی برسد که برابر ۳۰۰ ثانیه (۵ دقیقه) است.

### دریافت ایمیج بر اساس کلاس زمان‌اجرا

{{< feature-state feature_gate_name="RuntimeClassInImageCriApi" >}}  
Kubernetes از نسخه آلفا، پشتیبانی از دریافت ایمیج را بر اساس کلاس زمان‌اجرا (RuntimeClass) یک پاد ارائه می‌دهد.

اگر [feature gate](/docs/reference/command-line-tools-reference/feature-gates/)  
`RuntimeClassInImageCriApi` را فعال کنید، kubelet ایمیج‌های کانتینر را بر اساس زوج نام ایمیج و هندلر زمان‌اجرا (runtime handler) مرجع می‌دهد، نه فقط نام ایمیج یا دایجست.  
زمان‌اجرای شما ({{< glossary_tooltip text="container runtime" term_id="container-runtime" >}}) ممکن است رفتار خود را بر اساس هندلر انتخاب‌شده تنظیم کند.  
دریافت ایمیج بر اساس کلاس زمان‌اجرا برای کانتینرهای مبتنی بر ماشین مجازی، مانند کانتینرهای Windows Hyper-V، مفید است.

## دریافت سریالی و موازی ایمیج‌ها

به‌طور پیش‌فرض، kubelet ایمیج‌ها را سریالی (متوالی) می‌کشد. یعنی kubelet تنها یک درخواست دریافت ایمیج را در یک زمان به سرویس ایمیج ارسال می‌کند. سایر درخواست‌ها باید تا پایان پردازش درخواست جاری صبر کنند.

نودها تصمیمات دریافت ایمیج را به‌صورت جداگانه . حتی در حالت سریالی‌سازی دریافت ایمیج، دو نود مختلف می‌توانند به‌طور موازی همان ایمیج را بکشند.

اگر می‌خواهید دریافت ایمیج را به‌صورت موازی فعال کنید، می‌توانید فیلد `serializeImagePulls` را در [پیکربندی kubelet](/docs/reference/config-api/kubelet-config.v1beta1/) روی false تنظیم کنید. با `serializeImagePulls: false`، درخواست‌های دریافت ایمیج فوراً به سرویس ایمیج ارسال می‌شوند و چندین ایمیج به‌طور هم‌زمان کشیده می‌شوند.

هنگام فعال کردن دریافت موازی ایمیج‌ها، مطمئن شوید که سرویس ایمیج زمان‌اجرای شما قادر به پردازش دریافت موازی ایمیج‌ها باشد.

kubelet هرگز برای یک پاد چند ایمیج را به‌طور موازی نمی‌کشد. برای مثال، اگر پادی یک کانتینر init و یک کانتینر برنامه داشته باشد، دریافت ایمیج‌های این دو کانتینر موازی‌سازی نمی‌شود. اما اگر دو پاد با ایمیج‌های مختلف داشته باشید و ویژگی دریافت موازی فعال باشد، kubelet ایمیج‌های آن دو پاد را به‌طور موازی می‌کشد.

### حداکثر تعداد دریافت موازی ایمیج

{{< feature-state for_k8s_version="v1.32" state="beta" >}}

وقتی `serializeImagePulls` روی false تنظیم شود، kubelet به‌طور پیش‌فرض هیچ محدودیتی برای حداکثر تعداد ایمیج‌هایی که هم‌زمان کشیده می‌شوند در نظر نمی‌گیرد. اگر بخواهید تعداد دریافت موازی ایمیج‌ها را محدود کنید، می‌توانید فیلد `maxParallelImagePulls` را در پیکربندی kubelet تعیین کنید. با تنظیم `maxParallelImagePulls` روی _n_، تنها _n_ ایمیج می‌توانند هم‌زمان کشیده شوند و هر درخواست دریافت ایمیج فراتر از _n_ باید تا اتمام حداقل یکی از دریافت‌های در حال انجام منتظر بماند.

محدود کردن تعداد دریافت موازی ایمیج‌ها از مصرف بیش‌ازحد پهنای باند شبکه یا I/O دیسک جلوگیری می‌کند، زمانی که دریافت موازی ایمیج فعال باشد.

می‌توانید `maxParallelImagePulls` را به عددی مثبت برابر یا بزرگ‌تر از ۱ تنظیم کنید. اگر آن را به عددی برابر یا بزرگ‌تر از ۲ تنظیم کنید، باید `serializeImagePulls` را روی false قرار دهید. در غیر این صورت، kubelet با تنظیم نامعتبر `maxParallelImagePulls` موفق به راه‌اندازی نخواهد شد.

## ایمیج چندمعماری با ایندکس ایمیج

علاوه بر ارائه‌ی ایمیج‌های باینری، یک رجیستری کانتینر می‌تواند یک  
[ایندکس ایمیج کانتینر](https://github.com/opencontainers/image-spec/blob/master/image-index.md)  
نیز سرو کند. ایندکس ایمیج می‌تواند به چندین  
[مانیفست ایمیج](https://github.com/opencontainers/image-spec/blob/master/manifest.md)  
برای نسخه‌های معماری‌محور یک کانتینر اشاره کند. ایده این است که شما می‌توانید  
یک نام برای ایمیج داشته باشید (برای مثال: `pause`، `example/mycontainer`، `kube-apiserver`)  
و اجازه دهید سیستم‌های مختلف، ایمیج باینری مناسب معماری ماشینی را که استفاده می‌کنند، دریافت کنند.

پروژه‌ی Kubernetes معمولاً ایمیج‌های کانتینر برای نسخه‌های خود را با نام‌هایی حاوی پسوند `-$(ARCH)` می‌سازد.  
برای سازگاری با نسخه‌های قدیمی‌تر، ایمیج‌های قدیمی‌تر را با پسوندهای مشخص تولید می‌کند.  
برای مثال، ایمیجی با نام `pause` یک تصویر چندمعماری حاوی مانیفست برای همه‌ی معماری‌های پشتیبانی‌شده خواهد بود،  
در حالی که `pause-amd64` نسخه‌ای سازگار با پیکربندی‌های قبلی یا فایل‌های YAML با نام سخت‌کدشده و پسوند است.

## استفاده از رجیستری خصوصی

رجیستری‌های خصوصی ممکن است برای کشف و/یا دریافت ایمیج‌ها از آن‌ها به احراز هویت نیاز داشته باشند.  
اطلاعات اعتبار (Credentials) را می‌توان به چند روش فراهم کرد:

- [تعریف `imagePullSecrets` هنگام تعریف یک پاد](#specifying-imagepullsecrets-on-a-pod)  
  تنها پادهایی که کلیدهای خود را ارائه می‌کنند می‌توانند به رجیستری خصوصی دسترسی پیدا کنند.

- [پیکربندی نودها برای احراز هویت به یک رجیستری خصوصی](#configuring-nodes-to-authenticate-to-a-private-registry)  
  - همه‌ی پادها می‌توانند هر رجیستری خصوصی پیکربندی‌شده را بخوانند.  
  - نیازمند پیکربندی نود توسط مدیر خوشه است.

- استفاده از افزونه‌ی _kubelet credential provider_ برای [دریافت پویا اعتبارنامه‌ها برای رجیستری‌های خصوصی](#kubelet-credential-provider)  
  می‌توان kubelet را طوری پیکربندی کرد که از افزونه‌ی اجرایی Credential Provider برای  
  رجیستری خصوصی مربوطه استفاده کند.  

- [ایمیج‌های از پیش دریافت‌شده](#pre-pulled-images)  
  - همهٔ پادها می‌توانند از هر ایمیجی که روی نود کش شده است استفاده کنند.  
  - نیازمند دسترسی root به تمام نودها برای پیکربندی.  
- افزونه‌های مخصوص فروشنده یا محلی  

  اگر از پیکربندی نود سفارشی استفاده می‌کنید، شما (یا ارائه‌دهندهٔ خدمات ابری شما) می‌توانید مکانیزم خود را برای احراز هویت نود به رجیستری کانتینر پیاده‌سازی کنید.

این گزینه‌ها در ادامه با جزئیات بیشتری توضیح داده شده‌اند.

### مشخص کردن `imagePullSecrets` در پاد

{{< note >}}  
این روش توصیه‌شده برای اجرای کانتینرها بر اساس ایمیج‌های موجود در رجیستری‌های خصوصی است.  
{{< /note >}}

Kubernetes از مشخص کردن کلیدهای رجیستری ایمیج کانتینر در پاد پشتیبانی می‌کند.  
تمام `imagePullSecrets` باید Secretهایی باشند که در همان  
{{< glossary_tooltip term_id="namespace" >}}  
پاد وجود دارند. این Secretها باید از نوع `kubernetes.io/dockercfg` یا `kubernetes.io/dockerconfigjson` باشند.

### پیکربندی نودها برای احراز هویت به یک رجیستری خصوصی

دستورالعمل‌های خاص برای تنظیم اعتبارنامه‌ها به زمان‌اجرای کانتینر و رجیستری مورد استفاده شما بستگی دارد. برای دقیق‌ترین اطلاعات به مستندات راه‌حل خود مراجعه کنید.

برای مثال پیکربندی یک رجیستری ایمیج کانتینر خصوصی، به تسک  
[Pull an Image from a Private Registry](/docs/tasks/configure-pod-container/pull-image-private-registry)  
مراجعه کنید. آن مثال از یک رجیستری خصوصی در Docker Hub استفاده می‌کند.

### افزونه‌ی اعتبارنامه kubelet برای دریافت ایمیج‌های احراز هویت‌شده {#kubelet-credential-provider}

می‌توانید kubelet را طوری پیکربندی کنید که یک باینری افزونه را فراخوانی کند تا به‌صورت پویا اعتبارنامه‌های رجیستری را برای یک ایمیج کانتینر دریافت کند. این روش مقاوم‌ترین و چندمنظوره‌ترین راه برای دریافت اعتبارنامه‌ها برای رجیستری‌های خصوصی است، اما نیاز به پیکربندی در سطح kubelet دارد.

این تکنیک می‌تواند برای اجرای {{< glossary_tooltip term_id="static-pod" text="static Pods" >}} که نیاز به ایمیج‌های کانتینر میزبانی‌شده در یک رجیستری خصوصی دارند، بسیار مفید باشد. استفاده از {{< glossary_tooltip term_id="service-account" >}} یا {{< glossary_tooltip term_id="secret" >}} برای ارائه اعتبارنامه‌های رجیستری خصوصی در مشخصات یک پاد ایستا ممکن نیست، زیرا پاد ایستا نمی‌تواند به منابع API دیگر در مشخصات خود ارجاع دهد.

برای جزئیات بیشتر، به [Configure a kubelet image credential provider](/docs/tasks/administer-cluster/kubelet-credential-provider/) مراجعه کنید.  

### تفسیر فایل config.json {#config-json}

تفسیر `config.json` بین پیاده‌سازی اصلی Docker و تفسیر Kubernetes متفاوت است. در Docker، کلیدهای `auths` تنها می‌توانند URLهای ریشه‌ای را مشخص کنند، در حالی که Kubernetes علاوه بر مسیرهای مطابقت پیشوندی، از URLهای الگو (glob) نیز پشتیبانی می‌کند. تنها محدودیت این است که الگوهای glob (`*`) باید برای هر زیردامنه شامل نقطه (`.`) باشند. تعداد زیردامنه‌های مطابقت‌شده باید برابر با تعداد الگوهای glob (`*.`) باشد. برای مثال:

- `*.kubernetes.io` با `kubernetes.io` **مطابقت ندارد**، اما با `abc.kubernetes.io` **مطابقت می‌کند**.  
- `*.*.kubernetes.io` با `abc.kubernetes.io` **مطابقت ندارد**، اما با `abc.def.kubernetes.io` **مطابقت می‌کند**.  
- `prefix.*.io` با `prefix.kubernetes.io` **مطابقت می‌کند**.  
- `*-good.kubernetes.io` با `prefix-good.kubernetes.io` **مطابقت می‌کند**.  

این بدان معناست که `config.json` زیر معتبر است:

```json
{
    "auths": {
        "my-registry.example/images": { "auth": "…" },
        "*.my-registry.example/images": { "auth": "…" }
    }
}
```

عملیات دریافت ایمیج، اطلاعات اعتبار (Credentials) را برای هر الگوی معتبر به زمان‌اجرای کانتینر CRI ارسال می‌کند. برای مثال، نام‌های ایمیجی زیر با موفقیت مطابقت پیدا می‌کنند:

- `my-registry.example/images`  
- `my-registry.example/images/my-image`  
- `my-registry.example/images/another-image`  
- `sub.my-registry.example/images/my-image`  

اما این نام‌های ایمیج **مطابقت نخواهند داشت**:

- `a.sub.my-registry.example/images/my-image`  
- `a.b.sub.my-registry.example/images/my-image`  

kubelet عملیات دریافت ایمیج را به‌صورت متوالی برای هر اعتبارنامهٔ یافت‌شده انجام می‌دهد. این بدان معناست که می‌توانید چندین ورودی مختلف در `config.json` برای مسیرهای گوناگون داشته باشید:

```json
{
    "auths": {
        "my-registry.example/images": {
            "auth": "…"
        },
        "my-registry.example/images/subpath": {
            "auth": "…"
        }
    }
}
```

اگر اکنون یک کانتینر مشخص کند ایمیج `my-registry.example/images/subpath/my-image` باید دریافت شود، آنگاه kubelet تلاش می‌کند آن را با استفاده از هر دو منبع احراز هویت دانلود کند و اگر یکی از آن‌ها شکست بخورد، از دیگری استفاده کند.

### ایمیج‌های از پیش دریافت‌شده

{{< note >}}
این روش مناسب است اگر بتوانید پیکربندی نودها را کنترل کنید. اگر ارائه‌دهندهٔ ابری شما نودها را مدیریت کرده و آن‌ها را به‌طور خودکار جایگزین کند، به‌طور قابل‌اعتمادی کار نخواهد کرد.
{{< /note >}}

به‌طور پیش‌فرض، kubelet سعی می‌کند هر ایمیج را از رجیستری مشخص‌شده دریافت کند. با این حال، اگر ویژگی `imagePullPolicy` کانتینر روی `IfNotPresent` یا `Never` تنظیم شده باشد، ایمیج محلی استفاده می‌شود (به‌ترتیب، به‌طور ترجیحی یا انحصاری).

اگر می‌خواهید به‌جای احراز هویت به رجیستری، به ایمیج‌های از پیش دریافت‌شده متکی باشید، باید مطمئن شوید که همهٔ نودهای خوشه همان ایمیج‌های از پیش دریافت‌شده را دارند.

این روش می‌تواند برای بارگذاری اولیهٔ برخی ایمیج‌ها به‌منظور افزایش سرعت یا به‌عنوان جایگزینی برای احراز هویت به رجیستری خصوصی استفاده شود.

مشابه استفاده از [kubelet credential provider](#kubelet-credential-provider)، ایمیج‌های از پیش دریافت‌شده همچنین برای راه‌اندازی {{< glossary_tooltip text="static Pods" term_id="static-pod" >}} که به ایمیج‌های میزبانی‌شده در رجیستری خصوصی وابسته‌اند مناسب هستند.

{{< note >}}
{{< feature-state feature_gate_name="KubeletEnsureSecretPulledImages" >}}
دسترسی به ایمیج‌های از پیش دریافت‌شده ممکن است بر اساس [اعتبارسنجی اعتبارنامهٔ دریافت ایمیج](#ensureimagepullcredentialverification) مجاز باشد.
{{< /note >}}

#### اطمینان از اعتبارسنجی اعتبارنامه‌های دریافت ایمیج {#ensureimagepullcredentialverification}

{{< feature-state feature_gate_name="KubeletEnsureSecretPulledImages" >}}

اگر feature gate `KubeletEnsureSecretPulledImages` برای خوشهٔ شما فعال باشد، Kubernetes اعتبارنامه‌های دریافت ایمیج را برای هر ایمیجی که نیاز به اعتبارنامه برای دریافت دارد، حتی اگر آن ایمیج قبلاً روی نود موجود باشد، اعتبارسنجی می‌کند. این اعتبارسنجی تضمین می‌کند که ایمیج‌هایی که در یک درخواست پاد وجود دارند و با اعتبارنامه‌های ارائه‌شده با موفقیت دریافت نشده‌اند، باید مجدداً از رجیستری دریافت شوند. علاوه بر این، دریافت ایمیج‌هایی که از همان اعتبارنامه‌ای استفاده می‌کنند که پیش‌تر منجر به دریافت موفق شده است، نیازی به دریافت مجدد از رجیستری ندارند و در عوض به‌صورت محلی اعتبارسنجی می‌شوند (مشروط بر اینکه ایمیج به‌صورت محلی موجود باشد).  
این موضوع توسط فیلد `imagePullCredentialsVerificationPolicy` در [پیکربندی Kubelet](/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-ImagePullCredentialsVerificationPolicy) کنترل می‌شود.

این پیکربندی تعیین می‌کند که چه زمانی اعتبارنامه‌های دریافت ایمیج باید اعتبارسنجی شوند اگر ایمیج قبلاً روی نود موجود باشد:

* `NeverVerify`: رفتار معادل غیرفعال بودن این feature gate را شبیه‌سازی می‌کند. اگر ایمیج به‌صورت محلی موجود باشد، اعتبارنامه‌های دریافت ایمیج اعتبارسنجی نمی‌شوند.
* `NeverVerifyPreloadedImages`: ایمیج‌هایی که خارج از kubelet دریافت شده‌اند، اعتبارسنجی نمی‌شوند، اما همهٔ ایمیج‌های دیگر اعتبارنامه‌هایشان اعتبارسنجی می‌شود. این رفتار پیش‌فرض است.
* `NeverVerifyAllowListedImages`: ایمیج‌هایی که خارج از kubelet دریافت شده‌اند و در لیست `preloadedImagesVerificationAllowlist` مشخص‌شده در پیکربندی kubelet آمده‌اند، اعتبارسنجی نمی‌شوند.
* `AlwaysVerify`: همهٔ ایمیج‌ها قبل از استفاده، اعتبارنامه‌هایشان اعتبارسنجی می‌شود.

این اعتبارسنجی شامل [ایمیج‌های از پیش دریافت‌شده](#pre-pulled-images)، ایمیج‌هایی که با استفاده از Secretهای سراسری نود دریافت شده‌اند، و ایمیج‌هایی که با استفاده از Secretهای سطح پاد دریافت شده‌اند، می‌شود.

{{< note >}}
در صورت گردش اعتبارنامه‌ها، اعتبارنامه‌های قبلاً استفاده‌شده برای دریافت ایمیج بدون نیاز به دسترسی به رجیستری همچنان اعتبارسنجی می‌شوند. اعتبارنامه‌های جدید یا گردش‌یافته نیاز به دریافت مجدد ایمیج از رجیستری خواهند داشت.
{{< /note >}}

#### ایجاد یک راز با پیکربندی Docker

برای احراز هویت در رجیستری، باید نام کاربری، رمز عبور رجیستری و آدرس ایمیل کلاینت و همچنین نام میزبان آن را بدانید.

دستور زیر را اجرا کنید و مقادیر مناسب را جایگزین متغیرهای جایگزین کنید:

```shell
kubectl create secret docker-registry <name> \
  --docker-server=<docker-registry-server> \
  --docker-username=<docker-user> \
  --docker-password=<docker-password> \
  --docker-email=<docker-email>
```

اگر قبلاً یک فایل اعتبارنامه Docker دارید، به‌جای استفاده از دستور بالا می‌توانید فایل اعتبارنامه را به‌عنوان یک {{< glossary_tooltip text="Secret" term_id="secret" >}} در Kubernetes وارد (import) کنید. دستورالعمل [ایجاد Secret بر اساس اعتبارنامه‌های موجود Docker](/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials) نحوهٔ انجام این کار را توضیح می‌دهد.

این روش زمانی که از چندین رجیستری کانتینر خصوصی استفاده می‌کنید بسیار مفید است، زیرا دستور `kubectl create secret docker-registry` یک Secret ایجاد می‌کند که فقط با یک رجیستری خصوصی کار می‌کند.

{{< note >}}
پادها تنها می‌توانند به imagePullSecrets در همان namespace خود ارجاع دهند، بنابراین این فرآیند باید برای هر namespace یک‌بار انجام شود.
{{< /note >}}

#### ارجاع به `imagePullSecrets` در یک پاد

اکنون می‌توانید پادهایی ایجاد کنید که با افزودن بخش `imagePullSecrets` به تعریف پاد، به آن Secret ارجاع دهند. هر آیتم در آرایهٔ `imagePullSecrets` فقط می‌تواند به یک Secret در همان namespace اشاره کند.

برای مثال:
```shell
cat <<EOF > pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: foo
  namespace: awesomeapps
spec:
  containers:
    - name: foo
      image: janedoe/awesomeapp:v1
  imagePullSecrets:
    - name: myregistrykey
EOF

cat <<EOF >> ./kustomization.yaml
resources:
- pod.yaml
EOF
```

برای هر پادی که از یک رجیستری خصوصی استفاده می‌کند باید این کار انجام شود.

با این حال، می‌توانید این فرآیند را با مشخص کردن بخش `imagePullSecrets`  
در یک منبع [ServiceAccount](/docs/tasks/configure-pod-container/configure-service-account/) خودکار کنید.  
برای دستورالعمل‌های دقیق‌تر به بخش  
[افزودن ImagePullSecrets به یک Service Account](/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account)  
مراجعه کنید.

می‌توانید این روش را همراه با یک فایل `.docker/config.json` به ازای هر نود استفاده کنید.  
اعتبارنامه‌ها با هم ادغام خواهند شد.

## موارد استفاده

راه‌حل‌های متعددی برای پیکربندی رجیستری‌های خصوصی وجود دارد. در اینجا برخی موارد رایج و راه‌حل‌های پیشنهاد‌شده آمده‌اند:

1. خوشه‌ای که تنها از ایمیج‌های غیرخصوصی (مثلاً متن‌باز) استفاده می‌کند و نیازی به پنهان کردن ایمیج‌ها نیست.  
   - از ایمیج‌های عمومی در یک رجیستری عمومی استفاده کنید  
     - پیکربندی لازم نیست.  
     - برخی ارائه‌دهندگان ابری به‌طور خودکار ایمیج‌های عمومی را کش یا میران کنند که دسترسی‌پذیری را بهبود و زمان دریافت را کاهش می‌دهد.
1. خوشه‌ای که برخی ایمیج‌های اختصاصی دارد که باید از کاربران خارج شرکت پنهان باشد اما برای همهٔ کاربران خوشه قابل مشاهده باشد.  
   - از رجیستری خصوصی میزبانی‌شده استفاده کنید  
     - ممکن است نیاز به پیکربندی دستی روی نودهایی باشد که باید به رجیستری خصوصی دسترسی داشته باشند.  
   - یا، یک رجیستری خصوصی داخلی پشت فایروال خود با دسترسی خواندن باز اجرا کنید.  
     - نیازی به پیکربندی Kubernetes نیست.  
   - از سرویس رجیستری ایمیج میزبانی‌شده‌ای استفاده کنید که دسترسی به ایمیج را کنترل می‌کند  
     - با autoscaling نود بهتر از پیکربندی دستی نودها کار می‌کند.  
   - یا، در خوشه‌ای که تغییر پیکربندی نودها دشوار است، از `imagePullSecrets` استفاده کنید.
1. خوشه‌ای با ایمیج‌های اختصاصی که برخی از آن‌ها نیاز به کنترل دسترسی سخت‌گیرانه‌تر دارند.  
   - مطمئن شوید کنترل‌کنندهٔ admission [AlwaysPullImages](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages)  
     فعال است؛ در غیر این صورت، همهٔ پادها ممکن است به همهٔ ایمیج‌ها دسترسی داشته باشند.  
   - داده‌های حساس را به یک منبع Secret انتقال دهید، به جای بسته‌بندی در ایمیج.
1. خوشهٔ چندمستأجری که هر مستأجر نیاز به رجیستری خصوصی خود دارد.  
   - مطمئن شوید کنترل‌کنندهٔ admission [AlwaysPullImages](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages)  
     فعال است؛ در غیر این صورت، همهٔ پادهای همهٔ مستأجران ممکن است به همهٔ ایمیج‌ها دسترسی داشته باشند.  
   - یک رجیستری خصوصی با احراز هویت مورد نیاز اجرا کنید.  
   - برای هر مستأجر اعتبارنامهٔ رجیستری تولید کنید، در یک Secret ذخیره و آن Secret را به همهٔ namespaceهای مستأجر انتقال دهید.  
   - سپس مستأجر آن Secret را به `imagePullSecrets` هر namespace اضافه می‌کند.

اگر به چندین رجیستری نیاز دارید، می‌توانید برای هر رجیستری یک Secret جداگانه ایجاد کنید.

## ارائه‌دهنده اعتبارنامه داخلی قدیمی kubelet

در نسخه‌های قدیمی‌تر Kubernetes، kubelet با اعتبارنامه‌های ارائه‌دهندهٔ ابری یکپارچه بود. این امکان را فراهم می‌کرد که به‌صورت پویا اعتبارنامه‌ها برای رجیستری‌های ایمیج دریافت شوند.

سه پیاده‌سازی داخلی از ارائه‌دهندهٔ اعتبارنامه kubelet وجود داشت: ACR (Azure Container Registry)، ECR (Elastic Container Registry)، و GCR (Google Container Registry).

از نسخه 1.26 Kubernetes به بعد، این مکانیزم قدیمی حذف شده است، بنابراین باید یکی از کارهای زیر را انجام دهید:  
- پیکربندی یک ارائه‌دهندهٔ اعتبارنامه kubelet برای ایمیج روی هر نود؛ یا  
- مشخص کردن اعتبارنامه‌های دریافت ایمیج با استفاده از `imagePullSecrets` و حداقل یک Secret.

## {{% heading "whatsnext" %}}

* مستند [OCI Image Manifest Specification](https://github.com/opencontainers/image-spec/blob/main/manifest.md) را مطالعه کنید.  
* درباره [جمع‌آوری زباله ایمیج‌های کانتینر](/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection) بیشتر بیاموزید.  
* اطلاعات بیشتری درباره [دریافت ایمیج از رجیستری خصوصی](/docs/tasks/configure-pod-container/pull-image-private-registry) کسب کنید.  
