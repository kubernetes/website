---
reviewers:
  - moh0ps
title: رازها
api_metadata:
- apiVersion: "v1"
  kind: "Secret"
content_type: concept
feature:
  title: راز و مدیریت پیکربندی
  description: >
    Deploy and update Secrets and application configuration without rebuilding your image
    and without exposing Secrets in your stack configuration.
weight: 30
---

<!-- overview -->

یک راز شیء‌ای است که حاوی مقدار کمی از داده‌های حساس مانند رمز عبور، توکن یا کلید است. در غیر این صورت، چنین اطلاعاتی ممکن است در یک {{< glossary_tooltip term_id="pod" >}} مشخصات یا در یک {{< glossary_tooltip text="container image" term_id="image" >}} قرار داده شوند. استفاده از یک راز به این معنی است که نیازی به گنجاندن داده‌های محرمانه در کد برنامه خود ندارید.

از آنجا که می‌توان رازها را مستقل از پادهایی که از آنها استفاده می‌کنند ایجاد کرد، خطر کمتری برای افشای راز (و داده‌های آن) در طول گردش کار ایجاد، مشاهده و ویرایش پادها وجود دارد. کوبرنتیز و برنامه‌هایی که در خوشه شما اجرا می‌شوند، می‌توانند اقدامات احتیاطی بیشتری را نیز در مورد رازها انجام دهند، مانند جلوگیری از نوشتن داده‌های حساس در حافظه غیرفرار.

رمزها مشابه {{< glossary_tooltip text="ConfigMaps" term_id="configmap" >}} هستند، اما به طور خاص برای نگهداری داده‌های محرمانه در نظر گرفته شده‌اند.

{{< caution >}}
رازهای کوبرنتیز، به طور پیش‌فرض، بدون رمزگذاری در مخزن داده زیربنایی سرور API (etcd) ذخیره می‌شوند. هر کسی که به API دسترسی داشته باشد می‌تواند یک راز را بازیابی یا تغییر دهد، و بنابراین هر کسی که به etcd دسترسی داشته باشد نیز می‌تواند. علاوه بر این، هر کسی که مجاز به ایجاد یک پاد در یک فضای نام باشد، می‌تواند از آن دسترسی برای خواندن هر راز در آن فضای نام استفاده کند. این شامل دسترسی غیرمستقیم مانند توانایی ایجاد یک استقرار نیز می‌شود.

برای استفاده ایمن از رازها، حداقل مراحل زیر را انجام دهید:

1. [فعال کردن رمزگذاری در Rest](/docs/tasks/administer-cluster/encrypt-data/) برای رازها.
1. [فعال یا پیکربندی قوانین RBAC](/docs/reference/access-authn-authz/authorization/) با حداقل امتیاز دسترسی به رازها.
1. محدود کردن دسترسی راز به کانتینرهای خاص
1. [استفاده از ارائه‌دهندگان خارجی ذخیره‌سازی رازها را در نظر بگیرید](https://secrets-store-csi-driver.sigs.k8s.io/concepts.html#provider-for-the-secrets-store-csi-driver).

برای راهنمایی‌های بیشتر برای مدیریت و بهبود امنیت رازها خود، به [روش‌های خوب برای رازهای کوبرنتیز](/docs/concepts/security/secrets-good-practices) مراجعه کنید.

{{< /caution >}}

برای جزئیات بیشتر به [امنیت اطلاعات برای رازها](#information-security-for-secrets) مراجعه کنید.

<!-- body -->

## کاربردهای رازها

شما می‌توانید از رازها برای اهدافی مانند موارد زیر استفاده کنید:

- [تنظیم متغیرهای محیطی برای یک کانتینر](/docs/tasks/inject-data-application/distribute-credentials-secure/#define-container-environment-variables-using-secret-data).
- [اطلاعات احراز هویت مانند کلیدهای SSH یا رمزهای عبور را به پادها ارائه دهید](/docs/tasks/inject-data-application/distribute-credentials-secure/#provide-prod-test-creds).
- [به kubelet اجازه دهید image کانتینر را از رجیستری‌های خصوصی دریافت کند](/docs/tasks/configure-pod-container/pull-image-private-registry/).

صفحه کنترل کوبرنتیز نیز از رازها استفاده می‌کند؛ برای مثال، [bootstrap توکن رازها](#bootstrap-token-secrets) سازوگاری برای کمک به خودکارسازی ثبت گره‌ها هستند.

### مورد استفاده: فایل‌های نقطه‌ای در یک حجم راز

شما می‌توانید با تعریف کلیدی که با نقطه شروع می‌شود، داده‌های خود را "hidden" کنید. این کلید نشان‌دهنده‌ی یک پرونده نقطه‌ای یا "hidden" است. برای مثال، وقتی پرونده مخفی زیر در یک درایو به نام `secret-volume` نصب می‌شود، درایو شامل یک پرونده واحد به نام `.secret-file` خواهد بود و `dotfile-test-container` این پرونده را در مسیر `/etc/secret-volume/.secret-file` خواهد داشت.

{{< note >}}
پرونده هایی که با کاراکتر نقطه شروع می‌شوند از خروجی `ls -l` پنهان می‌شوند؛ برای مشاهده آنها هنگام فهرست کردن محتویات پوشه باید از `ls -la` استفاده کنید.
{{< /note >}}

{{% code language="yaml" file="secret/dotfile-secret.yaml" %}}

### مورد استفاده: راز قابل مشاهده برای یک کانتینر در یک پاد

برنامه‌ای را در نظر بگیرید که نیاز به مدیریت درخواست‌های HTTP، انجام برخی منطق‌های پیچیده‌ی کاری و سپس امضای برخی پیام‌ها با HMAC دارد. از آنجایی که منطق کاربردی پیچیده‌ای دارد، ممکن است یک آسیب‌پذیری خواندن پرونده از راه دور در سرور وجود داشته باشد که بدون اطلاع کاربر، کلید خصوصی را در اختیار مهاجم قرار دهد.

این می‌تواند به دو فرآیند در دو کانتینر تقسیم شود: یک کانتینر ظاهر که تعامل کاربر و منطق کسب‌وکار را مدیریت می‌کند، اما نمی‌تواند کلید خصوصی را ببیند؛ و یک کانتینر امضاکننده که می‌تواند کلید خصوصی را ببیند و به درخواست‌های امضای ساده از ظاهر (مثلاً از طریق شبکه میزبان محلی) پاسخ دهد.

با این رویکرد پارتیشن‌بندی‌شده، مهاجم اکنون باید سرور برنامه را فریب دهد تا کاری نسبتاً دلخواه انجام دهد، که ممکن است سخت‌تر از وادار کردن آن به خواندن یک پرونده باشد.

### جایگزین‌هایی برای رازها

به جای استفاده از یک راز برای محافظت از داده‌های محرمانه، می‌توانید از گزینه‌های دیگر استفاده کنید.

در اینجا برخی از گزینه‌های شما آورده شده است:

- اگر مولفه ابری شما نیاز به احراز هویت برای برنامه دیگری دارد که می‌دانید در همان خوشه کوبرنتیز در حال اجرا است، می‌توانید از یک [حساب کاربری سرویس](/docs/reference/access-authn-authz/authentication/#service-account-tokens) و توکن‌های آن برای شناسایی کلاینت خود استفاده کنید.
- ابزارهای شخص ثالثی وجود دارند که می‌توانید آنها را، چه در داخل و چه در خارج از خوشه خود، اجرا کنید تا داده‌های حساس را مدیریت کنند. به عنوان مثال، سرویسی که پادها از طریق HTTPS به آن دسترسی دارند، که در صورت احراز هویت صحیح کلاینت (مثلاً با توکن حساب کاربری سرویس)، یک راز را فاش می‌کند.
- برای احراز هویت، می‌توانید یک امضاکننده سفارشی برای گواهی‌های X.509 پیاده‌سازی کنید و از [درخواست‌های امضای گواهی](/docs/reference/access-authn-authz/certificate-signing-requests/) استفاده کنید تا به آن امضاکننده سفارشی اجازه دهید گواهی‌هایی را برای پادهایی که به آنها نیاز دارند صادر کند.
- شما می‌توانید از یک [device plugin](/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/) برای ارائه سخت‌افزار رمزگذاری محلی گره به یک پاد خاص استفاده کنید. به عنوان مثال، می‌توانید پادهای مورد اعتماد را روی گره‌هایی که یک ماژول بستر مورد اعتماد ارائه می‌دهند و به صورت خارج از باند پیکربندی شده‌اند، زمان‌بندی کنید.

همچنین می‌توانید دو یا چند مورد از این گزینه‌ها را با هم ترکیب کنید، از جمله گزینه استفاده از خود اشیاء مخفی.

برای مثال: یک {{< glossary_tooltip text="operator" term_id="operator-pattern" >}} پیاده‌سازی (یا مستقر) کنید که توکن‌های جلسه کوتاه‌مدت را از یک سرویس خارجی دریافت کند، و سپس بر اساس آن توکن‌های جلسه کوتاه‌مدت، رازها را ایجاد کند. پادهایی که در خوشه شما اجرا می‌شوند می‌توانند از توکن‌های جلسه استفاده کنند، و اپراتور از معتبر بودن آنها اطمینان حاصل می‌کند. این جداسازی به این معنی است که می‌توانید پادهایی را اجرا کنید که از سازوکارهای دقیق صدور و به‌روزرسانی آن توکن‌های جلسه بی‌اطلاع هستند.

## انواع راز {#secret-types}

هنگام ایجاد یک راز، می‌توانید نوع آن را با استفاده از بخش `type` در منبع [راز](/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/) یا پرچم‌های خط فرمان معادل `kubectl` (در صورت وجود) مشخص کنید. نوع راز برای تسهیل مدیریت برنامه‌ریزی‌شده‌ی داده‌های راز استفاده می‌شود.

کوبرنتیز چندین نوع داده‌ی از پیش تعریف‌شده برای برخی از سناریوهای رایج ارائه می‌دهد. این نوع داده‌ها از نظر اعتبارسنجی‌های انجام‌شده و محدودیت‌هایی که کوبرنتیز بر آنها اعمال می‌کند، متفاوت هستند.

| نوع داخلی                         | کاربرد                                   |
| ------------------------------------- |---------------------------------------- |
| `Opaque`                              | داده‌های دلخواه تعریف‌شده توسط کاربر   |
| `kubernetes.io/service-account-token` | توکن حساب سرویس                        |
| `kubernetes.io/dockercfg`             | فایل سریالی شده `~/.dockercfg`         |
| `kubernetes.io/dockerconfigjson`      | فایل سریالی شده `~/.docker/config.json`|
| `kubernetes.io/basic-auth`            | مدارک لازم برای احراز هویت اولیه       |
| `kubernetes.io/ssh-auth`              | اعتبارنامه برای احراز هویت SSH        |
| `kubernetes.io/tls`                   | داده‌ها برای یک کلاینت یا سرور TLS      |
| `bootstrap.kubernetes.io/token`       | داده‌های توکن بوت‌استرپ                  |

شما می‌توانید با اختصاص یک رشته غیرتهی به عنوان مقدار `type` برای یک شیء راز، نوع راز خودتان را تعریف و استفاده کنید (رشته خالی به عنوان یک نوع `Opaque` در نظر گرفته می‌شود).

کوبرنتیز هیچ محدودیتی برای نام نوع اعمال نمی‌کند. با این حال، اگر از یکی از انواع داخلی استفاده می‌کنید، باید تمام الزامات تعریف شده برای آن نوع را رعایت کنید.

اگر نوعی از راز را تعریف می‌کنید که برای استفاده عمومی است، از قرارداد پیروی کنید و نوع راز را طوری ساختار دهید که نام دامنه شما قبل از نام، با یک `/` از هم جدا شود. به عنوان مثال: `cloud-hosting.example.net/cloud-api-credentials`.

### راز مبهم

اگر نوع خاصی را در تنظیمات راز مشخص نکنید، نوع پیش‌فرض راز، `Opaque` است. وقتی با استفاده از `kubectl` یک راز ایجاد می‌کنید، باید از زیردستور `generic` برای نشان دادن نوع راز `Opaque` استفاده کنید. برای مثال، دستور زیر یک راز خالی از نوع `Opaque` ایجاد می‌کند:

```shell
kubectl create secret generic empty-secret
kubectl get secret empty-secret
```

خروجی به صورت زیر است:

```
NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
```

ستون `DATA` تعداد اقلام داده ذخیره شده در راز را نشان می‌دهد.
در این مورد، `0` به این معنی است که شما یک راز خالی ایجاد کرده‌اید.

### رازهای توکن حساب کاربری

نوع `kubernetes.io/service-account-token` از نوع راز برای ذخیره یک اعتبارنامه توکن استفاده می‌شود که یک {{< glossary_tooltip text="ServiceAccount" term_id="service-account" >}} را شناسایی می‌کند. این یک سازوکار قدیمی است که اعتبارنامه‌های حساب سرویس با طول عمر بالا را برای پادها فراهم می‌کند.

در کوبرنتیز نسخه ۱.۲۲ و بالاتر، رویکرد پیشنهادی این است که با استفاده از API [`TokenRequest`](/docs/reference/kubernetes-api/authentication-resources/token-request-v1/) یک توکن حساب سرویس با عمر کوتاه و چرخش خودکار دریافت کنید. می‌توانید این توکن‌های با عمر کوتاه را با استفاده از روش‌های زیر دریافت کنید:

* API مربوط به `TokenRequest` را مستقیماً یا با استفاده از یک کلاینت API مانند `kubectl` فراخوانی کنید. برای مثال، می‌توانید از دستور [`kubectl create token`]`(/docs/reference/generated/kubectl/kubectl-commands#-em-token-em-)` استفاده کنید.
* درخواست یک توکن نصب‌شده در [حجم ترکیبی](/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume) در تنظیمات پاد خود. کوبرنتیز توکن را ایجاد کرده و آن را در پاد نصب می‌کند. توکن به طور خودکار زمانی که پادی که در آن نصب شده است حذف شود، نامعتبر می‌شود. برای جزئیات بیشتر، به [راه‌اندازی یک پاد با استفاده از طرح توکن حساب سرویس](/docs/tasks/configure-pod-container/configure-service-account/#launch-a-pod-using-service-account-token-projection) مراجعه کنید.

{{< note >}}
شما فقط در صورتی باید یک توکن راز حساب سرویس ایجاد کنید که نتوانید از API مربوط به `TokenRequest` برای دریافت توکن استفاده کنید، و ریسک امنیتی ناشی از نگهداری یک اعتبارنامه توکن بدون انقضا در یک شیء API قابل خواندن برای شما قابل قبول باشد. برای دستورالعمل‌ها، به [ایجاد دستی یک توکن API با عمر طولانی برای یک حساب سرویس](/docs/tasks/configure-pod-container/configure-service-account/#manually-create-an-api-token-for-a-serviceaccount) مراجعه کنید.
{{< /note >}}

هنگام استفاده از این نوع راز، باید مطمئن شوید که حاشیه‌نویسی `kubernetes.io/service-account.name` روی یک نام حساب سرویس موجود تنظیم شده باشد. اگر هم اشیاء حساب سرویس و هم اشیاء راز را ایجاد می‌کنید، ابتدا باید شیء حساب سرویس را ایجاد کنید.

پس از ایجاد راز، یک کوبرنتیز {{< glossary_tooltip text="controller" term_id="controller" >}}
بخش های دیگری مانند حاشیه‌نویسی `kubernetes.io/service-account.uid` و کلید `token` در بخش `data` را که با یک توکن احراز هویت پر شده است، پر می‌کند.

پیکربندی مثال زیر یک توکن حساب سرویس به نام راز اعلام می‌کند:

{{% code language="yaml" file="secret/serviceaccount-token-secret.yaml" %}}

پس از ایجاد راز، منتظر بمانید تا کوبرنتیز کلید `token` را در بخش `data` وارد کند.

برای اطلاعات بیشتر در مورد نحوه کار حساب های سرویس به مستندات [ServiceAccount](/docs/concepts/security/service-accounts/) مراجعه کنید. همچنین می‌توانید بخش `automountServiceAccountToken` و بخش `serviceAccountName` از [`Pod`](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#pod-v1-core) را برای اطلاعات مربوط به ارجاع اعتبارنامه‌های حساب سرویس از درون پادها بررسی کنید.

### رازهای پیکربندی داکر

اگر در حال ایجاد یک راز برای ذخیره اعتبارنامه‌ها جهت دسترسی به رجیستری image کانتینر هستید، باید از یکی از مقادیر `type` زیر برای آن راز استفاده کنید:

- `kubernetes.io/dockercfg`: یک پرونده سریالی `~/.dockercfg` را ذخیره می‌کند که فرمت قدیمی برای پیکربندی خط فرمان داکر است. بخش راز `data` شامل یک کلید `.dockercfg` است که مقدار آن محتوای یک پرونده `~/.dockercfg` کدگذاری شده با base64 است.
- `kubernetes.io/dockerconfigjson`: یک JSON سریالی شده را ذخیره می‌کند که از همان قوانین قالب‌بندی پرونده `~/.docker/config.json` پیروی می‌کند، که یک قالب‌بندی جدید برای `~/.dockercfg` است. بخش راز `data` باید حاوی یک کلید `.dockerconfigjson` باشد که مقدار آن محتوای یک پرونده `~/.docker/config.json` با کدگذاری base64 است.

در زیر مثالی برای نوع راز از نوع `kubernetes.io/dockercfg` آورده شده است:

{{% code language="yaml" file="secret/dockercfg-secret.yaml" %}}

{{< note >}}
اگر نمی‌خواهید کدگذاری base64 را انجام دهید، می‌توانید به جای آن از بخش stringData استفاده کنید.
{{< /note >}}

وقتی رازهای پیکربندی داکر را با استفاده از تنظیمات ایجاد می‌کنید، سرور API بررسی می‌کند که آیا کلید مورد انتظار در بخش `data` وجود دارد یا خیر، و تأیید می‌کند که آیا مقدار ارائه شده می‌تواند به عنوان یک JSON معتبر تجزیه شود یا خیر. سرور API تأیید نمی‌کند که آیا JSON واقعاً یک پرونده پیکربندی داکر است یا خیر.

همچنین می‌توانید از `kubectl` برای ایجاد یک راز جهت دسترسی به رجیستری کانتینر استفاده کنید، مثلاً زمانی که پرونده پیکربندی داکر ندارید:

```shell
kubectl create secret docker-registry secret-tiger-docker \
  --docker-email=tiger@acme.example \
  --docker-username=tiger \
  --docker-password=pass1234 \
  --docker-server=my-registry.example:5000
```

این دستور یک راز از نوع `kubernetes.io/dockerconfigjson` ایجاد می‌کند.

بخش `.data.dockerconfigjson` را از آن راز جدید بازیابی کرده و داده‌ها را رمزگشایی کنید:

```shell
kubectl get secret secret-tiger-docker -o jsonpath='{.data.*}' | base64 -d
```

خروجی معادل سند JSON زیر است (که آن هم یک پرونده پیکربندی معتبر داکر است):

```json
{
  "auths": {
    "my-registry.example:5000": {
      "username": "tiger",
      "password": "pass1234",
      "email": "tiger@acme.example",
      "auth": "dGlnZXI6cGFzczEyMzQ="
    }
  }
}
```

{{< caution >}}
مقدار `auth` در آنجا با کد base64 کدگذاری شده است؛ مبهم است اما مخفی نیست. هر کسی که بتواند آن راز را بخواند، می‌تواند توکن حامل دسترسی به رجیستری را پیدا کند.

پیشنهاد می‌شود از [ارائه دهندگان اعتبارنامه](/docs/tasks/administer-cluster/kubelet-credential-provider/) برای ارائه پویا و ایمن رمزهای ادغام در صورت تقاضا استفاده شود.
{{< /caution >}}

### راز احراز هویت پایه

نوع `kubernetes.io/basic-auth` برای ذخیره اعتبارنامه‌های مورد نیاز برای احراز هویت اولیه ارائه شده است. هنگام استفاده از این نوع راز، بخش `data` از راز باید شامل یکی از دو کلید زیر باشد:

- `username`: نام کاربری برای احراز هویت
- `password`: رمز عبور یا توکن برای احراز هویت

هر دو مقدار برای دو کلید فوق، رشته‌های کدگذاری شده با base64 هستند. می‌توانید به طور جایگزین، محتوای متن ساده را با استفاده از بخش `stringData` در تنظیمات راز ارائه دهید.

تنظیمات زیر نمونه‌ای از یک راز احراز هویت پایه است:

{{% code language="yaml" file="secret/basicauth-secret.yaml" %}}

{{< note >}}
بخش "stringData" برای یک راز با اعمال سمت سرور به خوبی کار نمی کند.
{{< /note >}}

نوع پایه احراز هویت مخفی فقط برای راحتی ارائه شده است. می‌توانید برای اعتبارنامه‌های مورد استفاده برای احراز هویت اولیه، یک نوع «مات» ایجاد کنید. با این حال، استفاده از نوع تعریف‌شده و عمومی راز (`kubernetes.io/basic-auth`) به دیگران کمک می‌کند تا هدف راز شما را درک کنند و قراردادی برای نام‌های کلیدی که باید انتظار داشته باشند، تعیین می‌کند.

### رازهای احراز هویت SSH

نوع داخلی `kubernetes.io/ssh-auth` برای ذخیره داده‌های مورد استفاده در احراز هویت SSH ارائه شده است. هنگام استفاده از این نوع مخفی، باید یک جفت کلید-مقدار `ssh-privatekey` را در بخش `data` (یا `stringData`) به عنوان اعتبارنامه SSH مورد استفاده مشخص کنید.

تنظیمات زیر نمونه‌ای از یک راز است که برای احراز هویت با کلید عمومی/خصوصی SSH استفاده می‌شود:

{{% code language="yaml" file="secret/ssh-auth-secret.yaml" %}}

نوع راز احراز هویت SSH فقط برای راحتی ارائه شده است. می‌توانید برای اعتبارنامه‌های مورد استفاده برای احراز هویت SSH، یک نوع «Opaque» ایجاد کنید. با این حال، استفاده از نوع راز تعریف‌شده و عمومی (`kubernetes.io/ssh-auth`) به دیگران کمک می‌کند تا هدف راز شما را درک کنند و قراردادی برای نام کلیدهای مورد انتظار تعیین می‌کند.
کوبرنتیز API تأیید می‌کند که کلیدهای مورد نیاز برای یک راز از این نوع تنظیم شده‌اند.

{{< caution >}}
کلیدهای خصوصی SSH به خودی خود ارتباط قابل اعتمادی بین یک کلاینت SSH و سرور میزبان برقرار نمی‌کنند. برای کاهش حملات "مرد میانی" به یک ابزار ثانویه برای ایجاد اعتماد نیاز است، مانند یک پرونده `known_hosts` که به ConfigMap اضافه می‌شود.
{{< /caution >}}

### رازهای TLS

نوع راز در `kubernetes.io/tls` برای ذخیره یک گواهی و کلید مرتبط با آن است که معمولاً برای TLS استفاده می‌شود.

یکی از کاربردهای رایج رازهای TLS، پیکربندی رمزگذاری در حین انتقال برای [Ingress](/docs/concepts/services-networking/ingress/) است، اما می‌توانید از آن با منابع دیگر یا مستقیماً در حجم کاری خود نیز استفاده کنید. هنگام استفاده از این نوع راز، کلید `tls.key` و `tls.crt` باید در بخش `data` (یا `stringData`) پیکربندی راز ارائه شوند، اگرچه سرور API در واقع مقادیر هر کلید را اعتبارسنجی نمی‌کند.

به عنوان جایگزینی برای استفاده از `stringData`، می‌توانید از بخش `data` برای ارائه گواهی کدگذاری شده base64 و کلید خصوصی استفاده کنید. برای جزئیات، به [محدودیت‌های نام‌ها و داده‌های مخفی](#restriction-names-data) مراجعه کنید.

YAML زیر شامل یک نمونه پیکربندی برای یک راز TLS است:

{{% code language="yaml" file="secret/tls-auth-secret.yaml" %}}

نوع راز TLS فقط برای راحتی ارائه شده است. می‌توانید برای اعتبارنامه‌های مورد استفاده برای احراز هویت TLS، یک نوع «Opaque» ایجاد کنید. با این حال، استفاده از نوع راز تعریف‌شده و عمومی (`kubernetes.io/tls`) به تضمین ثبات قالب راز در پروژه شما کمک می‌کند. سرور API بررسی می‌کند که آیا کلیدهای مورد نیاز برای راز از این نوع تنظیم شده‌اند یا خیر.

برای ایجاد یک راز TLS با استفاده از `kubectl`، از زیردستور `tls` استفاده کنید:

```shell
kubectl create secret tls my-tls-secret \
  --cert=path/to/cert/file \
  --key=path/to/key/file
```

جفت کلید عمومی/خصوصی باید از قبل وجود داشته باشد. گواهی کلید عمومی برای `--cert` باید با فرمت .PEM کدگذاری شده باشد و با کلید خصوصی داده شده برای `--key` مطابقت داشته باشد.

### رازهای توکن Bootstrap

نوع راز `bootstrap.kubernetes.io/token` برای توکن‌هایی است که در طول فرآیند بوت‌استرپ گره استفاده می‌شوند. این نوع توکن‌ها برای امضای ConfigMaps شناخته‌شده استفاده می‌شوند.

یک توکن بوت‌استرپ راز معمولاً در فضای نام `kube-system` ایجاد می‌شود و به شکل `bootstrap-token-<token-id>` نامگذاری می‌شود که در آن `<token-id>` یک رشته 6 کاراکتری از شناسه توکن است.

به عنوان یک تنظیمات کوبرنتیز، یک توکن بوت‌استرپ راز ممکن است به شکل زیر باشد:

{{% code language="yaml" file="secret/bootstrap-token-secret-base64.yaml" %}}

یک توکن بوت‌استرپ به نام راز دارای کلیدهای زیر است که در بخش `data` مشخص شده‌اند:

- `token-id`: یک رشته تصادفی ۶ کاراکتری به عنوان شناسه توکن. الزامی است.
- `token-secret`: یک رشته تصادفی ۱۶ کاراکتری به عنوان توکن اصلی. رمز. الزامی.
- `description`: یک رشته قابل خواندن توسط انسان که کاربرد توکن را شرح می‌دهد. اختیاری.
- `expiration`: یک زمان مطلق UTC با استفاده از [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) که مشخص می‌کند توکن چه زمانی باید منقضی شود. اختیاری.
- `usage-bootstrap-<usage>`: یک پرچم بولی که نشان‌دهنده‌ی کاربردهای اضافی برای توکن بوت‌استرپ است.
- `auth-extra-groups`: فهرستی از نام گروه‌هایی که با کاما از هم جدا شده‌اند و علاوه بر گروه `system:bootstrappers` احراز هویت خواهند شد.

شما می‌توانید به طور جایگزین، مقادیر را در بخش `stringData` از راز بدون کدگذاری base64 ارائه دهید:

{{% code language="yaml" file="secret/bootstrap-token-secret-literal.yaml" %}}

{{< note >}}
بخش `stringData` برای یک راز به خوبی با اعمال سمت سرور کار نمی کند.
{{< /note >}}

## کار با رازها

### ایجاد یک راز

چندین گزینه برای ایجاد یک راز وجود دارد:

- [استفاده از `kubectl`](/docs/tasks/configmap-secret/managing-secret-using-kubectl/)
- [استفاده از یک پرونده پیکربندی](/docs/tasks/configmap-secret/managing-secret-using-config-file/)
- [استفاده از ابزار Kustomize](/docs/tasks/configmap-secret/managing-secret-using-kustomize/)

#### محدودیت‌های مربوط به نام‌ها و داده‌های راز {#restriction-names-data}

نام یک شیء مخفی باید یک نام معتبر [نام زیردامنه DNS](/docs/concepts/overview/working-with-objects/names#dns-subdomain-names) باشد.

می‌توانید هنگام ایجاد پرونده پیکربندی برای یک راز، بخش `data` و/یا `stringData` را مشخص کنید. بخش های `data` و `stringData` اختیاری هستند. مقادیر همه کلیدهای بخش `data` باید رشته‌های کدگذاری شده با base64 باشند. اگر تبدیل به رشته base64 مطلوب نیست، می‌توانید به جای آن بخش `stringData` را مشخص کنید که رشته‌های دلخواه را به عنوان مقدار می‌پذیرد.

کلیدهای `data` و `stringData` باید شامل کاراکترهای حرفی-عددی، `-`، `_` یا `.` باشند. تمام جفت‌های کلید-مقدار در بخش `stringData` به صورت داخلی در بخش `data` ادغام می‌شوند. اگر کلیدی هم در بخش `data` و هم در بخش `stringData` ظاهر شود، مقدار مشخص شده در بخش `stringData` اولویت دارد.

#### محدودیت اندازه {#restriction-data-size}

حجم هر راز به ۱ مگابایت محدود شده است. این کار برای جلوگیری از ایجاد رازهای بسیار بزرگ است که می‌توانند سرور API و حافظه kubelet را اشغال کنند. با این حال، ایجاد بسیاری از رازهای کوچک‌تر نیز می‌تواند حافظه را اشغال کند. می‌توانید از [resource quota](/docs/concepts/policy/resource-quotas/) برای محدود کردن تعداد رازها (یا سایر منابع) در یک فضای نام استفاده کنید.

### ویرایش یک راز

شما می‌توانید یک راز موجود را ویرایش کنید، مگر اینکه [تغییرناپذیر](#secret-immutable) باشد. برای ویرایش یک راز، از یکی از روش‌های زیر استفاده کنید:

- [استقاده از `kubectl`](/docs/tasks/configmap-secret/managing-secret-using-kubectl/#edit-secret)
- [استفاده از یک پرونده پیکربندی](/docs/tasks/configmap-secret/managing-secret-using-config-file/#edit-secret)

همچنین می‌توانید با استفاده از ابزار Kustomize، داده‌های موجود در یک راز را ویرایش کنید (/docs/tasks/configmap-secret/managing-secret-using-kustomize/#edit-secret). با این حال، این روش یک شیء `Secret` جدید با داده‌های ویرایش شده ایجاد می‌کند.

بسته به نحوه ایجاد راز و همچنین نحوه استفاده از آن در پادهای شما، به‌روزرسانی‌های اشیاء `Secret` موجود به طور خودکار به پادهایی که از داده‌ها استفاده می‌کنند، منتشر می‌شوند. برای اطلاعات بیشتر، به بخش [استفاده از رازها به عنوان پرونده از یک پاد](#using-secrets-as-files-from-a-pod) مراجعه کنید.

### استفاده از یک راز

رازها می‌توانند به عنوان حجم‌های داده نصب شوند یا به عنوان {{< glossary_tooltip text="environment variables" term_id="container-env-variables" >}}
در معرض استفاده توسط یک کانتینر در یک پاد قرار گیرند. رازها همچنین می‌توانند توسط سایر بخش‌های سیستم، بدون اینکه مستقیماً در معرض پاد قرار گیرند، مورد استفاده قرار گیرند. به عنوان مثال، رازها می‌توانند حاوی اطلاعات احراز هویتی باشند که سایر بخش‌های سیستم باید از طرف شما برای تعامل با سیستم‌های خارجی از آنها استفاده کنند.

منابع حجم مخفی اعتبارسنجی می‌شوند تا اطمینان حاصل شود که مرجع شیء مشخص شده در واقع به شیء از نوع مخفی اشاره می‌کند. بنابراین، یک مخفی باید قبل از هر پادی که به آن وابسته است، ایجاد شود.

اگر رمز قابل دریافت نباشد (شاید به دلیل عدم وجود آن، یا به دلیل عدم اتصال موقت به سرور API)، kubelet به صورت دوره‌ای دوباره سعی می‌کند آن پاد را اجرا کند. kubelet همچنین یک رویداد برای آن پاد گزارش می‌دهد، از جمله جزئیات مشکل در دریافت رمز.

#### رازهای اختیاری {#restriction-secret-must-exist}

وقتی در یک پاد به یک راز اشاره می‌کنید، می‌توانید آن راز را به عنوان _اختیاری_ علامت‌گذاری کنید، مانند مثال زیر. اگر یک راز اختیاری وجود نداشته باشد، کوبرنتیز آن را نادیده می‌گیرد.

{{% code language="yaml" file="secret/optional-secret.yaml" %}}

به طور پیش‌فرض، رازها الزامی هستند. هیچ یک از کانتینرهای یک پاد تا زمانی که همه رازهای غیراختیاری در دسترس نباشند، شروع به کار نخواهند کرد.

اگر یک پاد به یک کلید خاص در یک راز غیراختیاری اشاره کند و آن راز وجود داشته باشد، اما کلید نامگذاری شده را نداشته باشد، پاد هنگام راه‌اندازی از کار می‌افتد.

### استفاده از رازها به عنوان پرونده از یک پاد {#using-secrets-as-files-from-a-pod}

اگر می‌خواهید به داده‌های یک راز در یک پاد دسترسی داشته باشید، یک راه برای انجام این کار این است که کوبرنتیز کاری کند که مقدار آن راز به عنوان یک پرونده در پرونده سیستم یک یا چند کانتینر پاد در دسترس باشد.

برای دستورالعمل‌ها، به [ایجاد یک پاد که از طریق یک درایو به داده‌های مخفی دسترسی دارد](/docs/tasks/inject-data-application/distribute-credentials-secure/#create-a-pod-that-has-access-to-the-secret-data-through-a-volume) مراجعه کنید.

وقتی یک درایو حاوی داده‌های یک راز است و آن راز به‌روزرسانی می‌شود، کوبرنتیز این موضوع را پیگیری کرده و داده‌های موجود در درایو را با استفاده از یک رویکرد در نهایت سازگار، به‌روزرسانی می‌کند.

{{< note >}}
کانتینری که از یک راز به عنوان یک [زیرمسیر](/docs/concepts/storage/volumes#using-subpath) برای متصل کردن یک درایو استفاده می‌کند، به‌روزرسانی‌های خودکار راز را دریافت نمی‌کند.
{{< /note >}}

kubelet یک حافظه پنهان از کلیدها و مقادیر فعلی برای رازهایی که در حجم های مربوط به پاد های آن گره استفاده می‌شوند، نگه می‌دارد. شما می‌توانید نحوه تشخیص تغییرات از مقادیر ذخیره شده توسط kubelet را پیکربندی کنید. بخش `configMapAndSecretChangeDetectionStrategy` در [پیکربندی kubelet](/docs/reference/config-api/kubelet-config.v1beta1/) راهبردی مورد استفاده kubelet را کنترل می‌کند. راهبرد پیش‌فرض `Watch` است.

به‌روزرسانی‌های مربوط به رازها می‌توانند یا توسط یک سازوکار نظارت API (پیش‌فرض)، بر اساس یک حافظه پنهان با زمان ماندگاری تعریف‌شده، یا از طریق سرور API خوشه‌ای در هر حلقه همگام‌سازی kubelet، منتشر شوند.

در نتیجه، کل تأخیر از لحظه به‌روزرسانی راز تا لحظه‌ای که کلیدهای جدید به پاد ارسال می‌شوند، می‌تواند به اندازه دوره همگام‌سازی kubelet + تأخیر انتشار حافظه پنهان باشد، که در آن تأخیر انتشار حافظه پنهان به نوع حافظه پنهان انتخاب شده بستگی دارد (به دنبال همان ترتیب ذکر شده در پاراگراف قبلی، این موارد عبارتند از: تأخیر انتشار نظارت، TTL حافظه پنهان پیکربندی شده یا صفر برای نظرسنجی مستقیم).

### استفاده از رازها به عنوان متغیرهای محیطی

برای استفاده از یک راز در یک {{< glossary_tooltip text="environment variable" term_id="container-env-variables" >}} در یک پاد:

1. برای هر کانتینر در مشخصات پاد خود، برای هر کلید مخفی که می‌خواهید استفاده کنید، یک متغیر محیطی به بخش `env[].valueFrom.secretKeyRef` اضافه کنید.
1. image و/یا خط فرمان خود را طوری تغییر دهید که برنامه به دنبال مقادیر در متغیرهای محیطی مشخص شده بگردد.

برای دستورالعمل‌ها، به [تعریف متغیرهای محیطی کانتینر با استفاده از داده‌های راز](/docs/tasks/inject-data-application/distribute-credentials-secure/#define-container-environment-variables-using-secret-data) مراجعه کنید.

لازم به ذکر است که محدوده کاراکترهای مجاز برای نام متغیرهای محیطی در پادها [محدود] است (/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config). اگر هر یک از کلیدها با قوانین مطابقت نداشته باشند، آن کلیدها در اختیار کانتینر شما قرار نمی‌گیرند، اگرچه پاد اجازه شروع به کار دارد.

### رازهای دریافت image کانتینر {#using-imagepullsecrets}

اگر می‌خواهید تصاویر کانتینر را از یک مخزن خصوصی دریافت کنید، به روشی نیاز دارید که kubelet روی هر گره بتواند به آن مخزن اعتبارسنجی شود. می‌توانید رمزهای دریافت image را برای امکان‌پذیر کردن این امر پیکربندی کنید. این رمزها در سطح پاد پیکربندی می‌شوند.

#### استفاده از دریافت image راز

بخش `imagePullSecrets` فهرستی از ارجاعات به رازها در همان فضای نام است. شما می‌توانید از `imagePullSecrets` برای ارسال یک راز که حاوی رمز عبور رجیستری image داکر (یا هر چیز دیگری) است به kubelet استفاده کنید. kubelet از این اطلاعات برای دریافت یک image خصوصی از طرف پاد شما استفاده می‌کند. برای اطلاعات بیشتر در مورد بخش `imagePullSecrets` به [مشخصات پاد API](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#podspec-v1-core) مراجعه کنید.

##### مشخص کردن دستی دریافت یک image راز

شما می‌توانید نحوه‌ی تعیین `imagePullSecrets` را از مستندات `[image های کانتینر](/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod)` بیاموزید.

##### تنظیم پیوست خودکار دریافت image راز

شما می‌توانید به صورت دستی `imagePullSecrets` را ایجاد کنید و از یک حساب سرویس به آنها ارجاع دهید. هر پاد که با آن حساب سرویس ایجاد شده باشد یا به طور پیش‌فرض با آن حساب سرویس ایجاد شده باشد، بخش `imagePullSecrets` خود را روی بخش مربوط به حساب سرویس تنظیم خواهد کرد. برای توضیح دقیق این فرآیند، به [Add ImagePullSecrets to a service account](/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account) مراجعه کنید.

### استفاده از رازها با پادهای ایستا {#restriction-static-pod}

شما نمی‌توانید از ConfigMaps یا رازها با {{< glossary_tooltip text="static Pods" term_id="static-pod" >}} استفاده کنید.

## رازهای تغییرناپذیر {#secret-immutable}

{{< feature-state for_k8s_version="v1.21" state="stable" >}}

کوبرنتیز به شما امکان می‌دهد تا رازهای خاص (و ConfigMaps) را به عنوان تغییرناپذیر علامت‌گذاری کنید.
جلوگیری از تغییر داده‌های یک راز موجود مزایای زیر را دارد:

- شما را از به‌روزرسانی‌های تصادفی (یا ناخواسته) که می‌توانند باعث قطع شدن برنامه‌ها شوند، محافظت می‌کند
- (برای خوشه هایی که به طور گسترده از رازها استفاده می‌کنند - حداقل ده‌ها هزار راز منحصر به فرد برای نصب در پاد)، تغییر به رازها تغییرناپذیر، عملکرد خوشه شما را با کاهش قابل توجه بار روی kube-apiserver بهبود می‌بخشد. kubelet نیازی به نگهداری [watch] روی هیچ رازها که به عنوان تغییرناپذیر علامت‌گذاری شده‌اند، ندارد.

### علامت‌گذاری یک راز به عنوان تغییرناپذیر {#secret-immutable-create}

شما می‌توانید با تنظیم بخش `immutable` روی `true`، یک «راز تغییرناپذیر» ایجاد کنید. برای مثال،

```yaml
apiVersion: v1
kind: Secret
metadata: ...
data: ...
immutable: true
```

همچنین می‌توانید هر راز تغییرپذیر موجود را به‌روزرسانی کنید تا تغییرناپذیر شود.

{{< note >}}
زمانی که یک راز یا ConfigMap به عنوان تغییرناپذیر علامت‌گذاری شود، برگرداندن این تغییر یا تغییر محتوای بخش `data` غیرممکن است. شما فقط می‌توانید راز را حذف و دوباره ایجاد کنید. پادهای موجود یک نقطه اتصال به راز حذف شده را حفظ می‌کنند - توصیه می‌شود این پادها را دوباره ایجاد کنید.
{{< /note >}}

## امنیت اطلاعات برای رازها

اگرچه ConfigMap و راز به طور مشابه کار می‌کنند، کوبرنتیز محافظت بیشتری را برای اشیاء راز اعمال می‌کند.

رازها اغلب مقادیری را در خود جای می‌دهند که طیف وسیعی از اهمیت را در بر می‌گیرند، که بسیاری از آنها می‌توانند باعث افزایش دسترسی در کوبرنتیز (مثلاً توکن‌های حساب سرویس) و سیستم‌های خارجی شوند. حتی اگر یک برنامه‌ی منفرد بتواند در مورد قدرت رازهایی که انتظار دارد با آنها تعامل داشته باشد، استدلال کند، برنامه‌های دیگر در همان فضای نام می‌توانند این فرضیات را نامعتبر کنند.

یک راز فقط در صورتی به یک گره ارسال می‌شود که پاد روی آن گره به آن نیاز داشته باشد. برای نصب رازها در پادها، kubelet یک رونوشت از داده‌ها را در `tmpfs` ذخیره می‌کند تا داده‌های محرمانه در حافظه پایدار نوشته نشوند. پس از حذف پادی که به راز وابسته است، kubelet رونوشت محلی داده‌های محرمانه خود را از راز حذف می‌کند.

ممکن است چندین کانتینر در یک پاد وجود داشته باشد. به طور پیش‌فرض، کانتینرهایی که شما تعریف می‌کنید فقط به حساب سرویس پیش‌فرض و راز مربوط به آن دسترسی دارند. برای دسترسی به هر راز دیگری، باید صریحاً متغیرهای محیطی را تعریف کنید یا یک حجم را به یک کانتینر نگاشت کنید.

ممکن است چندین پاد در یک گره دارای رازها باشند. با این حال، فقط رازهایی که یک پاد درخواست می‌کند، به طور بالقوه در کانتینرهای آن قابل مشاهده هستند. بنابراین، یک پاد به رازها پاد دیگر دسترسی ندارد.

### پیکربندی دسترسی با حداقل امتیاز به رازها

برای افزایش اقدامات امنیتی پیرامون رازها، از فضاهای نام جداگانه برای ایزوله کردن دسترسی به رازهای متصل شده استفاده کنید.

{{< warning >}}
هر کانتینری که با سطح دسترسی «privileged: true» روی یک گره اجرا شود، می‌تواند به تمام رمزهای استفاده شده در آن گره دسترسی داشته باشد.
{{< /warning >}}

## {{% heading "whatsnext" %}}

- برای راهنمایی‌هایی جهت مدیریت و بهبود امنیت اسرار خود، به [روش‌های خوب برای رازها کوبرنتیز](/docs/concepts/security/secrets-good-practices) مراجعه کنید.
- یاد بگیرید چگونه [مدیریت رازها با استفاده از `kubectl`](/docs/tasks/configmap-secret/managing-secret-using-kubectl/)
- یاد بگیرید چگونه [با استفاده از پرونده پیکربندی، رازها را مدیریت کنید](/docs/tasks/configmap-secret/managing-secret-using-config-file/)
- یاد بگیرید چگونه [مدیریت رازها با استفاده از kustomize](/docs/tasks/configmap-secret/managing-secret-using-kustomize/)
- برای `Secret` [مرجع API](/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/) را مطالعه کنید.
