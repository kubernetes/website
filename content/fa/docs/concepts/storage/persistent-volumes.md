---
reviewers:
- moh0ps
title: حجم‌های پایدار
api_metadata:
- apiVersion: "v1"
  kind: "PersistentVolume"
- apiVersion: "v1"
  kind: "PersistentVolumeClaim"
feature:
  title: Storage orchestration
  description: >
    Automatically mount the storage system of your choice, whether from local storage, a public cloud provider, or a network storage system such as iSCSI or NFS.
content_type: concept
weight: 20
---

<!-- overview -->

این سند، حجم های پایدار در کوبرنتیز را شرح می‌دهد. آشنایی با [حجم ها](/docs/concepts/storage/volumes/)، [کلاس های ذخیره سازی](/docs/concepts/storage/storage-classes/) و [کلاس‌های ویژگی‌های حجم](/docs/concepts/storage/volume-attributes-classes/) پیشنهاد می‌شود.

<!-- body -->

## مقدمه

مدیریت فضای ذخیره‌سازی، مسئله‌ای متمایز از مدیریت نمونه‌های محاسباتی است. زیرسیستم حجم پایدار یک API برای کاربران و مدیران فراهم می‌کند که جزئیات نحوه‌ی ارائه فضای ذخیره‌سازی را از نحوه‌ی مصرف آن جدا می‌کند. برای انجام این کار، دو منبع API جدید معرفی می‌کنیم: حجم پایدار و درخواست حجم پایدار.

یک حجم پایدار (PV) یک قطعه ذخیره‌سازی در خوشه است که توسط یک مدیر یا به صورت پویا با استفاده از [کلاس های ذخیره سازی](/docs/concepts/storage/storage-classes/) فراهم شده است. این یک منبع در خوشه است، درست مانند یک گره که یک منبع خوشه است. PVها افزونه‌های حجم مانند حجم ها هستند، اما چرخه عمر مستقلی از هر پاد جداگانه‌ای که از PV استفاده می‌کند، دارند. این شیء API جزئیات پیاده‌سازی ذخیره‌سازی را ثبت می‌کند، چه NFS، iSCSI یا یک سیستم ذخیره‌سازی مختص ارائه‌دهنده ابر.

درخواست حجم پایدار (PVC) درخواستی برای ذخیره‌سازی توسط کاربر است. این درخواست مشابه پاد است. پادها منابع گره و PVCها منابع PV را مصرف می‌کنند. پادها می‌توانند سطوح خاصی از منابع (CPU و Memory) را درخواست کنند. درخواست ها می‌توانند اندازه و حالت‌های دسترسی خاصی را درخواست کنند (مثلاً می‌توانند به صورت ReadWriteOnce، ReadOnlyMany، ReadWriteMany یا ReadWriteOncePod نصب شوند، به [حالت‌های دسترسی](#access-modes) مراجعه کنید).

در حالی که درخواست های حجم پایدار به کاربر اجازه می‌دهد از منابع ذخیره‌سازی انتزاعی استفاده کند، معمولاً کاربران برای مشکلات مختلف به حجم های پایدار با ویژگی‌های متفاوت، مانند عملکرد، نیاز دارند. مدیران خوشه باید بتوانند انواع حجم های پایداری را ارائه دهند که علاوه بر اندازه و حالت‌های دسترسی، از جهات دیگری نیز با یکدیگر متفاوت باشند، بدون اینکه کاربران را در جریان جزئیات نحوه پیاده‌سازی این حجم ها قرار دهند. برای این نیازها، منبع کلاس ذخیره سازی وجود دارد.

به [راهنمای کامل به همراه مثال‌های کاربردی](/docs/tasks/configure-pod-container/configure-persistent-volume-storage/) مراجعه کنید.

## چرخه حیات یک حجم و درخواست

حجم های پایدار منابعی در خوشه هستند. درخواست های حجم پایدار درخواست‌هایی برای آن منابع هستند و همچنین به عنوان بررسی‌های ادعایی برای منبع عمل می‌کنند. تعامل بین حجم های پایدار و درخواست های حجم پایدار از این چرخه حیات پیروی می‌کند:

### تأمین

دو روش برای تأمین حجم پایدار وجود دارد: ایستا یا پویا.

#### ایستا

یک مدیر خوشه تعدادی حجم پایدار ایجاد می‌کند. آن‌ها جزئیات فضای ذخیره‌سازی واقعی را که برای استفاده کاربران خوشه در دسترس است، حمل می‌کنند. آن‌ها در API کوبرنتیز وجود دارند و برای مصرف در دسترس هستند.

#### پویا

وقتی هیچ یک از حجم های پایدار ایستا ایجاد شده توسط مدیر با درخواست حجم پایدار کاربر مطابقت نداشته باشد، خوشه ممکن است سعی کند به صورت پویا یک حجم مخصوص درخواست حجم پایدار را فراهم کند. این تأمین بر اساس کلاس های ذخیره سازی است: درخواست حجم پایدار باید یک [کلاس ذخیره سازی] (/docs/concepts/storage/storage-classes/) درخواست کند و مدیر باید آن کلاس را برای تأمین پویا ایجاد و پیکربندی کرده باشد. درخواست هایی که کلاس `""` را درخواست می‌کنند، عملاً تأمین پویا را برای خود غیرفعال می‌کنند.

برای فعال کردن تأمین ذخیره‌سازی پویا بر اساس کلاس ذخیره‌سازی، مدیر خوشه باید `DefaultStorageClass` را در سرور API فعال کند. برای مثال، این کار را می‌توان با اطمینان از اینکه `DefaultStorageClass` در میان فهرست مقادیر مرتب و جدا شده با کاما برای پرچم `--enable-admission-plugins` از مؤلفه سرور API قرار دارد، انجام داد. برای اطلاعات بیشتر در مورد پرچم‌های خط فرمان سرور API، مستندات [kube-apiserver](/docs/reference/command-line-tools-reference/kube-apiserver/) را بررسی کنید.

### اتصال

یک کاربر یک درخواست حجم پایدار با مقدار مشخصی از فضای ذخیره‌سازی درخواستی و با حالت‌های دسترسی خاص ایجاد می‌کند، یا در صورت تأمین پویا، قبلاً ایجاد کرده است. یک حلقه کنترل در صفحه کنترل، درخواست های حجم پایدار جدید را زیر نظر می‌گیرد، یک حجم پایدار منطبق (در صورت امکان) پیدا می‌کند و آنها را به هم متصل می‌کند. اگر یک حجم پایدار به صورت پویا برای یک درخواست حجم پایدار جدید تأمین شده باشد، حلقه همیشه آن حجم پایدار را به حجم پایدار متصل می‌کند. در غیر این صورت، کاربر همیشه حداقل آنچه را که درخواست کرده است دریافت می‌کند، اما حجم ممکن است بیش از آنچه درخواست شده باشد. پس از اتصال، اتصالات درخواست حجم پایدار منحصر به فرد هستند، صرف نظر از نحوه اتصال آنها. اتصال درخواست حجم پایدار به حجم پایدار یک نگاشت یک به یک است که از مرجع درخواست استفاده می‌کند که یک اتصال دو طرفه بین حجم پایدار و درخواست حجم پایدار است.

اگر حجم منطبق وجود نداشته باشد، ادعاها به طور نامحدود بدون محدودیت باقی می‌مانند. با در دسترس قرار گرفتن حجم‌های منطبق، ادعاها محدود می‌شوند. به عنوان مثال، یک خوشه که با تعداد زیادی حجم پایدار با ظرفیت 50Gi تجهیز شده است، با درخواست حجم پایدار که درخواست 100Gi دارد، مطابقت نخواهد داشت. درخواست حجم پایدار می‌تواند زمانی محدود شود که یک حجم پایدار با ظرفیت 100Gi به خوشه اضافه شود.

### استفاده

پادها از درخواست ها به عنوان حجم استفاده می‌کنند. خوشه درخواست را بررسی می‌کند تا حجم محدود شده را پیدا کند و آن حجم را برای یک پاد متصل کند. برای حجم هایی که از حالت‌های دسترسی چندگانه پشتیبانی می‌کنند، کاربر مشخص می‌کند که هنگام استفاده از درخواست خود به عنوان حجم در یک پاد، کدام حالت مورد نظر است.

وقتی کاربری درخواستی داشته باشد و آن درخواست محدود شود، حجم پایدار محدود شده تا زمانی که به آن نیاز داشته باشد، متعلق به کاربر است. کاربران با گنجاندن بخش `persistentVolumeClaim` در بلوک `volumes` یک پاد، پادها را زمان‌بندی می‌کنند و به حجم های پایدار درخواستی خود دسترسی پیدا می‌کنند. برای جزئیات بیشتر در این مورد به [استفاده از درخواست ها به‌عنوان حجم](#claims-as-volumes) مراجعه کنید.

### محافظت از اشیاء ذخیره‌سازی در حال استفاده

هدف از ویژگی محافظت از اشیاء ذخیره‌سازی در حال استفاده این است که اطمینان حاصل شود که درخواست های حجم پایدار که به صورت فعال توسط یک پاد استفاده می‌شوند و حجم پایدار که به درخواست های حجم پایدار متصل هستند، از سیستم حذف نشوند، زیرا این امر ممکن است منجر به از دست رفتن داده‌ها شود.

{{< note >}}
درخواست حجم پایدار زمانی توسط یک پاد به صورت فعال استفاده می‌شود که یک شیء پاد وجود داشته باشد که از درخواست حجم پایدار استفاده کند.
{{< /note >}}

اگر کاربری یک درخواست حجم پایدار را که توسط یک پاد به طور فعال استفاده می‌شود، حذف کند، درخواست حجم پایدار بلافاصله حذف نمی‌شود. حذف درخواست حجم پایدار تا زمانی که درخواست حجم پایدار دیگر به طور فعال توسط هیچ پادی استفاده نشود، به تعویق می‌افتد. همچنین، اگر یک مدیر یک حجم پایدار را که به یک درخواست حجم پایدار متصل است حذف کند،حجم پایدار بلافاصله حذف نمی‌شود. حذف حجم پایدار تا زمانی که حجم پایدار دیگر به یک درخواست حجم پایدار متصل نباشد، به تعویق می‌افتد.

می‌توانید ببینید که یک درخواست حجم پایدار وقتی وضعیتش `Terminating` است و فهرست `Finalizers` شامل `kubernetes.io/pvc-protection` می‌شود، محافظت شده است:

```shell
kubectl describe pvc hostpath
Name:          hostpath
Namespace:     default
StorageClass:  example-hostpath
Status:        Terminating
Volume:
Labels:        <none>
Annotations:   volume.beta.kubernetes.io/storage-class=example-hostpath
               volume.beta.kubernetes.io/storage-provisioner=example.com/hostpath
Finalizers:    [kubernetes.io/pvc-protection]
...
```

می‌توانید ببینید که یک حجم پایدار وقتی وضعیتش `Terminating` است، محافظت می‌شود و فهرست `Finalizers` شامل `kubernetes.io/pv-protection` نیز می‌شود:

```shell
kubectl describe pv task-pv-volume
Name:            task-pv-volume
Labels:          type=local
Annotations:     <none>
Finalizers:      [kubernetes.io/pv-protection]
StorageClass:    standard
Status:          Terminating
Claim:
Reclaim Policy:  Delete
Access Modes:    RWO
Capacity:        1Gi
Message:
Source:
    Type:          HostPath (bare host directory volume)
    Path:          /tmp/data
    HostPathType:
Events:            <none>
```

### بازپس‌گیری

وقتی کاربری کارش با حجم تمام شد، می‌تواند اشیاء درخواست حجم پایدار را از API که امکان بازیابی منبع را فراهم می‌کند، حذف کند. سیاست بازیابی برای یک حجم پایدار به خوشه می‌گوید که پس از آزادسازی حجم، با آن چه کند. در حال حاضر، حجم ها می‌توانند یا حفظ شوند، یا بازیافت شوند یا حذف شوند.

#### حفظ 

سیاست بازپس‌گیری «حفظ» امکان بازپس‌گیری دستی منبع را فراهم می‌کند. هنگامی که درخواست حجم پایدار حذف می‌شود، حجم پایدار هنوز وجود دارد و درایو «آزاد شده» در نظر گرفته می‌شود. اما هنوز برای درخواست دیگری در دسترس نیست زیرا داده‌های درخواستی قبلی روی درایو باقی مانده است. یک مدیر می‌تواند با مراحل زیر درایو را به صورت دستی بازپس بگیرد.

1. حجم پایدار را حذف کنید. دارایی ذخیره‌سازی مرتبط در زیرساخت خارجی
پس از حذف حجم پایدار همچنان وجود دارد.
1. داده‌های مربوط به دارایی ذخیره‌سازی مرتبط را به صورت دستی و بر اساس آن پاک‌سازی کنید.
1. دارایی ذخیره‌سازی مرتبط را به صورت دستی حذف کنید.

اگر می‌خواهید از همان دارایی ذخیره‌سازی دوباره استفاده کنید، یک حجم پایدار جدید با همان تعریف دارایی ذخیره‌سازی ایجاد کنید.

#### حذف 

برای افزونه‌های حجمی که از سیاست بازپس‌گیری «حذف» پشتیبانی می‌کنند، حذف، هم شیء حجم پایدار را از کوبرنتیز و هم دارایی ذخیره‌سازی مرتبط در زیرساخت خارجی را حذف می‌کند. حجم هایی که به صورت پویا تأمین شده‌اند، [سیاست بازپس‌گیری کلاس ذخیره‌سازی خود](#reclaim-policy) را به ارث می‌برند که به طور پیش‌فرض روی «حذف» تنظیم شده است. مدیر باید کلاس ذخیره‌سازی را مطابق با انتظارات کاربران پیکربندی کند. در غیر این صورت، حجم پایدار باید پس از ایجاد، ویرایش یا اصلاح شود. به [تغییر سیاست بازپس‌گیری یک حجم پایدار](/docs/tasks/administer-cluster/change-pv-reclaim-policy/) مراجعه کنید.

#### بازیافت

{{< warning >}}
سیاست بازیابی `Recycle` منسوخ شده است. در عوض، رویکرد پیشنهادی استفاده از تأمین پویا است.
{{< /warning >}}

اگر افزونه‌ی درایو مورد نظر از سیاست بازیابی `Recycle` پشتیبانی کند، این سیاست یک پاکسازی اولیه (`rm -rf /thevolume/*`) روی درایو انجام می‌دهد و آن را دوباره برای درخواست جدید در دسترس قرار می‌دهد.

با این حال، یک مدیر می‌تواند یک قالب پاد بازیافت‌کننده سفارشی را با استفاده از پارامترهای خط فرمان مدیر کنترل کننده کوبرنتیز همانطور که در [مرجع](/docs/reference/command-line-tools-reference/kube-controller-manager/ توضیح داده شده است، پیکربندی کند. قالب پاد بازیافت‌کننده سفارشی باید حاوی مشخصات `volumes` باشد، همانطور که در مثال زیر نشان داده شده است:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pv-recycler
  namespace: default
spec:
  restartPolicy: Never
  volumes:
  - name: vol
    hostPath:
      path: /any/path/it/will/be/replaced
  containers:
  - name: pv-recycler
    image: "registry.k8s.io/busybox"
    command: ["/bin/sh", "-c", "test -e /scrub && rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  && test -z \"$(ls -A /scrub)\" || exit 1"]
    volumeMounts:
    - name: vol
      mountPath: /scrub
```

با این حال، مسیر خاص مشخص شده در الگوی پاد بازیافت سفارشی در بخش `volumes` با مسیر خاص حجم که در حال بازیافت است جایگزین می‌شود.

### نهایی کننده محافظت در برابر حذف حجم پایدار
{{< feature-state feature_gate_name="HonorPVReclaimPolicy" >}}

می‌توان نهایی کننده ها را به یک حجم پایدار اضافه کرد تا اطمینان حاصل شود که حجم پایدارهایی که دارای سیاست بازیابی `Delete` هستند، تنها پس از حذف فضای ذخیره‌سازی پشتیبان، حذف می‌شوند.

نهایی کننده `external-provisioner.volume.kubernetes.io/finalizer` (که در نسخه ۱.۳۱ معرفی شد) به هر دو نوع Volume CSI که به صورت پویا و ایستا ارائه شده‌اند، اضافه می‌شود.

نهایی کننده `kubernetes.io/pv-controller` (معرفی‌شده در نسخه ۱.۳۱) به حجم‌های افزونه درون‌درختی که به صورت پویا فراهم شده‌اند اضافه می‌شود و برای حجم‌های افزونه درون‌درختی که به صورت ایستا فراهم شده‌اند، نادیده گرفته می‌شود.

در زیر مثالی از حجم افزونه درون درختی که به صورت پویا تهیه شده است، آمده است:

```shell
kubectl describe pv pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
Name:            pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
Labels:          <none>
Annotations:     kubernetes.io/createdby: vsphere-volume-dynamic-provisioner
                 pv.kubernetes.io/bound-by-controller: yes
                 pv.kubernetes.io/provisioned-by: kubernetes.io/vsphere-volume
Finalizers:      [kubernetes.io/pv-protection kubernetes.io/pv-controller]
StorageClass:    vcp-sc
Status:          Bound
Claim:           default/vcp-pvc-1
Reclaim Policy:  Delete
Access Modes:    RWO
VolumeMode:      Filesystem
Capacity:        1Gi
Node Affinity:   <none>
Message:
Source:
    Type:               vSphereVolume (a Persistent Disk resource in vSphere)
    VolumePath:         [vsanDatastore] d49c4a62-166f-ce12-c464-020077ba5d46/kubernetes-dynamic-pvc-74a498d6-3929-47e8-8c02-078c1ece4d78.vmdk
    FSType:             ext4
    StoragePolicyName:  vSAN Default Storage Policy
Events:                 <none>
```

نهایی کننده `external-provisioner.volume.kubernetes.io/finalizer` برای حجم‌های CSI اضافه می‌شود. نمونه‌ای از آن به شرح زیر است:

```shell
Name:            pvc-2f0bab97-85a8-4552-8044-eb8be45cf48d
Labels:          <none>
Annotations:     pv.kubernetes.io/provisioned-by: csi.vsphere.vmware.com
Finalizers:      [kubernetes.io/pv-protection external-provisioner.volume.kubernetes.io/finalizer]
StorageClass:    fast
Status:          Bound
Claim:           demo-app/nginx-logs
Reclaim Policy:  Delete
Access Modes:    RWO
VolumeMode:      Filesystem
Capacity:        200Mi
Node Affinity:   <none>
Message:
Source:
    Type:              CSI (a Container Storage Interface (CSI) volume source)
    Driver:            csi.vsphere.vmware.com
    FSType:            ext4
    VolumeHandle:      44830fa8-79b4-406b-8b58-621ba25353fd
    ReadOnly:          false
    VolumeAttributes:      storage.kubernetes.io/csiProvisionerIdentity=1648442357185-8081-csi.vsphere.vmware.com
                           type=vSphere CNS Block Volume
Events:                <none>
```

وقتی پرچم ویژگی `CSIMigration{provider}` برای یک افزونه‌ی حجم درون‌درختی خاص فعال می‌شود، نهایی‌کننده `kubernetes.io/pv-controller` با نهایی‌کننده `external-provisioner.volume.kubernetes.io/finalizer` جایگزین می‌شود.

نهایی‌سازها تضمین می‌کنند که شیء حجم پایدار تنها پس از حذف شدن درایو از فضای ذخیره‌سازی، در صورتی که سیاست بازیابی حجم پایدار روی `Delete` باشد، حذف می‌شود. این امر همچنین تضمین می‌کند که درایو صرف نظر از ترتیب حذف حجم پایدار و درخواست حجم پایدار، از فضای ذخیره‌سازی حذف می‌شود.

### رزرو یک حجم پایدار

صفحه کنترل می‌تواند [درخواست حجم پایدار را به حجم های پایدار منطبق](#binding) در خوشه متصل کند. با این حال، اگر می‌خواهید یک درخواست حجم پایدار به یک حجم پایدار خاص متصل شود، باید آنها را از قبل متصل کنید.

با مشخص کردن یک حجم پایدار در یک درخواست حجم پایدار، شما یک اتصال بین آن حجم پایدار خاص و درخواست حجم پایدار اعلام می‌کنید. اگر حجم پایدار وجود داشته باشد و درخواست حجم پایدار را از طریق بخش `claimRef` خود رزرو نکرده باشد، آنگاه حجم پایدار و درخواست حجم پایدار به هم متصل خواهند شد.

اتصال صرف نظر از برخی معیارهای تطبیق حجم، از جمله وابستگی گره، اتفاق می‌افتد. صفحه کنترل همچنان بررسی می‌کند که [کلاس ذخیره‌سازی](/docs/concepts/storage/storage-classes/)، حالت‌های دسترسی و اندازه ذخیره‌سازی درخواستی معتبر باشند.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: foo-pvc
  namespace: foo
spec:
  storageClassName: "" # رشته خالی باید صریحاً تنظیم شود، در غیر این صورت کلاس ذخیره سازی پیش‌فرض تنظیم خواهد شد.
  volumeName: foo-pv
  ...
```

این روش هیچ گونه امتیاز اتصال به حجم پایدار را تضمین نمی‌کند. اگر درخواست حجم پایدار دیگری بتواند از حجم پایدار که شما مشخص کرده‌اید استفاده کند، ابتدا باید آن حجم ذخیره‌سازی را رزرو کنید. درخواست حجم پایدار مربوطه را در بخش `claimRef` حجم پایدار مشخص کنید تا درخواست حجم های پایدار دیگر نتوانند به آن متصل شوند.

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: foo-pv
spec:
  storageClassName: ""
  claimRef:
    name: foo-pvc
    namespace: foo
  ...
```

این قابلیت در صورتی مفید است که بخواهید از حجم های پایداری استفاده کنید که `persistentVolumeReclaimPolicy` آنها روی `Retain` تنظیم شده باشد، از جمله مواردی که از یک حجم پایدار موجود دوباره استفاده می‌کنید.

### درخواست های مربوط به افزایش حجم‌های پایدار

{{< feature-state for_k8s_version="v1.24" state="stable" >}}

پشتیبانی از گسترش درخواست های حجم پایدار به طور پیش‌فرض فعال است. می‌توانید انواع حجم های زیر را گسترش دهید:

* {{< glossary_tooltip text="csi" term_id="csi" >}} (شامل برخی از انواع حجم مهاجرت‌شده‌ی CSI)
* flexVolume (منسوخ شده)
* portworxVolume (منسوخ شده)

شما فقط در صورتی می‌توانید یک درخواست حجم پایدار را گسترش دهید که بخش `allowVolumeExpansion` کلاس ذخیره‌سازی آن روی true تنظیم شده باشد.

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: example-vol-default
provisioner: vendor-name.example/magicstorage
parameters:
  resturl: "http://192.168.10.100:8080"
  restuser: ""
  secretNamespace: ""
  secretName: ""
allowVolumeExpansion: true
```

برای درخواست یک حجم بزرگتر برای درخواست حجم پایدار، شیء درخواست حجم پایدار را ویرایش کرده و اندازه بزرگتری را مشخص کنید. این باعث گسترش حجمی می‌شود که از حجم پایدار زیرین پشتیبانی می‌کند. یک حجم پایدار جدید هرگز برای برآورده کردن این درخواست ایجاد نمی‌شود. در عوض، یک حجم موجود تغییر اندازه می‌دهد.

{{< warning >}}
ویرایش مستقیم اندازه یک حجم پایدار می‌تواند از تغییر خودکار اندازه آن حجم جلوگیری کند. اگر ظرفیت یک حجم پایدار را ویرایش کنید و سپس `.spec` یک درخواست حجم پایدار منطبق را ویرایش کنید تا اندازه درخواست حجم پایدار با حجم پایدار مطابقت داشته باشد، هیچ تغییر اندازه ذخیره‌سازی اتفاق نمی‌افتد. صفحه کنترل کوبرنتیز مشاهده می‌کند که وضعیت مطلوب هر دو منبع مطابقت دارد و نتیجه می‌گیرد که اندازه حجم پشتیبان به صورت دستی افزایش یافته است و نیازی به تغییر اندازه نیست.
{{< /warning >}}

#### افزایش حجم CSI

{{< feature-state for_k8s_version="v1.24" state="stable" >}}

پشتیبانی از افزایش حجم‌های CSI به طور پیش‌فرض فعال است، اما برای پشتیبانی از افزایش حجم، به یک درایور CSI خاص نیز نیاز دارد. برای اطلاعات بیشتر به مستندات درایور CSI خاص مراجعه کنید.

#### تغییر اندازه یک حجم حاوی پرونده سیستم

شما فقط می‌توانید اندازه‌ی پارتیشن‌های حاوی پرونده سیستم را تغییر دهید، اگر پرونده سیستم XFS، Ext3 یا Ext4 باشد.

وقتی یک حجم حاوی یک پرونده سیستم باشد، پرونده سیستم فقط زمانی تغییر اندازه می‌دهد که یک پاد جدید از درخواست حجم پایدار در حالت `ReadWrite` استفاده کند. افزایش پرونده سیستم یا هنگام راه‌اندازی پاد انجام می‌شود یا زمانی که پاد در حال اجرا است و پرونده سیستم زیرین از گسترش آنلاین پشتیبانی می‌کند.

FlexVolumes (که از زمان کوبرنتیز نسخه ۱.۲۳ منسوخ شده است) در صورتی که درایور با قابلیت `RequiresFSResize` روی `true` پیکربندی شده باشد، امکان تغییر اندازه را فراهم می‌کند. FlexVolume را می‌توان در راه‌اندازی مجدد پاد تغییر اندازه داد.

#### تغییر اندازه یک درخواست حجم پایدار در حال استفاده

{{< feature-state for_k8s_version="v1.24" state="stable" >}}

در این حالت، نیازی به حذف و ایجاد مجدد یک پاد یا استقرار که از درخواست حجم پایدار موجود استفاده می‌کند، ندارید. هر درخواست حجم پایدار در حال استفاده، به محض اینکه سیستم فایل آن گسترش یابد، به طور خودکار در دسترس پاد خود قرار می‌گیرد. این ویژگی هیچ تاثیری بر درخواست حجم های پایداری که توسط پاد یا استقرار استفاده نمی‌شوند، ندارد. شما باید قبل از تکمیل گسترش، پادی ایجاد کنید که از درخواست حجم پایدار استفاده کند.

مشابه سایر انواع حجم، حجم‌های FlexVolume نیز می‌توانند هنگام استفاده توسط یک پاد افزایش یابند.

{{< note >}}
تغییر اندازه FlexVolume فقط زمانی امکان‌پذیر است که راه انداز مربوطه از تغییر اندازه پشتیبانی کند.
{{< /note >}}

#### بازیابی از شکست هنگام گسترش حجم‌ها

اگر کاربری اندازه جدیدی را مشخص کند که برای سیستم ذخیره‌سازی زیرین بسیار بزرگ باشد، گسترش درخواست حجم پایدار به طور مداوم تکرار می‌شود تا زمانی که کاربر یا مدیر خوشه اقدامی انجام دهد. این می‌تواند نامطلوب باشد و از این رو کوبرنتیز روش‌های زیر را برای بازیابی از چنین خرابی‌هایی ارائه می‌دهد.

{{< tabs name="recovery_methods" >}}
{{% tab name="Manually with Cluster Administrator access" %}}

اگر گسترش فضای ذخیره‌سازی اصلی با شکست مواجه شود، مدیر خوشه می‌تواند به صورت دستی وضعیت درخواست حجم پایدار (PVC) را بازیابی کرده و درخواست‌های تغییر اندازه را لغو کند. در غیر این صورت، درخواست‌های تغییر اندازه به طور مداوم توسط کنترل‌کننده و بدون دخالت مدیر، دوباره بررسی می‌شوند.

1. حجم پایدار که به درخواست حجم پایدار متصل است را با سیاست بازپس‌گیری `Retain` علامت‌گذاری کنید.
2. درخواست حجم پایدار را حذف کنید. از آنجایی که حجم پایدار سیاست بازیابی `Retain` را دارد، هنگام ایجاد مجدد درخواست حجم پایدار هیچ داده‌ای را از دست نخواهیم داد.
3. ورودی `claimRef` را از مشخصات حجم پایدار حذف کنید تا درخواست حجم پایدار جدید بتواند به آن متصل شود. این کار باید حجم پایدار را `Available` کند.
4. درخواست حجم پایدار را با اندازه‌ای کوچک‌تر از حجم پایدار دوباره ایجاد کنید و بخش `volumeName` مربوط به درخواست حجم پایدار را برابر با نام حجم پایدار قرار دهید. این کار باید درخواست حجم پایدار جدید را به حجم پایدار موجود متصل کند.
5. فراموش نکنید که سیاست بازپس‌گیری حجم پایدار را دوباره فعال کنید.

{{% /tab %}}
{{% tab name="By requesting expansion to smaller size" %}}
{{< feature-state feature_gate_name="RecoverVolumeExpansionFailure" >}}

{{< note >}}
بازیابی از شکست گسترش درخواست حجم پایدار توسط کاربران (`RecoverVolumeExpansionFailure`) به عنوان یک ویژگی بتا از کوبرنتیز 1.32 در دسترس است و باید به طور پیش‌فرض فعال باشد. برای اطلاعات بیشتر به مستندات `[feature gate](/docs/reference/command-line-tools-reference/feature-gates/)` مراجعه کنید.
{{< /note >}}


هنگام استفاده از ویژگی `RecoverVolumeExpansionFailure`، اگر گسترش برای یک درخواست حجم پایدار با شکست مواجه شود، می‌توانید گسترش را با اندازه‌ای کوچکتر از مقدار درخواستی قبلی دوباره امتحان کنید. برای درخواست یک تلاش گسترش جدید با اندازه پیشنهادی کوچکتر، `.spec.resources` را برای آن درخواست حجم پایدار ویرایش کنید و مقداری کمتر از مقداری که قبلاً امتحان کرده‌اید انتخاب کنید. این مفید است اگر گسترش به مقدار بالاتر به دلیل محدودیت ظرفیت موفقیت‌آمیز نبود. اگر این اتفاق افتاده است، یا گمان می‌کنید که ممکن است رخ داده باشد، می‌توانید با مشخص کردن اندازه‌ای که در محدوده ظرفیت ارائه دهنده ذخیره‌سازی اصلی است، گسترش را دوباره امتحان کنید. می‌توانید با مشاهده `.status.allocatedResourceStauses` و رویدادهای روی درخواست حجم پایدار، وضعیت عملیات تغییر اندازه را رصد کنید.

توجه داشته باشید که اگرچه می‌توانید مقدار فضای ذخیره‌سازی کمتری نسبت به آنچه قبلاً درخواست شده بود، تعیین کنید، اما مقدار جدید همچنان باید بالاتر از `.status.capacity` باشد. کوبرنتیز از کوچک کردن درخواست حجم پایدار به کمتر از اندازه فعلی آن پشتیبانی نمی‌کند.
{{% /tab %}}
{{% /tabs %}}

## Types of Persistent Volumes

انواع حجم پایدار به صورت افزونه پیاده‌سازی می‌شوند. کوبرنتیز در حال حاضر از افزونه‌های زیر پشتیبانی می‌کند:

* [`csi`](/docs/concepts/storage/volumes/#csi) - رابط ذخیره‌سازی کانتینر (CSI)
* [`fc`](/docs/concepts/storage/volumes/#fc) - ذخیره‌سازی کانال فیبر (FC)
* [`hostPath`](/docs/concepts/storage/volumes/#hostpath) - حجم HostPath (فقط برای آزمایش تک گره؛ در یک خوشه چند گره‌ای کار نخواهد کرد؛ به جای آن از حجم «محلی» استفاده کنید)
* [`iscsi`](/docs/concepts/storage/volumes/#iscsi) - ذخیره‌سازی iSCSI (SCSI روی IP)
* [`local`](/docs/concepts/storage/volumes/#local) - دستگاه‌های ذخیره‌سازی محلی که روی گره‌ها نصب شده‌اند.
* [`nfs`](/docs/concepts/storage/volumes/#nfs) - ذخیره‌سازی پرونده سیستم شبکه (NFS)

انواع حجم پایدار زیر منسوخ شده‌اند اما هنوز در دسترس هستند. اگر از این انواع حجم به جز `flexVolume`، `cephfs` و `rbd` استفاده می‌کنید، لطفاً راه اندازهای CSI مربوطه را نصب کنید.

* [`awsElasticBlockStore`](/docs/concepts/storage/volumes/#awselasticblockstore) - AWS Elastic Block Store (EBS)
  (**مهاجرت به طور پیش فرض فعال است** شروع نسخه 1.23)
* [`azureDisk`](/docs/concepts/storage/volumes/#azuredisk) - Azure Disk
  (**مهاجرت به طور پیش فرض فعال است** شروع نسخه 1.23)
* [`azureFile`](/docs/concepts/storage/volumes/#azurefile) - Azure File
  (**مهاجرت به طور پیش فرض فعال است** شروع نسخه 1.24)
* [`cinder`](/docs/concepts/storage/volumes/#cinder) - Cinder (OpenStack block storage)
  (**مهاجرت به طور پیش فرض فعال است** شروع نسخه 1.21)
* [`flexVolume`](/docs/concepts/storage/volumes/#flexvolume) - FlexVolume
  (**از نسخه ۱.۲۳ منسوخ شده**، هیچ برنامه مهاجرتی وجود ندارد و هیچ برنامه‌ای برای حذف پشتیبانی نیز وجود ندارد)
* [`gcePersistentDisk`](/docs/concepts/storage/volumes/#gcePersistentDisk) - GCE Persistent Disk
  (**مهاجرت به طور پیش فرض فعال است** شروع نسخه 1.23)
* [`portworxVolume`](/docs/concepts/storage/volumes/#portworxvolume) - Portworx volume
  (**مهاجرت به طور پیش فرض فعال است** شروع نسخه 1.31)
* [`vsphereVolume`](/docs/concepts/storage/volumes/#vspherevolume) - vSphere VMDK volume
  (**مهاجرت به طور پیش فرض فعال است** شروع نسخه 1.25)

نسخه‌های قدیمی‌تر کوبرنتیز همچنین از انواع حجم پایدار درون‌درختی زیر پشتیبانی می‌کردند:

* [`cephfs`](/docs/concepts/storage/volumes/#cephfs)
  (**در دسترس نیست** شروع نسخه 1.31)
* `flocker` - Flocker storage.
  (**در دسترس نیست** شروع نسخه 1.25)
* `glusterfs` - GlusterFS storage.
  (**در دسترس نیست** شروع نسخه 1.26)
* `photonPersistentDisk` - دیسک پایدار کنترل‌کننده فوتون.
  (**در دسترس نیست** شروع نسخه 1.15)
* `quobyte` - Quobyte volume.
  (**در دسترس نیست** شروع نسخه 1.25)
* [`rbd`](/docs/concepts/storage/volumes/#rbd) - Rados Block Device (RBD) volume 
  (**در دسترس نیست** شروع نسخه 1.31)
* `scaleIO` - ScaleIO volume.
  (**در دسترس نیست** شروع نسخه 1.21)
* `storageos` - StorageOS volume.
  (**در دسترس نیست** شروع نسخه 1.25)

## حجم های پایدار

هر حجم پایدار شامل یک مشخصات و وضعیت است که مشخصات و وضعیت حجم را نشان می‌دهد. نام یک شیء حجم پایدار باید یک [نام زیر دامنه DNS] معتبر باشد (/docs/concepts/overview/working-with-objects/names#dns-subdomain-names).

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0003
spec:
  capacity:
    storage: 5Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Recycle
  storageClassName: slow
  mountOptions:
    - hard
    - nfsvers=4.1
  nfs:
    path: /tmp
    server: 172.17.0.2
```

{{< note >}}
ممکن است برای مصرف یک حجم پایدار در یک خوشه، برنامه‌های کمکی مربوط به نوع حجم مورد نیاز باشند. در این مثال، حجم پایدار از نوع NFS است و برنامه کمکی /sbin/mount.nfs برای پشتیبانی از متصل کردن پرونده سیستم NFS مورد نیاز است.
{{< /note >}}

### ظرفیت

به‌طورکلی، یک حجم پایدار ظرفیت ذخیره‌سازی مشخصی خواهد داشت. این ظرفیت با استفاده از ویژگی `capacity` حجم پایدار تنظیم می‌شود که یک مقدار {{< glossary_tooltip term_id="quantity" >}} است.

در حال حاضر، اندازه حافظه تنها منبعی است که می‌توان تنظیم یا درخواست کرد. ویژگی‌های آینده ممکن است شامل IOPS، توان عملیاتی و غیره باشد.

### حالت حجم

{{< feature-state for_k8s_version="v1.18" state="stable" >}}

کوبرنتیز از دو `volumeModes` از حجم های پایدار پشتیبانی می‌کند: `Filesystem` و `Block`.

`volumeMode` یک پارامتر API اختیاری است.
حالت پیش‌فرض مورد استفاده در صورت حذف پارامتر `volumeMode`، حالت `Filesystem` است.

یک حجم با `volumeMode: Filesystem` در پادها و در یک پوشه *متصل* می‌شود. اگر حجم توسط یک دستگاه بلوکی پشتیبانی شود و دستگاه خالی باشد، کوبرنتیز قبل از اولین متصل کردن آن، یک پرونده سیستم روی دستگاه ایجاد می‌کند.

می‌توانید مقدار `volumeMode` را روی `Block` تنظیم کنید تا از یک حجم به عنوان یک دستگاه بلوک خام استفاده شود. چنین حجمی به عنوان یک دستگاه بلوک، بدون هیچ پرونده سیستمی روی آن، در یک پاد ارائه می‌شود. این حالت برای ارائه سریع‌ترین راه ممکن برای دسترسی به یک حجم، بدون هیچ لایه پرونده سیستمی بین پاد و حجم، به پاد مفید است. از سوی دیگر، برنامه‌ای که در پاد اجرا می‌شود باید بداند چگونه با یک دستگاه بلوک خام کار کند. برای مثالی در مورد نحوه استفاده از یک حجم با `volumeMode: Block` در یک پاد، به [پشتیبانی از حجم بلوک خام](#raw-block-volume-support) مراجعه کنید.

### حالت‌های دسترسی

یک حجم پایدار می‌تواند به هر روشی که توسط ارائه‌دهنده منبع پشتیبانی می‌شود، روی یک میزبان نصب شود. همانطور که در جدول زیر نشان داده شده است، ارائه‌دهندگان قابلیت‌های متفاوتی خواهند داشت و حالت‌های دسترسی هر حجم پایدار بر روی حالت‌های خاصی که توسط آن حجم خاص پشتیبانی می‌شوند، تنظیم می‌شوند. به عنوان مثال، NFS می‌تواند از چندین کلاینت خواندن/نوشتن پشتیبانی کند، اما یک NFS حجم پایدار خاص ممکن است به صورت فقط خواندنی روی سرور صادر شود. هر حجم پایدار مجموعه حالت‌های دسترسی خاص خود را دارد که قابلیت‌های آن حجم پایدار خاص را توصیف می‌کند.

حالت‌های دسترسی عبارتند از:

`ReadWriteOnce`
: این حجم می‌تواند توسط یک گره واحد به صورت خواندنی-نوشتنی مونت شود. حالت دسترسی ReadWriteOnce همچنان می‌تواند به چندین پاد اجازه دهد تا به آن حجم دسترسی داشته باشند (از آن بخوانند یا در آن بنویسند) وقتی که پادها روی یک گره اجرا می‌شوند. برای دسترسی به یک پاد، لطفاً به ReadWriteOncePod مراجعه کنید.

`ReadOnlyMany`
: این درایو می‌تواند توسط بسیاری از گره‌ها به صورت فقط خواندنی نصب شود.

`ReadWriteMany`
: این درایو می‌تواند توسط بسیاری از گره‌ها به صورت خواندنی-نوشتنی نصب شود.

 `ReadWriteOncePod`
: {{< feature-state for_k8s_version="v1.29" state="stable" >}}
  این حجم می‌تواند توسط یک پاد به صورت خواندنی-نوشتنی نصب شود. اگر می‌خواهید مطمئن شوید که فقط یک پاد در کل خوشه می‌تواند آن درخواست حجم پایدار را بخواند یا در آن بنویسد، از حالت دسترسی ReadWriteOncePod استفاده کنید.

{{< note >}}
حالت دسترسی `ReadWriteOncePod` فقط برای {{< glossary_tooltip text="CSI" term_id="csi" >}} حجم ها و نسخه کوبرنتیز 1.22+ پشتیبانی می‌شود. برای استفاده از این ویژگی، باید موارد زیر را به این نسخه‌ها یا نسخه‌های بالاتر به‌روزرسانی کنید:

* [csi-provisioner:v3.0.0+](https://github.com/kubernetes-csi/external-provisioner/releases/tag/v3.0.0)
* [csi-attacher:v3.3.0+](https://github.com/kubernetes-csi/external-attacher/releases/tag/v3.3.0)
* [csi-resizer:v1.3.0+](https://github.com/kubernetes-csi/external-resizer/releases/tag/v1.3.0)
{{< /note >}}

در رابط خط فرمان (CLI)، حالت‌های دسترسی به صورت خلاصه به صورت زیر هستند:

* RWO - ReadWriteOnce
* ROX - ReadOnlyMany
* RWX - ReadWriteMany
* RWOP - ReadWriteOncePod

{{< note >}}
کوبرنتیز از حالت‌های دسترسی به حجم برای تطبیق با درخواست های حجم پایدار و حجم های پایدار استفاده می‌کند. در برخی موارد، حالت‌های دسترسی به حجم همچنین محل نصب حجم پایدار را محدود می‌کنند. حالت‌های دسترسی به حجم پس از نصب فضای ذخیره‌سازی، محافظت در برابر نوشتن را اعمال نمی‌کنند. حتی اگر حالت‌های دسترسی به صورت ReadWriteOnce، ReadOnlyMany یا ReadWriteMany مشخص شوند، هیچ محدودیتی بر حجم اعمال نمی‌کنند. به عنوان مثال، حتی اگر یک حجم پایدار به صورت ReadOnlyMany ایجاد شود، هیچ تضمینی وجود ندارد که فقط خواندنی باشد. اگر حالت‌های دسترسی به صورت ReadWriteOncePod مشخص شوند، حجم محدود شده و فقط می‌تواند روی یک پاد نصب شود.
{{< /note >}}

> __Important!__ یک درایو فقط می‌تواند با استفاده از یک حالت دسترسی در یک زمان نصب شود،
> حتی اگر از بسیاری پشتیبانی کند.

| Volume Plugin        | ReadWriteOnce          | ReadOnlyMany          | ReadWriteMany | ReadWriteOncePod       |
| :---                 | :---:                  | :---:                 | :---:         | -                      |
| AzureFile            | &#x2713;               | &#x2713;              | &#x2713;      | -                      |
| CephFS               | &#x2713;               | &#x2713;              | &#x2713;      | -                      |
| CSI                  | depends on the driver  | depends on the driver | depends on the driver | depends on the driver |
| FC                   | &#x2713;               | &#x2713;              | -             | -                      |
| FlexVolume           | &#x2713;               | &#x2713;              | depends on the driver | -              |
| HostPath             | &#x2713;               | -                     | -             | -                      |
| iSCSI                | &#x2713;               | &#x2713;              | -             | -                      |
| NFS                  | &#x2713;               | &#x2713;              | &#x2713;      | -                      |
| RBD                  | &#x2713;               | &#x2713;              | -             | -                      |
| VsphereVolume        | &#x2713;               | -                     | - (works when Pods are collocated) | - |
| PortworxVolume       | &#x2713;               | -                     | &#x2713;      | -                  | - |

### کلاس

یک حجم پایدار می‌تواند یک کلاس داشته باشد که با تنظیم ویژگی `storageClassName` به نام یک `[StorageClass](/docs/concepts/storage/storage-classes/` مشخص می‌شود. یک حجم پایدار از یک کلاس خاص فقط می‌تواند به درخواست حجم های پایدار که آن کلاس را درخواست می‌کنند، متصل شود. یک حجم پایدار بدون `storageClassName` کلاسی ندارد و فقط می‌تواند به درخواست حجم های پایدار که کلاس خاصی را درخواست نمی‌کنند، متصل شود.

در گذشته، به جای ویژگی `storageClassName` از حاشیه‌نویسی `volume.beta.kubernetes.io/storage-class` استفاده می‌شد. این حاشیه‌نویسی هنوز کار می‌کند؛ با این حال، در نسخه بعدی کوبرنتیز کاملاً منسوخ خواهد شد.

### سیاست بازپس‌گیری

سیاست‌های فعلی بازپس‌گیری عبارتند از:

* Retain -- بازپس گیری دستی
* Recycle -- scrub اولیه (`rm -rf /thevolume/*`)
* Delete -- حذف حجم

برای کوبرنتیز {{< skew currentVersion >}}، فقط انواع درایوهای `nfs` و `hostPath` از بازیافت پشتیبانی می‌کنند.

### گزینه‌های اتصال

مدیر کوبرنتیز می‌تواند گزینه‌های اتصال اضافی را برای زمانی که یک حجم ماندگار روی یک گره نصب می‌شود، مشخص کند.

{{< note >}}
همه انواع درایوهای پایدار از گزینه‌های اتصال پشتیبانی نمی‌کنند.
{{< /note >}}

انواع درایوهای زیر از گزینه‌های اتصال پشتیبانی می‌کنند:

* `csi` (including CSI migrated volume types)
* `iscsi`
* `nfs`

گزینه‌های اتصال اعتبارسنجی نشده‌اند. اگر یک گزینه اتصال نامعتبر باشد، اتصال با شکست مواجه می‌شود.

در گذشته، به جای ویژگی `mountOptions` از حاشیه‌نویسی `volume.beta.kubernetes.io/mount-options` استفاده می‌شد. این حاشیه‌نویسی هنوز کار می‌کند؛ با این حال، در نسخه بعدی کوبرنتیز کاملاً منسوخ خواهد شد.

### وابستگی به گره

{{< note >}}
برای اکثر انواع حجم، نیازی به تنظیم این بخش ندارید.
شما باید این مورد را به طور صریح برای درایوهای [محلی](/docs/concepts/storage/volumes/#local) تنظیم کنید.
{{< /note >}}

یک حجم پایدار می‌تواند وابستگی گره را مشخص کند تا محدودیت‌هایی را تعریف کند که دسترسی به این حجم را از چه گره‌هایی محدود می‌کند. پادهایی که از حجم استفاده می‌کنند، فقط برای گره‌هایی برنامه‌ریزی می‌شوند که توسط وابستگی گره انتخاب شده‌اند. برای تعیین وابستگی گره، `nodeAffinity` را در `.spec` یک حجم پایدار تنظیم کنید. مرجع API `[حجم پایدار](/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/#PersistentVolumeSpec)` جزئیات بیشتری در این زمینه دارد.

### فاز

یک حجم پایدار در یکی از مراحل زیر خواهد بود:

`Available`
: منبعی رایگان که هنوز به هیچ درخواستی محدود نشده است

`Bound`
: حجم به یک درخواست محدود شده است

`Released`
: درخواست حذف شده است، اما منبع ذخیره‌سازی مرتبط هنوز توسط خوشه بازپس گرفته نشده است.

`Failed`
: بازیابی (خودکار) حجم با شکست مواجه شده است.

شما می‌توانید نام درخواست حجم پایدار متصل به حجم پایدار را با استفاده از دستور `kubectl describe persistentvolume <name>` مشاهده کنید.

#### زمان‌ثبت تغییر فاز

{{< feature-state feature_gate_name="PersistentVolumeLastPhaseTransitionTime" >}}

بخش `.status` برای یک حجم پایدار می‌تواند شامل یک بخش آلفای `lastPhaseTransitionTime` باشد. این بخش، زمان ثبت آخرین انتقال فاز آن حجم را ثبت می‌کند. برای ولوم‌های تازه ایجاد شده، فاز روی `Pending` و `lastPhaseTransitionTime` روی زمان فعلی تنظیم می‌شود.

## درخواست های حجم پایدار

هر درخواست حجم پایدار شامل یک مشخصات و وضعیت است که مشخصات و وضعیت درخواست را نشان می‌دهد. نام شیء درخواست حجم پایدار باید یک نام معتبر باشد. [نام زیر دامنه DNS](/docs/concepts/overview/working-with-objects/names#dns-subdomain-names).

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myclaim
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  resources:
    requests:
      storage: 8Gi
  storageClassName: slow
  selector:
    matchLabels:
      release: "stable"
    matchExpressions:
      - {key: environment, operator: In, values: [dev]}
```

### حالت‌های دسترسی

درخواست ها هنگام درخواست ذخیره‌سازی با حالت‌های دسترسی خاص، از [همان قراردادهای مربوط به حجم‌ها](#access-modes) استفاده می‌کنند.

### حالت‌های حجم

درخواست ها از [همان قرارداد مربوط به حجم ها](#volume-mode) برای نشان دادن میزان مصرف حجم به عنوان یک پرونده سیستم یا یک دستگاه بلوکی استفاده می‌کنند.

### نام حجم

درخواست ها می‌توانند از بخش `volumeName` برای اتصال صریح به یک حجم پایدار خاص استفاده کنند. همچنین می‌توانید `volumeName` را بدون تنظیم رها کنید، که نشان می‌دهد می‌خواهید کوبرنتیز یک حجم پایدار جدید تنظیم کند که با ادعا مطابقت داشته باشد. اگر حجم پایدار مشخص شده از قبل به درخواست حجم پایدار دیگری متصل شده باشد، اتصال در حالت انتظار گیر خواهد کرد.

### منابع

درخواست ها، مانند پادها، می‌توانند مقادیر خاصی از یک منبع را درخواست کنند. در این مورد، درخواست برای ذخیره‌سازی است. همان مدل منبع (https://git.k8s.io/design-proposals-archive/scheduling/resources.md) برای هر دو مورد حجم‌ها و درخواست ها اعمال می‌شود.

{{< note >}}
برای حجم های `Filesystem`، درخواست ذخیره‌سازی به اندازه حجم «بیرونی» (یعنی اندازه اختصاص داده شده از پس زمینه ذخیره سازی) اشاره دارد. این بدان معناست که اندازه قابل نوشتن ممکن است برای ارائه‌دهندگانی که یک پرونده سیستم را روی یک دستگاه بلوکی ایجاد می‌کنند، به دلیل سربار پرونده سیستم، کمی کمتر باشد. این امر به ویژه در XFS قابل مشاهده است، جایی که بسیاری از ویژگی‌های ابرداده به طور پیش‌فرض فعال هستند.
{{< /note >}}

### انتخابگر

درخواست ها می‌توانند یک انتخابگر برچسب [label selector](/docs/concepts/overview/working-with-objects/labels/#label-selectors) را برای فیلتر کردن بیشتر مجموعه حجم‌ها مشخص کنند. فقط حجم‌هایی که برچسب آنها با انتخابگر مطابقت دارد، می‌توانند به درخواست متصل شوند. انتخابگر می‌تواند شامل دو بخش باشد:

* `matchLabels` - حجم باید برچسبی با این مقدار داشته باشد
* `matchExpressions` - فهرستی از الزامات که با مشخص کردن کلید، فهرست مقادیر و عملگری که کلید و مقادیر را به هم مرتبط می‌کند، ایجاد می‌شود.
  عملگرهای معتبر شامل `In`، `NotIn`، `Exists` و `DoesNotExist` هستند.

تمام الزامات، از هر دو `matchLabels` و `matchExpressions`، با هم AND می‌شوند - برای تطبیق، همه آنها باید برآورده شوند.

### کلاس

یک درخواست می‌تواند با مشخص کردن نام یک کلاس خاص، با استفاده از ویژگی `storageClassName`، درخواست یک کلاس خاص را بدهد. فقط حجم های پایدار کلاس درخواستی، آن‌هایی که `storageClassName` آن‌ها با درخواست حجم پایدار یکسان است، می‌توانند به درخواست حجم پایدار متصل شوند.

درخواست ها حجم پایدار لزوماً نیازی به درخواست کلاس ندارند. یک درخواست حجم پایدار که `storageClassName` آن برابر با `""` تنظیم شده باشد، همیشه به عنوان درخواست یک حجم پایدار بدون کلاس تفسیر می‌شود، بنابراین فقط می‌تواند به حجم های پایداری بدون کلاس (بدون حاشیه‌نویسی یا با یک مجموعه برابر با `""`) محدود شود. یک درخواست حجم پایدار بدون `storageClassName` کاملاً یکسان نیست و بسته به اینکه آیا [`DefaultStorageClass` افزونه پذیرش](/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass) روشن است یا خیر، توسط خوشه به طور متفاوتی رفتار می‌شود.

* اگر افزونه پذیرش فعال باشد، مدیر می‌تواند یک کلاس ذخیره سازی پیش‌فرض مشخص کند. تمام درخواست های حجم پایداری که `storageClassName` ندارند، فقط می‌توانند به حجم پایدارهایی با آن پیش‌فرض متصل شوند. تعیین کلاس ذخیره سازی پیش‌فرض با تنظیم حاشیه‌نویسی `storageclass.kubernetes.io/is-default-class` برابر با `true` در یک شیء کلاس ذخیره سازی انجام می‌شود. اگر مدیر پیش‌فرضی مشخص نکند، خوشه به ایجاد کلاس ذخیره سازی طوری پاسخ می‌دهد که انگار افزونه پذیرش غیرفعال است. اگر بیش از یک کلاس ذخیره سازی پیش‌فرض مشخص شده باشد، هنگام تهیه پویای درخواست حجم پایدار، از جدیدترین پیش‌فرض استفاده می‌شود.
* اگر افزونه پذیرش غیرفعال باشد، مفهومی از کلاس ذخیره سازی پیش‌فرض وجود ندارد. تمام درخواست حجم های پایداری که `storageClassName` آنها روی `""` تنظیم شده است، فقط می‌توانند به حجم های پایداری متصل شوند که `storageClassName` آنها نیز روی `""` تنظیم شده است. با این حال، درخواست حجم های پایداری که `storageClassName` آنها حذف شده است، می‌توانند بعداً پس از در دسترس قرار گرفتن کلاس ذخیره سازی پیش‌فرض، به‌روزرسانی شوند. اگر درخواست حجم پایدار به‌روزرسانی شود، دیگر به حجم های پایداری که `storageClassName` آنها نیز روی `""` تنظیم شده است، متصل نخواهد شد.

برای جزئیات بیشتر به [تخصیص پیش فرض کلاس ذخیره سازی به صورت گذشته‌نگر](#retroactive-default-storageclass-assignment) مراجعه کنید.

بسته به روش نصب، یک کلاس ذخیره سازی پیش‌فرض ممکن است توسط مدیر افزونه در حین نصب در یک کلاستر کوبرنتیز مستقر شود.

وقتی یک درخواست حجم پایدار علاوه بر درخواست کلاس ذخیره سازی، یک `selector` را مشخص می‌کند، الزامات با هم AND می‌شوند: فقط یک حجم پایدار از کلاس درخواستی و با برچسب‌های درخواستی می‌تواند به درخواست حجم پایدار متصل شود.

{{< note >}}
در حال حاضر، یک درخواست حجم پایدار با یک `selector` غیر خالی نمی‌تواند یک حجم پایدار به صورت پویا برای آن فراهم کند.
{{< /note >}}

در گذشته، به جای ویژگی `storageClassName` از حاشیه‌نویسی `volume.beta.kubernetes.io/storage-class` استفاده می‌شد. این حاشیه‌نویسی هنوز کار می‌کند؛ با این حال، در نسخه‌های بعدی کوبرنتیز پشتیبانی نخواهد شد.

#### تخصیص پیش فرض کلاس ذخیره سازی به صورت گذشته‌نگر

{{< feature-state for_k8s_version="v1.28" state="stable" >}}

شما می‌توانید بدون مشخص کردن `storageClassName` برای درخواست حجم پایدار جدید، یک درخواست حجم پایدار ایجاد کنید، و می‌توانید این کار را حتی زمانی که هیچ کلاس ذخیره سازی پیش‌فرضی در خوشه شما وجود ندارد، انجام دهید. در این حالت، درخواست حجم پایدار جدید همانطور که تعریف کرده‌اید ایجاد می‌شود و `storageClassName` آن درخواست حجم پایدار تا زمانی که مقدار پیش‌فرض در دسترس قرار گیرد، تنظیم نشده باقی می‌ماند.

وقتی یک کلاس ذخیره سازی پیش‌فرض در دسترس قرار می‌گیرد، صفحه کنترل هر درخواست حجم پایدار موجود بدون `storageClassName` را شناسایی می‌کند. برای درخواست حجم های پایداری که یا مقدار خالی برای `storageClassName` دارند یا این کلید را ندارند، صفحه کنترل سپس آن درخواست های حجم پایدار را به‌روزرسانی می‌کند تا `storageClassName` را با کلاس ذخیره سازی پیش‌فرض جدید مطابقت دهد. اگر درخواست حجم پایدار موجودی دارید که `storageClassName` آن `""` است، و یک کلاس ذخیره سازی پیش‌فرض پیکربندی می‌کنید، این درخواست حجم پایدار به‌روزرسانی نخواهد شد.

برای اینکه بتوانید به حجم های پایداری که `storageClassName` آنها روی `""` تنظیم شده است (در حالی که کلاس ذخیره سازی پیش‌فرض وجود دارد) متصل بمانید، باید `storageClassName` مربوط به درخواست حجم پایدار مربوطه را روی `""` تنظیم کنید.

این رفتار به مدیران کمک می‌کند تا کلاس ذخیره سازی پیش‌فرض را با حذف اولیه‌ی قبلی و سپس ایجاد یا تنظیم یکی دیگر تغییر دهند. این پنجره‌ی کوتاه در حالی که هیچ پیش‌فرضی وجود ندارد، باعث می‌شود درخواست حجم های پایداری که در آن زمان بدون `storageClassName` ایجاد شده‌اند، هیچ پیش‌فرضی نداشته باشند، اما به دلیل انتساب پیش‌فرض گذشته‌نگر کلاس ذخیره سازی، این روش تغییر پیش‌فرض‌ها ایمن است.

## درخواست‌ها به عنوان حجم

پادها با استفاده از درخواست به عنوان یک حجم به فضای ذخیره‌سازی دسترسی پیدا می‌کنند. درخواست ها باید در همان فضای نامی باشند که پاد از آن درخواست استفاده می‌کند. خوشه درخواست را در فضای نام پاد پیدا می‌کند و از آن برای دریافت حجم پایدار پشتیبان درخواست استفاده می‌کند. سپس حجم به میزبان و در پاد متصل می‌شود.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: nginx
      volumeMounts:
      - mountPath: "/var/www/html"
        name: mypd
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: myclaim
```

### نکته‌ای در مورد فضاهای نام

پیوندهای حجم های پایدار انحصاری هستند و از آنجایی که درخواست های حجم پایدار اشیاء با فضای نام هستند، اتصال درخواست ها با حالت‌های "چندگانه" (`ROX`، `RWX`) فقط در یک فضای نام امکان‌پذیر است.

### حجم های پایدار از نوع `hostPath`

یک `hostPath` حجم پایدار از یک پرونده یا پوشه در گره برای شبیه‌سازی فضای ذخیره‌سازی متصل به شبکه استفاده می‌کند. به [حجم های پایدار از نوع `hostPath`](/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume) مراجعه کنید.

## پشتیبانی از حجم بلوک خام

{{< feature-state for_k8s_version="v1.18" state="stable" >}}

افزونه‌های حجم زیر از حجم‌های بلوک خام، از جمله تأمین پویا در صورت لزوم، پشتیبانی می‌کنند:

* CSI (including some CSI migrated volume types)
* FC (Fibre Channel)
* iSCSI
* Local volume

### حجم پایدار با استفاده از یک حجم بلوک خام {#persistent-volume-using-a-raw-block-volume}

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: block-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  volumeMode: Block
  persistentVolumeReclaimPolicy: Retain
  fc:
    targetWWNs: ["50060e801049cfd1"]
    lun: 0
    readOnly: false
```

### درخواست حجم پایدار درخواست یک حجم بلوک خام {#persistent-volume-claim-requesting-a-raw-block-volume}

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: block-pvc
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Block
  resources:
    requests:
      storage: 10Gi
```

### مشخصات پاد اضافه کردن مسیر دستگاه بلوک خام در کانتینر

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-block-volume
spec:
  containers:
    - name: fc-container
      image: fedora:26
      command: ["/bin/sh", "-c"]
      args: [ "tail -f /dev/null" ]
      volumeDevices:
        - name: data
          devicePath: /dev/xvda
  volumes:
    - name: data
      persistentVolumeClaim:
        claimName: block-pvc
```

{{< note >}}
هنگام اضافه کردن یک دستگاه بلوک خام برای یک پاد، شما به جای مسیر نصب، مسیر دستگاه را در کانتینر مشخص می‌کنید.
{{< /note >}}

### اتصال حجم‌های بلوک

اگر کاربری با استفاده از بخش `volumeMode` در مشخصات درخواست حجم پایدار، یک حجم بلوک خام را درخواست کند، قوانین اتصال کمی با نسخه‌های قبلی که این حالت را به عنوان بخشی از مشخصات در نظر نمی‌گرفتند، متفاوت است. جدولی از ترکیبات ممکن که کاربر و مدیر ممکن است برای درخواست یک دستگاه بلوک خام مشخص کنند، فهرست شده است. این جدول نشان می‌دهد که آیا حجم با توجه به ترکیبات، محدود خواهد شد یا خیر: ماتریس اتصال حجم برای حجم‌های با تأمین ایستا:

| PV volumeMode | PVC volumeMode  | Result           |
| --------------|:---------------:| ----------------:|
|   unspecified | unspecified     | BIND             |
|   unspecified | Block           | NO BIND          |
|   unspecified | Filesystem      | BIND             |
|   Block       | unspecified     | NO BIND          |
|   Block       | Block           | BIND             |
|   Block       | Filesystem      | NO BIND          |
|   Filesystem  | Filesystem      | BIND             |
|   Filesystem  | Block           | NO BIND          |
|   Filesystem  | unspecified     | BIND             |

{{< note >}}
فقط حجم های آماده‌سازی‌شده به صورت ایستا برای انتشار آلفا پشتیبانی می‌شوند. مدیران سیستم باید هنگام کار با دستگاه‌های بلوک خام، این مقادیر را در نظر بگیرند.
{{< /note >}}

## پشتیبانی از Snapshot و بازیابی حجم از طریق Snapshot

{{< feature-state for_k8s_version="v1.20" state="stable" >}}

Snapshot های حجم فقط از افزونه‌های حجم CSI خارج از درخت پشتیبانی می‌کنند. برای جزئیات بیشتر، به [Snapshot های حجم](/docs/concepts/storage/volume-snapshots/) مراجعه کنید. افزونه‌های حجم درون درخت منسوخ شده‌اند. می‌توانید در مورد افزونه‌های حجم منسوخ شده در [سوالات متداول افزونه حجم] (https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md) مطالعه کنید.

### ایجاد یک درخواست حجم پایدار از یک Snapshot حجم {#create-persistent-volume-claim-from-volume-snapshot}

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: restore-pvc
spec:
  storageClassName: csi-hostpath-sc
  dataSource:
    name: new-snapshot-test
    kind: VolumeSnapshot
    apiGroup: snapshot.storage.k8s.io
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

## ایجاد نسخه‌ی همسان از یک حجم

[ایجاد نسخه‌ی همسان از یک حجم](/docs/concepts/storage/volume-pvc-datasource/)
فقط برای افزونه‌های حجم CSI در دسترس است.

### ایجاد درخواست حجم پایدار از یک درخواست حجم پایدار موجود {#create-persistent-volume-claim-from-an-existing-pvc}

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: cloned-pvc
spec:
  storageClassName: my-csi-plugin
  dataSource:
    name: existing-src-pvc-name
    kind: PersistentVolumeClaim
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

## پُرکننده‌های حجم و منابع داده

{{< feature-state for_k8s_version="v1.24" state="beta" >}}

کوبرنتیز از توزیع‌کننده‌های حجم سفارشی پشتیبانی می‌کند. برای استفاده از توزیع‌کننده‌های حجم سفارشی، باید `AnyVolumeDataSource` را برای kube-apiserver و kube-controller-manager فعال کنید.

پرکننده‌های حجم از یک بخش مشخصات درخواست حجم پایدار به نام `dataSourceRef` استفاده می‌کنند. برخلاف بخش `dataSource` که فقط می‌تواند شامل ارجاعی به یک درخواست حجم پایدار دیگر یا یک VolumeSnapshot باشد، بخش `dataSourceRef` می‌تواند شامل ارجاعی به هر شیء در همان فضای نام باشد، به جز اشیاء اصلی غیر از درخواست های حجم پایدار. برای خوشه‌هایی که دروازه ویژگی آنها فعال است، استفاده از `dataSourceRef` نسبت به `dataSource` ترجیح داده می‌شود.

## منابع داده فضای نام متقابل

{{< feature-state for_k8s_version="v1.26" state="alpha" >}}

کوبرنتیز از منابع داده حجمی فضای نام متقابل پشتیبانی می‌کند. برای استفاده از منابع داده حجمی فضای نام متقابل، باید `AnyVolumeDataSource` و `CrossNamespaceVolumeDataSource` [دروازه های ویژگی](/docs/reference/command-line-tools-reference/feature-gates/) را برای kube-apiserver و kube-controller-manager فعال کنید. همچنین، باید `CrossNamespaceVolumeDataSource` را برای csi-provisioner فعال کنید.

فعال کردن ویژگی CrossNamespaceVolumeDataSource به شما امکان می‌دهد یک فضای نام را در بخش dataSourceRef مشخص کنید.

{{< note >}}
وقتی یک فضای نام برای یک منبع داده‌ی حجم مشخص می‌کنید، کوبرنتیز قبل از پذیرش مرجع، وجود یک ReferenceGrant در فضای نام دیگر را بررسی می‌کند. ReferenceGrant بخشی از APIهای افزونه‌ی `gateway.networking.k8s.io` است. برای جزئیات بیشتر به [ReferenceGrant](https://gateway-api.sigs.k8s.io/api-types/referencegrant/) در مستندات  API مراجعه کنید. این بدان معناست که قبل از اینکه بتوانید از این سازوکار استفاده کنید، باید خوشه کوبرنتیز خود را حداقل با ReferenceGrant از Gateway API گسترش دهید.
{{< /note >}}

## مراجع منبع داده

بخش `dataSourceRef` تقریباً مانند بخش `dataSource` رفتار می‌کند. اگر یکی مشخص شده باشد و دیگری مشخص نشده باشد، سرور API به هر دو بخش مقدار یکسانی می‌دهد. هیچ‌کدام از بخش ها پس از ایجاد قابل تغییر نیستند و تلاش برای تعیین مقادیر متفاوت برای دو بخش منجر به خطای اعتبارسنجی خواهد شد. بنابراین، دو بخش همیشه محتوای یکسانی خواهند داشت.

دو تفاوت بین بخش `dataSourceRef` و بخش `dataSource` وجود دارد که کاربران باید از آنها آگاه باشند:

* بخش `dataSource` مقادیر نامعتبر را نادیده می‌گیرد (گویی بخش خالی است) در حالی که بخش `dataSourceRef` هرگز مقادیر را نادیده نمی‌گیرد و در صورت استفاده از مقدار نامعتبر، خطا ایجاد می‌کند. مقادیر نامعتبر شامل هر شیء اصلی (اشیایی که apiGroup ندارند) به جز درخواست های حجم پایدار می‌شود.
* بخش `dataSourceRef` می‌تواند شامل انواع مختلفی از اشیاء باشد، در حالی که بخش `dataSource` فقط درخواست های حجم پایدار و VolumeSnapshotها را مجاز می‌داند.

وقتی ویژگی `CrossNamespaceVolumeDataSource` فعال باشد، تفاوت‌های دیگری نیز وجود دارد:

* بخش `dataSource` فقط اشیاء محلی را مجاز می‌داند، در حالی که بخش `dataSourceRef` اشیاء موجود در هر فضای نامی را مجاز می‌داند.
* وقتی فضای نام مشخص می‌شود، `dataSource` و `dataSourceRef` همگام‌سازی نمی‌شوند.

کاربران همیشه باید در خوشه‌هایی که دروازه ویژگی فعال است از `dataSourceRef` استفاده کنند و در خوشه‌هایی که این دروازه فعال نیست، به `dataSource` بازگردند. تحت هیچ شرایطی لازم نیست هر دو بخش را بررسی کنند. مقادیر تکراری با معانی کمی متفاوت فقط برای سازگاری معکوس وجود دارند. به طور خاص، ترکیبی از کنترل‌کننده‌های قدیمی‌تر و جدیدتر می‌توانند با هم کار کنند زیرا بخش ها یکسان هستند.

### استفاده از پُرکننده‌های حجم

پرکننده‌های حجم، {{< glossary_tooltip text="controllers" term_id="controller" >}} هستند که می‌توانند حجم‌های غیر خالی ایجاد کنند، که در آن‌ها محتویات حجم توسط یک منبع سفارشی تعیین می‌شود. کاربران با مراجعه به یک منبع سفارشی با استفاده از بخش `dataSourceRef` یک حجم پر شده ایجاد می‌کنند:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: populated-pvc
spec:
  dataSourceRef:
    name: example-name
    kind: ExampleDataSource
    apiGroup: example.storage.k8s.io
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

از آنجا که جمع‌کننده‌های حجم، اجزای خارجی هستند، تلاش برای ایجاد یک درخواست حجم پایدار که از یکی از آنها استفاده می‌کند، در صورت عدم اتصال همه اجزای صحیح، می‌تواند با شکست مواجه شود. کنترل‌کننده‌های خارجی باید رویدادهایی را روی درخواست حجم پایدار ایجاد کنند تا بازخوردی در مورد وضعیت ایجاد ارائه دهند، از جمله هشدارهایی در صورت عدم امکان ایجاد درخواست حجم پایدار به دلیل وجود برخی از اجزای از دست رفته.

شما می‌توانید کنترل‌کننده آلفا [اعتبارسنج منبع داده حجمی](https://github.com/kubernetes-csi/volume-data-source-validator) را در خوشه خود نصب کنید. این کنترل‌کننده در صورتی که هیچ توزیع‌کننده‌ای برای مدیریت آن نوع منبع داده ثبت نشده باشد، رویدادهای هشداردهنده‌ای را روی درخواست حجم پایدار ایجاد می‌کند. هنگامی که یک توزیع‌کننده مناسب برای درخواست حجم پایدار نصب می‌شود، مسئولیت گزارش رویدادهای مربوط به ایجاد حجم و مشکلات در طول فرآیند بر عهده آن کنترل‌کننده توزیع‌کننده است.

### استفاده از منبع داده‌ی حجم فضای نام متقابل

{{< feature-state for_k8s_version="v1.26" state="alpha" >}}

یک مرجع اعطایی ایجاد کنید تا به مالک فضای نام اجازه دهید مرجع را بپذیرد. شما با مشخص کردن یک منبع داده برای یک فضای نام متقاطع با استفاده از بخش `dataSourceRef`، یک حجم جمعیتی تعریف می‌کنید. شما باید از قبل یک مرجع اعطایی معتبر در فضای نام منبع داشته باشید:

   ```yaml
   apiVersion: gateway.networking.k8s.io/v1beta1
   kind: ReferenceGrant
   metadata:
     name: allow-ns1-pvc
     namespace: default
   spec:
     from:
     - group: ""
       kind: PersistentVolumeClaim
       namespace: ns1
     to:
     - group: snapshot.storage.k8s.io
       kind: VolumeSnapshot
       name: new-snapshot-demo
   ```

   ```yaml
   apiVersion: v1
   kind: PersistentVolumeClaim
   metadata:
     name: foo-pvc
     namespace: ns1
   spec:
     storageClassName: example
     accessModes:
     - ReadWriteOnce
     resources:
       requests:
         storage: 1Gi
     dataSourceRef:
       apiGroup: snapshot.storage.k8s.io
       kind: VolumeSnapshot
       name: new-snapshot-demo
       namespace: default
     volumeMode: Filesystem
   ```

## نوشتن پیکربندی قابل حمل

اگر در حال نوشتن قالب‌ها یا مثال‌های پیکربندی هستید که روی طیف وسیعی از خوشه ها اجرا می‌شوند و به ذخیره‌سازی مداوم نیاز دارند، توصیه می‌شود از الگوی زیر استفاده کنید:

- اشیاء درخواست حجم پایدار را در بسته پیکربندی خود (در کنار استقرارها، ConfigMaps و غیره) قرار دهید.
- اشیاء حجم پایدار را در پیکربندی وارد نکنید، زیرا کاربری که پیکربندی را نمونه‌سازی می‌کند ممکن است مجوز ایجاد حجم های پایدار را نداشته باشد.
- به کاربر این امکان را بدهید که هنگام نمونه‌سازی از قالب، نام کلاس ذخیره‌سازی را ارائه دهد.
  - اگر کاربر نام کلاس ذخیره‌سازی را ارائه دهد، آن مقدار را در بخش `persistentVolumeClaim.storageClassName` قرار دهید. این کار باعث می‌شود درخواست حجم پایدار با کلاس ذخیره‌سازی صحیح مطابقت داشته باشد، اگر خوشه کلاس های ذخیره سازی توسط مدیر فعال شده باشد.
  - اگر کاربر نام کلاس ذخیره‌سازی را ارائه نکرد، بخش `persistentVolumeClaim.storageClassName` را صفر بگذارید. این باعث می‌شود که یک حجم پایدار به طور خودکار برای کاربر با کلاس ذخیره سازی پیش‌فرض در خوشه فراهم شود. بسیاری از محیط‌های خوشه دارای کلاس ذخیره سازی پیش‌فرض نصب شده هستند، یا مدیران می‌توانند کلاس ذخیره سازی پیش‌فرض خود را ایجاد کنند.
- در ابزار خود، مراقب درخواست حجم های پایداری باشید که پس از مدتی متصل نمی‌شوند و این را به کاربر اطلاع دهید، زیرا این ممکن است نشان دهد که خوشه هیچ پشتیبانی از ذخیره‌سازی پویا ندارد (در این صورت کاربر باید یک حجم پایدار منطبق ایجاد کند) یا خوشه هیچ سیستم ذخیره‌سازی ندارد (در این صورت کاربر نمی‌تواند پیکربندی مورد نیاز درخواست حجم های پایدار را مستقر کند).

## {{% heading "whatsnext" %}}

* درباره [ایجاد یک حجم پایدار](/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume) بیشتر بدانید.
* درباره [ایجاد یک درخواست حجم پایدار](/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim) بیشتر بدانید.
* [سند طراحی ذخیره‌سازی پایدار] (https://git.k8s.io/design-proposals-archive/storage/persistent-storage.md) را مطالعه کنید.

### API references {#reference}

درباره API های شرح داده شده در این صفحه بخوانید:

* [`PersistentVolume`](/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/)
* [`PersistentVolumeClaim`](/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/)
