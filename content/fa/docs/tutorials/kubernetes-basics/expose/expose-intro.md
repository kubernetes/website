---
title: برنامه خود را با استفاده از سرویس ها منتشر کنید
weight: 10
---

## {{% heading "objectives" %}}

* یاد خواهید گرفت سرویس ها کوبرنتیز چیستند.
* یاد خواهید گرفت برچسب ها (label) و انتخاب کننده (selector).
* یک برناهه را در خارج از کوبرنتیز منتشر خواهید کرد.

## نگاه کلی بر سرویس های کوبرنتیز


[پادها](/docs/concepts/workloads/pods/) در کوبرنتیز فانی بوده و هرلحظه امکان دارد حذف شوند. به عبارت دیگر همه پادها یک [طول عمر](/docs/concepts/workloads/pods/pod-lifecycle/) دارند.
هنگامی که نود کارگری از بین برود پادهایی که بر روی آن نود درحال اجرا بوده اند هم از بین می روند.
در این هنگام [کپی های همسان](/docs/concepts/workloads/controllers/replicaset/) (Replicaset) می توانند به صورت خودکار با ساخت پادهای جدید کلاستر شما را به حالت ایده ال بازگرداند.

به عنوان مثالی دیگر فرض کنید که ۳ کپی همسان (replicas) بک اند سیستم پردازش تصویر شما را تشکیل می دهند.
سیستم فرانت‌اند در این مثال نباید گونه ای طراحی شده باشد که تعداد نسخه‌های بک‌اند یا حتی از بین رفتن و بازسازی یک پاد در وظایفش مشکلی ایجاد کند. با این حال، هر پاد در کلاستر کوبرنتیز یک آدرس IP منحصر‌به‌فرد دارد، حتی پادهایی که روی یک نودهمسان هستند. بنابراین، باید راهی برای هماهنگ‌سازی خودکار تغییرات میان پادها وجود داشته باشد تا برنامه‌های شما بتوانند به عملکرد خود ادامه دهند.

{{% alert %}}
_سرویس های کوبرنتیز منابعی هستند که با اتکا به آن ها می توانید منابع داخلی کلاسترتان را برای کاربران و شبکه های خارجی منتشر کنید._
{{% /alert %}}

[سرویس](/docs/concepts/services-networking/service/) در کوبرنتیز یک انتزاع (abstraction) است که مجموعه‌ای منطقی از پادها و سیاستی برای دسترسی به آن‌ها را تعریف می‌کند.
سرویس‌ها باعث می‌شوند پادهای وابسته به‌طور متغییر (loose coupling) به هم متصل باشند.
یک سرویس مانند سایر منابع کوبرنتیز با استفاده از YAML یا JSON تعریف می‌شود.
مجموعه‌ی پادهایی که یک سرویس هدف قرار می‌دهد معمولاً توسط یک selector بر اساس برچسب (label) مشخص می‌شود (در ادامه توضیح داده می‌شود که چرا ممکن است بخواهید سرویسی بدون مشخص‌کردن `selector` در spec ایجاد کنید).

اگرچه هر پاد یک آدرس IP منحصربه‌فرد دارد، این آدرس‌ها بدون وجود یک سرویس از خارج از کلاستر قابل دسترسی نیستند.
سرویس‌ها این امکان را فراهم می‌کنند که برنامه‌های شما بتوانند ترافیک خارج از کلاستر را دریافت کنند.

سرویس‌ها را می‌توان با تعیین یک نوع `type` در بخش `spec` به روش‌های مختلفی در معرض دسترس قرار داد:

* _ClusterIP_ (پیش فرض) - این نوع سرویس با استفاده از ای پی داخلی برنامه را در کلاستر منتشر می کند.
توجه داشته باشید که این نوع سرویس تنها از داخل کلاستر قابل دسترسی می باشد.

* _NodePort_ - این نوع سرویس با استفاده از NAT بر روی تمامی نودهای کلاستر برنامه شما را منتشر می کند.
منابع خارجی با استفاده از فرمت `NodeIP:NodePort` می توانند به سرویس منتشر شده دسترسی یابند.

* _LoadBalancer_ - این نوع سرویس در فزاهای ابری پشتیبانی شده یک متعادل کننده بار خارجی می سازد که ای پی مختص وایستا می گیرد.

* _ExternalName_ - این نوع سرویس محتوای `externalName` را به درخواست هامرتبط می کند و آن را به عنوان `CNAME` بازمی گرداند.
در این حالت هیچ گونه پروکسی استفاده نشده و تنها لازم است از `kube-dns` ویرایش ۱.۷ یا بالاتر و یا `CoreDNS` ویرایش ۰.۰..۸ یا بالاتر استفاده شود.

برای اطلاعات بیشتر به آموزش استفاده از [ای پی مبدا](/docs/tutorials/services/source-ip/) (Source IP) که در مورد سرویس ها اطلاعات تکمیلی تری می دهد نگاهی بندازید.
بازدید از آموزش [اتصال برنامه ها و سرویس ها](/docs/tutorials/services/connect-applications-service/) هم خالی از لطف نیست.

درضمن، توجه داشتع باشید در برخی از موارد سرویس های ساخته می شوند که انتخاب کننده (selector) ندارند.
این سرویس ها به کاربر این اجازه را می دهند تا سرویس خود را به صورت دستی به نقاط مقصد وصل کند.
یکی دیگر از جاهایی که امکان دارد با سرویس بدون انتخاب گر مواجه شوید در سرویس `نام خارجی` (ExternalName) است.

## برچسب ها و سرویس ها

سرویس در کوبرنتیز ترافیک را بین مجموعه‌ای از پادها مسیردهی می‌کند. سرویس‌ها همان لایه‌ی انتزاعی هستند که اجازه می‌دهند پادها بدون تأثیر بر عملکرد برنامه‌ی شما از بین بروند یا مجدداً ساخته شوند. کشف (discovery) و مسیردهی (routing) بین پادهای وابسته به یکدیگر (مانند بخش‌های فرانت‌اند و بک‌اند در یک برنامه) توسط سرویس‌های کوبرنتیز مدیریت می‌شود.

سرویس ها از طریق [برچسب ها و انتخاب کننده ها](/docs/concepts/overview/working-with-objects/labels) به پادها متصل می شوند که راه حلی ساده برای گروه کردن منطقی منابع در کوبرنتیز هست.
برچسب ها به صورت `کلید و محتوا` (key/value) به منابع متصل شده تا این کارها را انجام دهند:

* اختصاص دادن یک منبع برای آزمایش، عملیات یا بهینه سازی
* الصاق برچسب ویرایش و نسخه
* دسته بندی یک منبع از طریق برچسب

{{< figure src="/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg" class="diagram-medium" >}}

برچسب منابع هر زمانی می تواند اختصاص یابد یا تغییر کند.
حالا بیایید با استفاده از برچسب ها برنامه تان را منتشر کنید.

### مرحله اول:‌ ساخت یک سرویس

بیایید بررسی کنیم که برنامه‌ی ما در حال اجراست.
از دستور `kubectl get` استفاده می‌کنیم و به‌دنبال پادهای موجود می‌گردیم:

```shell
kubectl get pods
```

{{< note >}}
اگر هیچ پادی در حال اجرا نباشد، به این معناست که منابع ایجاد‌شده در آموزش‌های قبلی پاک شده‌اند.
در این صورت، به آموزش استفاده از [ ساخت یک دیپلویمنت با استفاده از kubectl](/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro#deploy-an-app) برگردید و مجدداً دیپلویمنت را ایجاد کنید. لطفاً چند ثانیه صبر کنید و سپس دوباره پادها را فهرست کنید. زمانی که یک پاد در حال اجرا را مشاهده کردید، می‌توانید ادامه دهید.
{{< /note >}}


در قدم بعدی با استفاده از دستور زیر، لیست سرویس های کلاستر را بررسی کنید:

```shell
kubectl get services
```

در حال حاضر سرویسی به نام (kubernetes-bootcamp) داریم و اگر دقیق تر نگاه کنیم می بینیم که سرویس ما یک `cluster-IP` یکتا با یک درگاه داخلی و یک `external-IP` را در پاسخ از دستور قبل را به ما گزارش می دهد.

برای اینکه متوجه شویم چه درگاه هایی برای این سرویس ما تخصیص یافته اند از دستور زیر استفاده کنیم:

```shell
kubectl describe services/kubernetes-bootcamp
```

با استفاده از دستور زیر یک متغییر محیطی با نام `NODE_PORT` بسازید و درگاه اختصاصی را در آن ذخیره کنید:

```shell
export NODE_PORT="$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')"
echo "NODE_PORT=$NODE_PORT"
```

حالا می توانید از خارج از کلاستر خود برنامه نشر شده را آزمایش کنید.

```shell
curl http://"$(minikube ip):$NODE_PORT"
```

{{< note >}}
در صورتی که از نرم افزار Docker Desktop برای minikube استفاده می کنید باید یک تونل مینی کیوب بزنید. 
این تونل به این دلیل باید برپا شود که به شما اجازه دهد تا به کانتینر های داخل محیط Docker Desktop از طریق سیستم خودتان متصل شوید.

در ترمینال دیگری دستور زیر را اجرا کنید:

```shell
minikube service kubernetes-bootcamp --url
```

The output looks like this:

```
http://127.0.0.1:51082
!  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.
```

آدرس بازگردانده شده را استفاده کنید تا به برنامه متصل شوید:

```shell
curl 127.0.0.1:51082
```
{{< /note >}}

پاسخ سرور را در این مرحله باید ببنید. سرویس ما برنامه را منتشر کرد!

### مرحله دوم : استفاده از برچسب ها

برنامه جاری که از طریق دیپلویمنت مستقر کرده اید به صورت خودکار برچسبی از دیپلویمنت خود می گی رد. 

با استفاده از دستور زیر برچسب دیپلویمنت را بررسی کنید:

```shell
kubectl describe deployment
```

حالا بیایید از این برچسب استفاده کنیم. یکی از روش های استفاده از برچسب ها اضافه کردن آن ها به پارامتر `-l` در دستورات است.

```shell
kubectl get pods -l app=kubernetes-bootcamp
```

شما می توانید این برچسب را برای دیدن سرویس ها هم بکار به برید.

```shell
kubectl get services -l app=kubernetes-bootcamp
```

برای قسمت بعد اول اسم پاد را در یک متغییر محیطی با نام `POD_NAME` ذخیره کنید:

```shell
export POD_NAME="$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')"
echo "Name of the Pod: $POD_NAME"
```

برای ایجاد برچسب می توانید از زیردستور `label` و منبع مورد نظر استفاده کنید تا برچسب جدید الصاق شود:

```shell
kubectl label pods "$POD_NAME" version=v1
```

بعد از اجرای دستور قبل یک برچسب جدید به پاد ما وصل می شود کی می توانید با کمک گرفتن از زیردستور `describe` آن را بررسی کنید:

```shell
kubectl describe pods "$POD_NAME"
```

همانطور که می بینید برچسب جدید به پاد ما وصل شده و به ما این امکان را می دهد که از طریق این برچسب لیست پادها را تهیه کنیم.

```shell
kubectl get pods -l version=v1
```

### مرحله سوم: حذف سرویس

برای حذف سرویس ها می توانید از زیر دستور `delete service` استفاده نمایید. این زیر دستور قابلیت استفاده هم زمان با برچسب ها را دارد و مانند مثال زیر می توانید این دو خاصیت را با هم ادغام کنید:

```shell
kubectl delete service -l app=kubernetes-bootcamp
```

تأیید کنید که سرویس حذف شده است:

```shell
kubectl get services
```

پاسخ دستور قبل تایید می کند که سرویس حذف شده است، برای اطمینان بیشتر می توانید این مورد را دوباره با استفاده از درگاه و ای پی قبلی آن از طریق دستور `curl` آزمایش کنید:

```shell
curl http://"$(minikube ip):$NODE_PORT"
```

این نشان می‌دهد که برنامه دیگر از خارج از کلاستر قابل دسترسی نیست.

برای اطمینان از اینکه برنامه همچنان در حال اجراست، می‌توانید از داخل پاد با استفاده از دستور `curl` آن را بررسی کنید:

```shell
kubectl exec -ti $POD_NAME -- curl http://localhost:8080
```

با استناد به پاسخ دستور قبل می توانیم بگوییم که برنامه ما هنوز در حال اجرا است. این مهم به این دلیل می باشد که برنامه ما از طریق دیپلویمنت مدیریت می شود و سرویسی که با آن طعلق داشت تنها برای منتشر کردن برنامه در سطح خارج از کلاستر بوده است.

{{< note >}}
توجه داشته باشید که برای حذف پاد هایی که برنامه شما را در یک کلاستر بارگذاری می کنند باید آن دیپلویمنت را حذف کنید.
{{< /note >}}


## {{% heading "whatsnext" %}}

* آموزش [اجرای نسخه های مختلفی از برنامه هایتان](/docs/tutorials/kubernetes-basics/scale/scale-intro/).
* در مورد [سرویس](/docs/concepts/services-networking/service/) بیشتر بدانید. 
