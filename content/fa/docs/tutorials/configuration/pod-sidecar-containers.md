---
title: استفاده از کانتینرهای sidecar
content_type: tutorial
weight: 40
min-kubernetes-server-version: 1.29
---

<!-- overview -->

این بخش برای افرادی مناسب است که قصد دارند قابلیت داخلی جدیدِ
[کانتینرهای sidecar](/docs/concepts/workloads/pods/sidecar-containers/)
را برای بارهای کاری خود به کار بگیرند.  

کانتینر sidecar مفهوم تازه‌ای نیست؛ همان‌طور که در
[این مطلب وب نوشتی](/blog/2015/06/the-distributed-system-toolkit-patterns/)
اشاره شده است. کوبرنتیس اجرای چندین کانتینر در یک پاد را برای پیاده‌سازی این مفهوم
امکان‌پذیر می‌کند. بااین‌حال، اجرای یک کانتینر sidecar به‌عنوان کانتینر معمولی
محدودیت‌های زیادی دارد که اکنون با پشتیبانی داخلی جدید از کانتینرهای sidecar برطرف شده‌اند.  

{{< feature-state feature_gate_name="SidecarContainers" >}}

## {{% heading "objectives" %}}

- نیاز به کانتینرهای sidecar را درک کنید
- بتوانید مشکلات مربوط به کانتینرهای sidecar را عیب‌یابی کنید
- گزینه‌های "تزریق" جهانی کانتینرهای sidecar به هر حجم کاری را درک کنید

## {{% heading "prerequisites" %}}

{{< include "task-tutorial-prereqs.md" >}} {{< version-check >}}

<!-- lessoncontent -->

## نمای کلی کانتینرهای sidecar

کانتینرهای سایدکار، کانتینرهای ثانویه‌ای هستند که همراه با کانتینر اصلیِ برنامه در همان
{{< glossary_tooltip text="Pod" term_id="pod" >}} اجرا می‌شوند.
این کانتینرها با ارائه خدمات یا قابلیت‌های اضافی—مانند ثبت لاگ، پایش، امنیت،
یا همگام‌سازی داده—بدون تغییر مستقیم کد برنامه اصلی، کارایی یا امکانات آن
را افزایش و گسترش می‌دهند. برای اطلاعات بیشتر به صفحه
[کانتینرهای سایدکار](/docs/concepts/workloads/pods/sidecar-containers/) مراجعه کنید.

مفهوم کانتینرهای سایدکار جدید نیست و پیاده‌سازی‌های متعددی از آن وجود دارد.
علاوه بر کانتینرهای سایدکاری که خودِ شما—به‌عنوان تعریف‌کننده پاد—تمایل دارید اجرا شوند،
ممکن است برخی {{< glossary_tooltip text="addons" term_id="addons" >}} نیز، پیش از شروع به کار پاد،
آن را دست‌کاری کرده و کانتینرهای سایدکار اضافی تزریق کنند. مکانیزم متداول برای **تزریق**
این سایدکارهای اضافی معمولاً
[وب‌هوک‌های تغییر‌دهنده (Mutating Webhooks)](/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook)
هستند. برای نمونه، یک افزودنی «سرویس مش» ممکن است سایدکاری تزریق کند که
TLS دوطرفه و رمزنگاری حین انتقال را میان پادهای مختلف پیکربندی می‌کند.

با اینکه ایده کانتینرهای سایدکار تازگی ندارد،
پیاده‌سازی بومی این قابلیت در کوبرنتیس تازه است و—as با هر ویژگی تازه—
استفاده از آن می‌تواند چالش‌هایی به‌همراه داشته باشد.

این راهنما به بررسی چالش‌ها و راهکارهایی می‌پردازد که ممکن است هم کاربران نهایی و
هم سازندگان کانتینرهای سایدکار با آن‌ها روبه‌رو شوند.

## مزایای کانتینر sidecar داخلی

استفاده از پشتیبانی بومی کوبرنتیس برای کانتینرهای سایدکار چندین مزیت دارد:

1. می‌توانید یک کانتینر سایدکار بومی را طوری پیکربندی کنید که پیش از  
   {{< glossary_tooltip text="init containers" term_id="init-container" >}} اجرا شود.  
1. کانتینرهای سایدکار داخلی را می‌توان طوری نوشت که تضمین شود آخرین کانتینرهایی باشند که خاتمه می‌یابند.  
   وقتی همه کانتینرهای معمولی کامل شده و خاتمه یافتند، به کانتینر سایدکار سیگنال `SIGTERM` فرستاده می‌شود.  
   اگر این کانتینر به‌طور تمیز متوقف نشود، سیگنال `SIGKILL` برای خاتمه آن به کار می‌رود.  
1. در Jobها، زمانی که مقدار `restartPolicy` پاد `OnFailure` یا `Never` است،  
   کانتینرهای سایدکار بومی جلوی کامل شدن پاد را نمی‌گیرند؛ در حالی که برای کانتینرهای سایدکار قدیمی باید  
   تمهیدات ویژه‌ای در این حالت در نظر گرفته شود.  
1. همچنین در Jobها، حتی اگر کانتینرهای معمولی با `restartPolicy: Never` دوباره اجرا نشوند،  
   کانتینرهای سایدکار داخلی پس از پایان دوباره راه‌اندازی می‌شوند.  

برای آگاهی بیش‌تر، بخش  
[تفاوت‌ها با کانتینرهای init](/docs/concepts/workloads/pods/sidecar-containers/#differences-from-application-containers)  
را مطالعه کنید.  

## استفاده از کانتینرهای sidecar داخلی

درگاه ویژگی `SidecarContainers` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/)
از نسخه ۱٫۲۹ کوبرنتیس در حالت بتا قرار دارد و به‌طور پیش‌فرض فعال است.  
برخی خوشهها ممکن است این قابلیت را غیرفعال کرده باشند یا نرم‌افزاری نصب داشته باشند
که با آن ناسازگار باشد.  

در چنین شرایطی ممکن است پاد رد شود یا کانتینرهای سایدکار جلوی راه‌اندازی پاد را بگیرند
و پاد عملاً بی‌استفاده شود. تشخیص این وضعیت آسان است، زیرا پاد در مرحله
راه‌اندازی اولیه متوقف می‌شود؛ اما اغلب مشخص نیست چه عاملی باعث بروز مشکل شده است.  

در ادامه ملاحظات و گام‌های عیب‌یابی‌ای آورده شده است که هنگام به‌کارگیری کانتینرهای
سایدکار برای بارِ کاری خود می‌توانید از آن‌ها بهره ببرید.  

### مطمئن شوید که دروازه ویژگی فعال است

به‌عنوان نخستین گام، مطمئن شوید که هم سرور API و هم نودها روی نسخه v1.29 یا بالاترِ کوبرنتیس باشند. این قابلیت در خوشههایی که نودهای آن نسخه‌های قدیمی‌تری اجرا می‌کنند—که در آن‌ها این ویژگی فعال نیست—از کار خواهد افتاد.

{{< alert title="Note" color="info" >}}

می‌توان این ویژگی را روی نودهایی با نسخه ۱٫۲۸ نیز فعال کرد. رفتار خاتمه کانتینر سایدکار داخلی در نسخه ۱٫۲۸ متفاوت بود و توصیه نمی‌شود که رفتار سایدکار را با آن هماهنگ کنید. بااین‌حال، اگر تنها نگرانی ترتیب راه‌اندازی است، می‌توان جمله بالا را به «نودهایی با نسخه ۱٫۲۸ و درگاه ویژگی فعال» تغییر داد.

{{< /alert >}}

باید اطمینان حاصل کنید که درگاه ویژگی هم برای سرور(های) API در صفحه کنترل **و** هم برای تمامی نودها فعال است.

یکی از روش‌های بررسی فعال بودن درگاه ویژگی، اجرای دستوری مشابه زیر است:

- برای سرور API:

  ```shell
  kubectl get --raw /metrics | grep kubernetes_feature_enabled | grep SidecarContainers
  ```

- برای گره منفرد:

  ```shell
  kubectl get --raw /api/v1/nodes/<node-name>/proxy/metrics | grep kubernetes_feature_enabled | grep SidecarContainers
  ```

اگر چیزی شبیه به این را دیدید:

```
kubernetes_feature_enabled{name="SidecarContainers",stage="BETA"} 1
```

یعنی اینکه اون قابلیت فعال شده.

### ابزارهای شخص ثالث و webhookهای تغییردهنده را بررسی کنید

اگر هنگام ارزیابی این قابلیت با مشکل مواجه شدید، ممکن است نشان‌دهنده آن باشد که یکی از
ابزارهای شخص ثالث یا وب‌هوک‌های تغییردهنده دچار ایراد شده است.

زمانی که درگاه ویژگی `SidecarContainers` فعال باشد، پادها یک فیلد جدید در API خود به دست می‌آورند.
برخی ابزارها یا وب‌هوک‌های تغییردهنده ممکن است با نسخه‌های قدیمی‌تر API کوبرنتیس ساخته شده باشند.

اگر این ابزارها فیلدهای ناشناخته را همان‌گونه که هستند و با استفاده از راهبردهای مختلف وصله (patch) برای تغییر یک شیء پاد عبور دهند، مشکلی پیش نمی‌آید. بااین‌حال، ابزارهایی وجود دارند که
فیلدهای ناشناخته را حذف می‌کنند؛ در این صورت باید با نسخه v1.28+ از کد کلاینت API کوبرنتیس مجدداً کامپایل شوند.

برای بررسی این موضوع می‌توانید از دستور `kubectl describe pod` روی پادی که از پذیرش تغییردهنده گذشته است استفاده کنید. اگر ابزارها فیلد جدید (`restartPolicy:Always`) را حذف کرده باشند،
این فیلد را در خروجی دستور نخواهید دید.

اگر با چنین مشکلی روبه‌رو شدید، به نویسنده ابزار یا وب‌هوک توصیه کنید
به‌جای به‌روزرسانی کامل شیء، از یکی از راهبردهای وصله برای تغییر اشیا استفاده کند.

{{< alert title="Note" color="info" >}}

یک وب‌هوک تغییردهنده ممکن است بر اساس برخی شرایط پادها را به‌روزرسانی کند؛
بنابراین، کانتینرهای سایدکار ممکن است برای برخی پادها کار کنند و برای برخی دیگر نه.

{{< /alert >}}

### تزریق خودکار sidecar

اگر از نرم‌افزاری استفاده می‌کنید که به‌طور خودکار سایدکارها را تزریق می‌کند،  
چند راهبرد وجود دارد که می‌توانید برای اطمینان از قابل استفاده بودن کانتینرهای سایدکار بومی دنبال کنید.  
همه این راهبردها در اصل گزینه‌هایی هستند که می‌توانید انتخاب کنید تا تصمیم بگیرید  
پادی که سایدکار در آن تزریق می‌شود روی نودی قرار بگیرد که این قابلیت را پشتیبانی می‌کند یا خیر.  

به‌عنوان نمونه می‌توانید  
[این گفت‌وگو در جامعه Istio](https://github.com/istio/istio/issues/48794) را دنبال کنید.  
این بحث گزینه‌های زیر را بررسی می‌کند.  

1. پادهایی را که روی نودهای پشتیبان سایدکار قرار می‌گیرند علامت‌گذاری کنید.  
   می‌توانید از برچسب‌های نود و وابستگی نود (node affinity) برای علامت‌گذاری نودهایی که از  
   کانتینرهای سایدکار پشتیبانی می‌کنند و پادهایی که روی آن نودها قرار می‌گیرند استفاده کنید.  
1. سازگاری نودها را هنگام تزریق بررسی کنید. در زمان تزریق سایدکار می‌توانید  
   راهبردهای زیر را برای بررسی سازگاری نود به کار ببرید:  
   - نسخه نود را پرس‌وجو کرده و فرض کنید در نسخه ۱٫۲۹+ درگاه ویژگی فعال است  
   - متریک‌های پرومتئوس نود را پرس‌وجو کرده و وضعیت فعال بودن ویژگی را بررسی کنید  
   - فرض کنید نودها با [قوانین انحراف نسخه پشتیبانی‌شده](/releases/version-skew-policy/#supported-version-skew)  
     نسبت به سرور API در حال اجرا هستند  
   - روش‌های سفارشی دیگری نیز ممکن است برای تشخیص سازگاری نود وجود داشته باشد.  
1. یک تزریق‌کننده سایدکار سراسری توسعه دهید. ایده یک تزریق‌کننده سایدکار سراسری این است که  
   یک کانتینر سایدکار را هم به‌عنوان کانتینر معمولی و هم به‌عنوان کانتینر سایدکار بومی تزریق کند  
   و منطقی در زمان اجرا داشته باشد تا تصمیم بگیرد کدام‌یک کار خواهد کرد.  
   تزریق‌کننده سایدکار سراسری منابع را دو بار مصرف می‌کند، زیرا درخواست‌ها را دو بار حساب می‌کند،  
   اما ممکن است به‌عنوان راهکاری عملی برای موارد ویژه در نظر گرفته شود.  
   - یک راه این است که در شروع کانتینر سایدکار بومی،  
     نسخه نود را تشخیص داده و اگر نسخه از ویژگی سایدکار پشتیبانی نمی‌کند فوراً خارج شود.  
   - طراحی تشخیص ویژگی در زمان اجرا را در نظر بگیرید:  
     - یک دایرکتوری خالی تعریف کنید تا کانتینرها بتوانند با هم ارتباط برقرار کنند  
     - یک کانتینر init تزریق کنید که آن را `NativeSidecar` بنامیم با `restartPolicy=Always`.  
     - `NativeSidecar` باید هنگام اولین اجرا فایلی در دایرکتوری خالی بنویسد و فوراً با کد خروج `0` خارج شود.  
     - `NativeSidecar` در اجرای مجدد (زمانی که سایدکارهای بومی پشتیبانی می‌شوند) بررسی می‌کند  
       که آن فایل در دایرکتوری وجود دارد و آن را تغییر می‌دهد—نشان می‌دهد کانتینرهای سایدکار داخلی  
       پشتیبانی شده و در حال اجرا هستند.  
     - یک کانتینر معمولی تزریق کنید که آن را `OldWaySidecar` بنامیم.  
     - `OldWaySidecar` در شروع وجود فایل را در دایرکتوری خالی بررسی می‌کند.  
     - اگر فایل نشان دهد که `NativeSidecar` در حال اجرا **نیست**، فرض می‌کند  
       ویژگی سایدکار پشتیبانی نمی‌شود و خودش را به‌عنوان سایدکار فعال می‌کند.  
     - اگر فایل نشان دهد که `NativeSidecar` در حال اجرا است، یا هیچ کاری انجام نمی‌دهد و همیشه می‌خوابد  
       (در حالتی که `restartPolicy=Always` برای پاد باشد) یا فوراً با کد خروج `0` خارج می‌شود  
       (در حالتی که `restartPolicy!=Always` باشد).  

## {{% heading "whatsnext" %}}

- درباره [sidecar containers](/docs/concepts/workloads/pods/sidecar-containers/) بیشتر بدانید.
