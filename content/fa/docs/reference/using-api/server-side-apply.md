---
title: Server-Side Apply
reviewers:
- smarterclayton
- apelisse
- lavalamp
- liggitt
content_type: concept
weight: 25
---

<!-- overview -->

{{< feature-state feature_gate_name="ServerSideApply" >}}

Kubernetes از چندین برنامه‌نویس که برای مدیریت فیلدهای یک [object] واحد با هم همکاری می‌کنند، پشتیبانی می‌کند (/docs/concepts/overview/working-with-objects/).
Server-Side Apply یک مکانیزم اختیاری برای صفحه کنترل خوشه شما فراهم می‌کند تا تغییرات فیلدهای یک شیء را ردیابی کند. در سطح یک منبع خاص، Server-Side Apply اطلاعات مربوط به کنترل فیلدهای آن شیء را ثبت و ردیابی می‌کند.
Server-Side Apply به کاربران و {{< glossary_tooltip text="controllers" term_id="controller" >}} کمک می‌کند تا منابع خود را از طریق پیکربندی اعلانی مدیریت کنند. کلاینت‌ها می‌توانند با ارسال intent_fully specified_ خود، intent_{{< glossary_tooltip text="objects" term_id="object" >}} را به صورت اعلانی ایجاد و اصلاح کنند.
یک intent_fully specified یک شیء جزئی است که فقط شامل فیلدها و مقادیری است که کاربر در مورد آنها نظر دارد. این intent یا یک شیء جدید ایجاد می‌کند (با استفاده از مقادیر پیش‌فرض برای فیلدهای نامشخص)، یا توسط سرور API با شیء موجود ترکیب می‌شود (#merge-strategy).
[مقایسه با Client-Side Apply](#comparison-with-client-side-apply) توضیح می‌دهد که چگونه Server-Side Apply با پیاده‌سازی اصلی `kubectl apply` در سمت کلاینت متفاوت است.

<!-- body -->

## Field management

سرور Kubernetes API، فیلدهای مدیریت‌شده را برای همه اشیاء تازه ایجاد شده ردیابی می‌کند.

هنگام تلاش برای اعمال یک شیء، فیلدهایی که مقدار متفاوتی دارند و متعلق به [manager](#مدیران) دیگری هستند، منجر به [conflict](#تعارض) می‌شوند. این کار به منظور نشان دادن این موضوع انجام می‌شود که عملیات ممکن است تغییرات همکار دیگری را لغو کند.
می‌توان نوشتن روی اشیاء با فیلدهای مدیریت‌شده را اجباری کرد، در این صورت مقدار هر فیلد دارای تداخل لغو می‌شود و مالکیت منتقل می‌شود.

هر زمان که مقدار یک فیلد تغییر کند، مالکیت از مدیر فعلی آن به مدیری که تغییر را انجام می‌دهد، منتقل می‌شود.

بررسی کنید که آیا مدیر فیلد دیگری هم وجود دارد که مالک آن فیلد باشد یا خیر. اگر فیلد متعلق به هیچ مدیر فیلد دیگری نباشد، آن فیلد به مقدار پیش‌فرض خود (در صورت وجود) تنظیم می‌شود، یا در غیر این صورت از شیء حذف می‌شود. همین قانون در مورد فیلدهایی که لیست، لیست انجمنی یا نقشه هستند نیز صدق می‌کند.


مدیریت یک فیلد توسط یک کاربر، به معنای اعمال در سمت سرور، به این معنی است که کاربر به مقدار فیلد تکیه می‌کند و انتظار دارد که تغییر نکند. کاربری که آخرین بار در مورد مقدار یک فیلد اظهار نظری کرده است، به عنوان مدیر فعلی فیلد ثبت خواهد شد. این کار را می‌توان با تغییر صریح جزئیات مدیر فیلد با استفاده از HTTP `POST` (**create**)، `PUT` (**update**) یا عدم اعمال `PATCH` (**patch**) انجام داد. همچنین می‌توانید با وارد کردن مقداری برای آن فیلد در یک عملیات اعمال در سمت سرور، یک مدیر فیلد را اعلام و ثبت کنید.

درخواست **patch** سمت سرور، مستلزم آن است که کلاینت هویت خود را به عنوان [field manager ](#managers) ارائه دهد. هنگام استفاده از Server-Side Apply، تلاش برای تغییر فیلدی که توسط مدیر دیگری کنترل می‌شود، منجر به رد درخواست می‌شود، مگر اینکه کلاینت یک لغو را اعمال کند.
برای جزئیات لغوها، به [Conflicts](#conflicts) مراجعه کنید.

وقتی دو یا چند اعمال‌کننده مقدار یکسانی را برای یک فیلد تعیین می‌کنند، مالکیت آن فیلد را به اشتراک می‌گذارند. هرگونه تلاش بعدی برای تغییر مقدار فیلد مشترک، توسط هر یک از اعمال‌کننده‌ها، منجر به تداخل می‌شود. مالکان فیلد مشترک می‌توانند با ارسال درخواست Server-Side Apply **patch** که شامل آن فیلد نمی‌شود، مالکیت یک فیلد را واگذار کنند.

جزئیات مدیریت فیلدها در فیلدی به نام `managedFields` ذخیره می‌شوند که بخشی از [`metadata`](/docs/reference/kubernetes-api/common-definitions/object-meta/) یک شیء است.

اگر فیلدی را از مانیفست حذف کنید و آن مانیفست را اعمال کنید، Server-Side
Apply بررسی می‌کند که آیا مدیر فیلد دیگری نیز وجود دارد که مالک آن فیلد باشد یا خیر.
اگر فیلد متعلق به هیچ مدیر فیلد دیگری نباشد، یا از شیء زنده حذف می‌شود یا در صورت وجود، به مقدار پیش‌فرض خود بازنشانی می‌شود.
همین قانون در مورد آیتم‌های لیست انجمنی یا نقشه نیز صدق می‌کند.

در مقایسه با حاشیه‌نویسی (قدیمی) [`kubectl.kubernetes.io/last-applied-configuration`](/docs/reference/labels-annotations-taints/#kubectl-kubernetes-io-last-applied-configuration)
مدیریت‌شده توسط `kubectl`، Server-Side Apply از رویکرد اعلانی‌تری استفاده می‌کند که مدیریت فیلد کاربر (یا کلاینت) را به جای آخرین وضعیت اعمال‌شده کاربر، ردیابی می‌کند. به عنوان یک عارضه جانبی استفاده از Server-Side Apply، اطلاعاتی در مورد اینکه کدام مدیر فیلد هر فیلد را در یک شیء مدیریت می‌کند نیز در دسترس قرار می‌گیرد.

### Example {#ssa-example-configmap}

یک مثال ساده از یک شیء ایجاد شده با استفاده از Server-Side Apply می‌تواند چیزی شبیه به این باشد:

{{< note >}}
دستور `kubectl get` به طور پیش‌فرض فیلدهای مدیریت‌شده را حذف می‌کند. برای نمایش `managedFields` در زمانی که فرمت خروجی `json` یا `yaml` است، `--show-managed-fields` را اضافه کنید.
{{< /note >}}

```yaml
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-cm
  namespace: default
  labels:
    test-label: test
  managedFields:
  - manager: kubectl
    operation: Apply # note capitalization: "Apply" (or "Update")
    apiVersion: v1
    time: "2010-10-10T0:00:00Z"
    fieldsType: FieldsV1
    fieldsV1:
      f:metadata:
        f:labels:
          f:test-label: {}
      f:data:
        f:key: {}
data:
  key: some value
```

آن شیء ConfigMap نمونه شامل یک رکورد مدیریت فیلد در `.metadata.managedFields` است. رکورد مدیریت فیلد شامل اطلاعات اولیه در مورد خود موجودیت مدیریت کننده، به علاوه جزئیاتی در مورد فیلدهای تحت مدیریت و عملیات مربوطه (`Apply` یا `Update`) است. اگر درخواستی که آخرین بار آن فیلد را تغییر داده است، یک `Server-Side Apply **patch** بوده باشد، مقدار `operation` برابر با `Apply` خواهد بود؛ در غیر این صورت، `Update` خواهد بود.

یک نتیجه‌ی محتمل دیگر هم وجود دارد. یک کلاینت می‌تواند یک بدنه‌ی درخواست نامعتبر ارسال کند. اگر هدف کاملاً مشخص‌شده، یک شیء معتبر تولید نکند، درخواست با شکست مواجه می‌شود.

با این حال، می‌توان `.metadata.managedFields` را از طریق یک **به‌روزرسانی** یا از طریق یک عملیات **پچ** که از Server-Side Apply استفاده نمی‌کند، تغییر داد. انجام این کار اکیداً توصیه نمی‌شود، اما اگر، برای مثال، `.metadata.managedFields` وارد حالت ناپایدار شود (که نباید در عملیات عادی اتفاق بیفتد)، می‌تواند گزینه معقولی برای امتحان کردن باشد.

قالب «`managedFields` در مرجع API Kubernetes به صورت [description](/docs/reference/kubernetes-api/common-definitions/object-meta/#System) آمده است.

{{< caution >}}
فیلد `.metadata.managedFields` توسط سرور API مدیریت می‌شود. شما باید از به‌روزرسانی دستی آن خودداری کنید.
{{< /caution >}}

### Conflicts

یک _conflict_ یک خطای وضعیت خاص است که زمانی رخ می‌دهد که یک عملیات `Apply` سعی می‌کند فیلدی را که مدیر دیگری نیز ادعای مدیریت آن را دارد، تغییر دهد. این امر مانع از آن می‌شود که یک درخواست‌کننده ناخواسته مقدار تعیین‌شده توسط کاربر دیگری را بازنویسی کند. وقتی این اتفاق می‌افتد، درخواست‌کننده 3 گزینه برای حل تداخل‌ها دارد:

* **مقدار را بازنویسی کنید، مدیر انحصاری شوید:** اگر بازنویسی مقدار عمدی بوده باشد (یا اگر اعمال‌کننده یک فرآیند خودکار مانند یک کنترل‌کننده باشد)، اعمال‌کننده باید پارامتر پرس‌وجوی `force` را روی true تنظیم کند (برای `kubectl apply`، از پارامتر خط فرمان `--force-conflicts` استفاده می‌کنید) و درخواست را دوباره انجام دهید. این کار عملیات را مجبور به موفقیت می‌کند، مقدار فیلد را تغییر می‌دهد، و فیلد را از تمام ورودی‌های سایر مدیران در `managedFields` حذف می‌کند.


* **مقدار را بازنویسی نکنید، ادعای مدیریت را کنار بگذارید:** اگر درخواست‌کننده دیگر به مقدار فیلد اهمیتی ندهد، می‌تواند آن را از مدل محلی منبع خود حذف کند و درخواست جدیدی با آن فیلد خاص ارسال کند. این کار مقدار را بدون تغییر باقی می‌گذارد و باعث می‌شود فیلد از ورودی درخواست‌کننده در `managedFields` حذف شود.

* **مقدار را بازنویسی نکنید، مدیر مشترک شوید:** اگر کاربر هنوز به مقدار یک فیلد اهمیت می‌دهد، اما نمی‌خواهد آن را بازنویسی کند، می‌تواند مقدار آن فیلد را در مدل محلی منبع خود تغییر دهد تا با مقدار شیء روی سرور مطابقت داشته باشد و سپس درخواست جدیدی ارسال کند که آن به‌روزرسانی محلی را در نظر می‌گیرد. انجام این کار مقدار را بدون تغییر باقی می‌گذارد و باعث می‌شود مدیریت آن فیلد توسط کاربر به همراه تمام مدیران فیلد دیگری که قبلاً ادعای مدیریت آن را داشته‌اند، به اشتراک گذاشته شود.

### Field managers {#managers}

مدیران، گردش‌های کاری متمایزی را که شیء را تغییر می‌دهند شناسایی می‌کنند (به‌ویژه در مورد تداخل‌ها مفید است!)، و می‌توانند از طریق پارامتر پرس‌وجوی [`fieldManager`](/docs/reference/kubernetes-api/common-parameters/common-parameters/#fieldManager) به عنوان بخشی از یک درخواست اصلاح مشخص شوند. هنگامی که شما به یک منبع درخواست می‌دهید، پارامتر `fieldManager` مورد نیاز است.
برای سایر به‌روزرسانی‌ها، سرور API هویت یک مدیر فیلد را از هدر HTTP "User-Agent:" (در صورت وجود) استنباط می‌کند.

وقتی از ابزار `kubectl` برای انجام عملیات اعمال سمت سرور استفاده می‌کنید، `kubectl` به طور پیش‌فرض هویت مدیر را روی ``kubectl`` تنظیم می‌کند.

## Serialization

در سطح پروتکل، Kubernetes بدنه پیام‌های Server-Side Apply را به صورت [YAML](https://yaml.org/) و با نوع رسانه `application/apply-patch+yaml` نمایش می‌دهد.

{{< note >}}
چه داده‌های JSON ارسال کنید و چه داده‌های YAML، از `application/apply-patch+yaml` به عنوان مقدار هدر `Content-Type` استفاده کنید.

تمام اسناد JSON با فرمت YAML معتبر هستند. با این حال، Kubernetes دارای یک اشکال است که در آن از یک تجزیه‌کننده YAML استفاده می‌کند که مشخصات YAML را به طور کامل پیاده‌سازی نمی‌کند. برخی از escapeهای JSON ممکن است شناسایی نشوند.
{{< /note >}}

سریال‌سازی همانند اشیاء Kubernetes است، با این تفاوت که کلاینت‌ها ملزم به ارسال یک شیء کامل نیستند.

در اینجا مثالی از بدنه پیام Apply سمت سرور (با هدف کاملاً مشخص) آورده شده است:
```yaml
{
  "apiVersion": "v1",
  "kind": "ConfigMap"
}
```

(این یک به‌روزرسانی بدون تغییر ایجاد می‌کند، مشروط بر اینکه به عنوان بدنه‌ی یک درخواست **patch** به یک منبع معتبر `v1/configmaps` و با درخواست مناسب `Content-Type` ارسال شده باشد).


## عملیات در محدوده مدیریت میدانی {#apply-and-update}

عملیات API کوبرنتیز که مدیریت فیلد در آنها در نظر گرفته شده است عبارتند از:

1. اعمال سمت سرور (HTTP `PATCH`، با نوع محتوای `application/apply-patch+yaml`)
2. جایگزینی یک شیء موجود (**به‌روزرسانی** به کوبرنتیز؛ `PUT` در سطح HTTP)

هر دو عملیات، `.metadata.managedFields` را به‌روزرسانی می‌کنند، اما کمی متفاوت رفتار می‌کنند.

اگر یک لغو اجباری مشخص نکنید، یک عملیات اعمال که با تداخل در سطح فیلد مواجه می‌شود، همیشه با شکست مواجه می‌شود. در مقابل، اگر با استفاده از **update** تغییری ایجاد کنید که بر یک فیلد مدیریت‌شده تأثیر بگذارد، تداخل هرگز باعث شکست عملیات نمی‌شود.

تمام درخواست‌های سمت سرور Apply **patch** ملزم به شناسایی خود با ارائه پارامتر پرس‌وجوی `fieldManager` هستند، در حالی که پارامتر پرس‌وجو برای عملیات **update** اختیاری است. در نهایت، هنگام استفاده از عملیات `Apply`، نمی‌توانید `managedFields` را در بدنه درخواستی که ارسال می‌کنید تعریف کنید.
یک شیء نمونه با چندین مدیر می‌تواند به این شکل باشد:

```yaml
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-cm
  namespace: default
  labels:
    test-label: test
  managedFields:
  - manager: kubectl
    operation: Apply
    time: '2019-03-30T15:00:00.000Z'
    apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:metadata:
        f:labels:
          f:test-label: {}
  - manager: kube-controller-manager
    operation: Update
    apiVersion: v1
    time: '2019-03-30T16:00:00.000Z'
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        f:key: {}
data:
  key: new value
```

در این مثال، عملیات دوم به عنوان **به‌روزرسانی** توسط مدیری به نام `kube-controller-manager` اجرا شد. درخواست به‌روزرسانی با موفقیت انجام شد و مقداری را در فیلد داده تغییر داد که باعث شد مدیریت آن فیلد به `kube-controller-manager` تغییر کند.
اگر به جای آن، این به‌روزرسانی با استفاده از Server-Side Apply انجام می‌شد، درخواست به دلیل مالکیت متضاد با شکست مواجه می‌شد.

## استراتژی ادغام

استراتژی ادغام، که با Server-Side Apply پیاده‌سازی شده است، چرخه حیات شیء را عموماً پایدارتر می‌کند. Server-Side Apply سعی می‌کند فیلدها را بر اساس بازیگری که آنها را مدیریت می‌کند ادغام کند، نه بر اساس مقادیر. به این ترتیب، چندین بازیگر می‌توانند بدون ایجاد تداخل غیرمنتظره، شیء یکسانی را به‌روزرسانی کنند.

وقتی کاربری یک شیء intent با مشخصات کامل را به نقطه پایانی Server-Side Apply ارسال می‌کند، سرور آن را با شیء زنده‌ای که مقدار آن از بدنه درخواست در صورت مشخص بودن در هر دو مکان، مطلوب است، ادغام می‌کند. اگر مجموعه اقلام موجود در پیکربندی اعمال شده، مجموعه‌ای از اقلام اعمال شده توسط همان کاربر در دفعه قبل نباشد، هر مورد از دست رفته که توسط هیچ اعمال‌کننده دیگری مدیریت نمی‌شود، حذف می‌شود. برای اطلاعات بیشتر در مورد نحوه استفاده از طرحواره یک شیء برای تصمیم‌گیری هنگام ادغام، به [sigs.k8s.io/structured-merge-diff](https://sigs.k8s.io/structured-merge-diff) مراجعه کنید.


API کوبرنتیز (و کد Go که آن API را برای کوبرنتیز پیاده‌سازی می‌کند) امکان تعریف نشانگرهای استراتژی ادغام را فراهم می‌کند. این نشانگرها، استراتژی ادغام پشتیبانی‌شده برای فیلدهای درون اشیاء کوبرنتیز را توصیف می‌کنند. برای {{< glossary_tooltip term_id="CustomResourceDefinition" text="CustomResourceDefinition" >}}، می‌توانید این نشانگرها را هنگام تعریف منبع سفارشی تنظیم کنید.

| Golang marker   | OpenAPI extension            | Possible values                                  | Description                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| --------------- | ---------------------------- | ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `//+listType`   | `x-kubernetes-list-type`     | `atomic`/`set`/`map`                             | قابل اجرا برای لیست‌ها. `set` برای لیست‌هایی اعمال می‌شود که فقط شامل عناصر اسکالر هستند. این عناصر باید منحصر به فرد باشند. `map` فقط برای لیست‌های تو در تو اعمال می‌شود. مقادیر کلید (به `listMapKey` مراجعه کنید) باید در لیست منحصر به فرد باشند.. «اتمی» می‌تواند برای هر لیستی اعمال شود. اگر به عنوان «اتمی» پیکربندی شود، کل لیست در طول ادغام جایگزین می‌شود. در هر نقطه از زمان، یک مدیر واحد مالک لیست است.. If `set` or `map`, مدیران مختلف می‌توانند ورودی‌ها را به‌طور جداگانه مدیریت کنند. |
| `//+listMapKey` | `x-kubernetes-list-map-keys` | فهرست نام فیلدها، مثلاً `["port", "protocol"]` | فقط زمانی قابل اجرا است که `+listType=map`. فهرستی از نام فیلدها که مقادیر آنها به طور منحصر به فرد ورودی‌های لیست را مشخص می‌کند. در حالی که می‌تواند چندین کلید وجود داشته باشد، `listMapKey` مفرد است زیرا کلیدها باید به صورت جداگانه در نوع Go مشخص شوند. فیلدهای کلید باید اسکالر باشند.                                                                                                                                                                               |
| `//+mapType` | `x-kubernetes-map-type` | `atomic`/`granular` | قابل اجرا برای نقشه‌ها. `atomic` به این معنی است که نقشه فقط می‌تواند به طور کامل توسط یک مدیر واحد جایگزین شود. `granular` به این معنی است که نقشه از مدیران جداگانه‌ای برای به‌روزرسانی فیلدهای جداگانه پشتیبانی می‌کند.                                                                                                                                                                                                                                                                 |
| `//+structType` | `x-kubernetes-map-type`      | `atomic`/`granular`                              | قابل اجرا برای ساختارها؛ در غیر این صورت، همان نحوه استفاده و حاشیه‌نویسی OpenAPI مانند `//+mapType`.                                                                                                                                                                                                                                                                                                                                                                      |

اگر `listType` وجود نداشته باشد، سرور API نشانگر `patchStrategy=merge` را به عنوان `listType=map` و نشانگر `patchMergeKey` مربوطه را به عنوان `listMapKey` تفسیر می‌کند.
The `atomic` list type is recursive.

(در کد [Go](https://go.dev/) برای Kubernetes، این نشانگرها به عنوان توضیحات مشخص شده‌اند و نویسندگان کد نیازی به تکرار آنها به عنوان برچسب‌های فیلد ندارند.)

## منابع سفارشی و اعمال سمت سرور

به طور پیش‌فرض، Server-Side Apply با منابع سفارشی به عنوان داده‌های بدون ساختار رفتار می‌کند. با همه کلیدها مانند فیلدهای struct رفتار می‌شود و همه لیست‌ها اتمیک در نظر گرفته می‌شوند.

اگر CustomResourceDefinition یک[schema](/docs/reference/generated/kubernetes-api/{{< param "version" >}}#jsonschemaprops-v1-apiextensions-k8s-io)
که حاوی حاشیه‌نویسی‌هایی مطابق تعریف قبلی در بخش [Merge Strategy](#merge-strategy)
است، تعریف کند، این حاشیه‌نویسی‌ها هنگام ادغام اشیاء از این نوع استفاده خواهند شد.


### سازگاری در تغییرات توپولوژی

در موارد نادر، نویسنده‌ی یک CustomResourceDefinition (CRD) یا یک منبع داخلی ممکن است بخواهد توپولوژی خاص یک فیلد را در منبع خود تغییر دهد، بدون اینکه نسخه API آن را افزایش دهد. تغییر توپولوژی انواع، با ارتقاء خوشه یا به‌روزرسانی CRD، هنگام به‌روزرسانی اشیاء موجود پیامدهای متفاوتی دارد. دو دسته تغییر وجود دارد: وقتی یک فیلد از `map`/`set`/`granular` به `atomic` تغییر می‌کند، و برعکس.

وقتی `listType`، `mapType` یا `structType` از `map`/`set`/`granular` به `atomic` تغییر کند، کل لیست، نقشه یا ساختار اشیاء موجود در نهایت متعلق به بازیگرانی خواهد بود که عنصری از این نوع‌ها را در اختیار داشته‌اند. این بدان معناست که هرگونه تغییر بیشتر در این اشیاء باعث ایجاد تداخل می‌شود.

وقتی یک `listType`، `mapType` یا `structType` از `atomic` به `map`/`set`/`granular` تغییر می‌کند، سرور API قادر به استنباط مالکیت جدید این فیلدها نیست. به همین دلیل، وقتی اشیاء این فیلدها را به‌روزرسانی می‌کنند، هیچ تداخلی ایجاد نمی‌شود. به همین دلیل، تغییر نوع از `atomic` به `map`/`set`/`granular` توصیه نمی‌شود.

برای مثال، منبع سفارشی را در نظر بگیرید:

```yaml
---
apiVersion: example.com/v1
kind: Foo
metadata:
  name: foo-sample
  managedFields:
  - manager: "manager-one"
    operation: Apply
    apiVersion: example.com/v1
    fieldsType: FieldsV1
    fieldsV1:
      f:spec:
        f:data: {}
spec:
  data:
    key1: val1
    key2: val2
```

قبل از اینکه `spec.data` از `atomic` به `granular` تغییر کند، `manager-one` مالک فیلد `spec.data` و تمام فیلدهای درون آن (`key1` و `key2`) است. وقتی CRD برای تبدیل `spec.data` به `granular` تغییر می‌کند، `manager-one` همچنان مالک فیلد سطح بالا `spec.data` است (به این معنی که هیچ مدیر دیگری نمی‌تواند نقشه‌ای به نام `data` را بدون تداخل حذف کند)، اما دیگر مالک `key1` و `key2` نیست، بنابراین مدیر دیگری می‌تواند آن فیلدها را بدون تداخل تغییر یا حذف کند.

## استفاده از Server-Side Apply در یک کنترلر

به عنوان توسعه‌دهنده یک کنترلر، می‌توانید از Server-Side Apply به عنوان راهی برای ساده‌سازی منطق به‌روزرسانی کنترلر خود استفاده کنید. تفاوت‌های اصلی با یک 
read-modify-write و/یا patch موارد زیر است:

* شیء اعمال شده باید شامل تمام فیلدهایی باشد که کنترلر به آنها اهمیت می‌دهد.
* هیچ راهی برای حذف فیلدهایی که قبلاً توسط کنترلر اعمال نشده‌اند وجود ندارد (کنترلر همچنان می‌تواند برای این موارد استفاده **patch** یا **update** ارسال کند).
* لازم نیست شیء از قبل خوانده شود؛ `resourceVersion` لازم نیست مشخص شود.

It is strongly recommended for controllers to always force conflicts on objects that
they own and manage, since they might not be able to resolve or act on these conflicts.

## انتقال مالکیت

علاوه بر کنترل‌های همزمانی ارائه شده توسط [conflict resolution](#conflicts)، Server-Side Apply روش‌هایی را برای انجام انتقال مالکیت فیلد هماهنگ از کاربران به کنترل‌کننده‌ها فراهم می‌کند.

این موضوع با مثال به بهترین شکل توضیح داده می‌شود. بیایید نگاهی به نحوه انتقال ایمن مالکیت فیلد `replicas` از یک کاربر به یک کنترلر بیندازیم، در حالی که «مقیاس‌بندی افقی خودکار برای یک Deployment» را با استفاده از منبع HorizontalPodAutoscaler و کنترلر همراه آن فعال می‌کنیم.

فرض کنید کاربری Deployment را با مقدار دلخواه `replicas` تعریف کرده است:

{{% code_sample file="application/ssa/nginx-deployment.yaml" %}}

و کاربر Deployment را با استفاده از Server-Side Apply ایجاد کرده است، مانند:

```shell
kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment.yaml --server-side
```

Then later, automatic scaling is enabled for the Deployment; for example:

```shell
kubectl autoscale deployment nginx-deployment --cpu-percent=50 --min=1 --max=10
```

اکنون، کاربر می‌خواهد `replicas` را از پیکربندی خود حذف کند تا به طور تصادفی با HorizontalPodAutoscaler (HPA) و کنترل‌کننده آن درگیر نشود. با این حال، یک رقابت وجود دارد: ممکن است مدتی طول بکشد تا HPA نیاز به تنظیم `.spec.replicas` را احساس کند. اگر کاربر `.spec.replicas` را قبل از اینکه HPA در فیلد بنویسد و مالک آن شود، حذف کند، سرور API `.spec.replicas` را روی 1 (تعداد کپی پیش‌فرض برای استقرار) تنظیم می‌کند. این چیزی نیست که کاربر بخواهد اتفاق بیفتد، حتی به طور موقت - ممکن است بار کاری در حال اجرا را به خوبی کاهش دهد.

دو راه حل وجود دارد:

- (اساسی) `replicas` را در پیکربندی باقی بگذارید؛ وقتی HPA در نهایت در آن فیلد می‌نویسد، سیستم بر سر آن با کاربر تداخل ایجاد می‌کند. در آن مرحله، حذف آن از پیکربندی بی‌خطر است.

- (پیشرفته‌تر) با این حال، اگر کاربر نخواهد منتظر بماند، مثلاً به این دلیل که می‌خواهد خوشه را برای همکارانش خوانا نگه دارد، می‌تواند مراحل زیر را برای ایمن‌سازی حذف «نسخه‌های کپی» از پیکربندی خود انجام دهد:

ابتدا، کاربر یک مانیفست جدید تعریف می‌کند که فقط شامل فیلد `replicas` است:

```yaml
# Save this file as 'nginx-deployment-replicas-only.yaml'.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
```

{{< note >}}
فایل YAML برای SSA در این مورد فقط شامل فیلدهایی است که می‌خواهید تغییر دهید.
اگر فقط می‌خواهید فیلد `spec.replicas` را با استفاده از SSA تغییر دهید، قرار نیست یک مانیفست استقرار کاملاً سازگار ارائه دهید.
{{< /note >}}

کاربر آن مانیفست را با استفاده از یک نام مدیر فیلد خصوصی اعمال می‌کند. در این مثال، کاربر `handover-to-hpa` را انتخاب کرده است:

```shell
kubectl apply -f nginx-deployment-replicas-only.yaml \
  --server-side --field-manager=handover-to-hpa \
  --validate=false
```

اگر اعمال منجر به تداخل با کنترل‌کننده HPA شود، هیچ کاری انجام ندهید. این تداخل نشان می‌دهد که کنترل‌کننده فیلد را زودتر از آنچه که گاهی اوقات اتفاق می‌افتد، در فرآیند تصاحب کرده است.

در این مرحله، کاربر می‌تواند فیلد `replicas` را از مانیفست خود حذف کند:

{{% code_sample file="application/ssa/nginx-deployment-no-replicas.yaml" %}}

توجه داشته باشید که هر زمان که کنترل‌کننده HPA فیلد `replicas` را روی مقدار جدیدی تنظیم کند، مدیر فیلد موقت دیگر هیچ فیلدی نخواهد داشت و به طور خودکار حذف می‌شود. نیازی به پاکسازی بیشتر نیست.

### انتقال مالکیت بین مدیران


مدیران فیلد می‌توانند با تنظیم فیلد به مقدار یکسان در هر دو پیکربندی اعمال‌شده، مالکیت یک فیلد را بین یکدیگر منتقل کنند و باعث شوند که مالکیت فیلد را به اشتراک بگذارند. هنگامی که مدیران مالکیت فیلد را به اشتراک گذاشتند، یکی از آنها می‌تواند فیلد را از پیکربندی اعمال‌شده خود حذف کند تا مالکیت را واگذار کند و انتقال را به مدیر فیلد دیگر تکمیل کند.

## مقایسه با Apply سمت کلاینت

دستور Server-Side Apply هم به عنوان جایگزینی برای پیاده‌سازی اصلی دستور فرعی `kubectl apply` در سمت کلاینت و هم به عنوان مکانیزمی ساده و مؤثر برای {{< glossary_tooltip term_id="controller" text="controllers" >}} برای اعمال تغییرات آنها در نظر گرفته شده است.


در مقایسه با حاشیه‌نویسی `last-applied` که توسط `kubectl` مدیریت می‌شود، Server-Side
Apply از رویکرد اعلانی‌تری استفاده می‌کند که مدیریت فیلد یک شیء را به جای آخرین وضعیت اعمال‌شده توسط کاربر، پیگیری می‌کند. این بدان معناست که به عنوان یک اثر جانبی استفاده از Server-Side Apply، اطلاعاتی در مورد اینکه کدام مدیر فیلد هر فیلد را در یک شیء مدیریت می‌کند نیز در دسترس قرار می‌گیرد.



یکی از پیامدهای تشخیص و حل تعارض پیاده‌سازی شده توسط Server-Side
Apply این است که یک اعمال‌کننده همیشه مقادیر فیلد به‌روزی را در وضعیت محلی خود دارد. اگر این مقادیر به‌روز نباشند، دفعه بعد که درخواست می‌دهند، با تعارض مواجه می‌شوند. هر یک از سه گزینه برای حل تعارض منجر به این می‌شود که پیکربندی اعمال شده، زیرمجموعه‌ای به‌روز از شیء در فیلدهای سرور باشد.

این با Client-Side Apply متفاوت است، که در آن مقادیر قدیمی که توسط کاربران دیگر رونویسی شده‌اند، در پیکربندی محلی یک متقاضی باقی می‌مانند. این مقادیر فقط زمانی دقیق می‌شوند که کاربر آن فیلد خاص را به‌روزرسانی کند، اگر اصلاً به‌روزرسانی شود، و یک متقاضی هیچ راهی برای دانستن اینکه آیا درخواست بعدی او تغییرات کاربران دیگر را بازنویسی خواهد کرد یا خیر، ندارد.

تفاوت دیگر این است که یک برنامه‌نویس که از Client-Side Apply استفاده می‌کند، قادر به تغییر نسخه API مورد استفاده خود نیست، اما Server-Side Apply از این مورد استفاده پشتیبانی می‌کند.

## Migration between client-side and server-side apply

### Upgrading from client-side apply to server-side apply

کاربران apply سمت کلاینت که منبعی را با `kubectl apply` مدیریت می‌کنند، می‌توانند با استفاده از پرچم زیر، استفاده از apply سمت سرور را شروع کنند.

```shell
kubectl apply --server-side [--dry-run=server]
```

به طور پیش‌فرض، مدیریت فیلد انتقال اشیاء از سمت کلاینت به سمت سرور kubectl اعمال می‌شود، بدون اینکه با تداخلی مواجه شود.

{{< caution >}}
حاشیه‌نویسی `last-applied-configuration` را به‌روز نگه دارید.
این حاشیه‌نویسی استنباط می‌کند که فیلدهای مدیریت‌شده سمت کلاینت اعمال می‌شوند.
هر فیلدی که توسط apply سمت کلاینت مدیریت نشود، تداخل ایجاد می‌کند.

برای مثال، اگر از `kubectl scale` برای به‌روزرسانی فیلد replicas پس از `client-side apply` استفاده کرده باشید، این فیلد متعلق به `client-side apply` نیست و در `kubectl apply --server-side` تداخل ایجاد می‌کند.
{{< /caution >}}

این رفتار در مورد apply سمت سرور با مدیر فیلد `kubectl` اعمال می‌شود.

به عنوان یک استثنا، می‌توانید با مشخص کردن یک مدیر فیلد متفاوت و غیر پیش‌فرض، همانطور که در مثال زیر مشاهده می‌شود، از این رفتار خودداری کنید. مدیر فیلد پیش‌فرض برای kubectl server-side apply، `kubectl` است.

```shell
kubectl apply --server-side --field-manager=my-manager [--dry-run=server]
```

### Downgrading from server-side apply to client-side apply

اگر منبعی را با `kubectl apply --server-side` مدیریت می‌کنید، می‌توانید مستقیماً با `kubectl apply` به سمت کلاینت برگردید.

Downgrading works because kubectl Server-Side Apply keeps the
`last-applied-configuration` annotation up-to-date if you use
`kubectl apply`.

دانگرید به نسخه پایین‌تر (downgrade) کار می‌کند زیرا kubectl Server-Side Apply در صورت استفاده از `kubectl apply`.، حاشیه‌نویسی `last-applied-configuration` را به‌روز نگه می‌دارد.

این رفتار در مورد Server-Side Apply با مدیر فیلد `kubectl` اعمال می‌شود.
به عنوان یک استثنا، می‌توانید با مشخص کردن یک مدیر فیلد متفاوت و غیر پیش‌فرض، همانطور که در مثال زیر مشاهده می‌شود، از این رفتار صرف نظر کنید. مدیر فیلد پیش‌فرض برای kubectl server-side apply، `kubectl` است.

```shell
kubectl apply --server-side --field-manager=my-manager [--dry-run=server]
```

## پیاده سازی API

فعل `PATCH` (برای شیء‌ای که از Server-Side Apply پشتیبانی می‌کند) نوع محتوای غیررسمی `application/apply-patch+yaml` را می‌پذیرد. کاربران Server-Side
Apply می‌توانند اشیاء جزئی مشخص شده را به صورت YAML به عنوان بدنه درخواست `PATCH` به URI یک منبع ارسال کنند. هنگام اعمال پیکربندی، همیشه باید تمام فیلدهایی را که برای نتیجه (مانند حالت مطلوب) که می‌خواهید تعریف کنید، مهم هستند، لحاظ کنید.

تمام پیام‌های JSON از نوع YAML معتبر هستند. بنابراین، علاوه بر استفاده از بدنه‌های درخواست YAML برای درخواست‌های Server-Side Apply، می‌توانید از بدنه‌های درخواست JSON نیز استفاده کنید، زیرا آنها نیز از نوع YAML معتبر هستند. در هر صورت، برای درخواست HTTP از نوع رسانه `application/apply-patch+yaml` استفاده کنید.

### کنترل دسترسی و مجوزها {#rbac-and-permissions}

از آنجایی که Server-Side Apply نوعی `PATCH` است، یک principal (مانند یک Role برای Kubernetes
{{< glossary_tooltip text="RBAC" term_id="rbac" >}}) برای ویرایش منابع موجود به مجوز **patch** نیاز دارد و همچنین برای ایجاد منابع جدید با Server-Side Apply به مجوز **create** verb نیاز دارد.

## Clearing `managedFields`

می‌توان تمام «فیلدهای مدیریت‌شده» را از یک شیء با بازنویسی آنها - با استفاده از یک **پچ** (پچ ادغام JSON، پچ ادغام استراتژیک، پچ JSON) - یا از طریق **به‌روزرسانی** (HTTP `PUT`) - حذف کرد؛ به عبارت دیگر، از طریق هر عملیات نوشتن - به غیر از **اعمال**. این کار را می‌توان با بازنویسی فیلد «فیلدهای مدیریت‌شده» با یک ورودی خالی انجام داد. دو مثال عبارتند از:

```console
PATCH /api/v1/namespaces/default/configmaps/example-cm
Accept: application/json
Content-Type: application/merge-patch+json

{
  "metadata": {
    "managedFields": [
      {}
    ]
  }
}
```

```console
PATCH /api/v1/namespaces/default/configmaps/example-cm
Accept: application/json
Content-Type: application/json-patch+json
If-Match: 1234567890123456789

[{"op": "replace", "path": "/metadata/managedFields", "value": [{}]}]
```

این کار `managedFields` را با فهرستی حاوی یک ورودی خالی بازنویسی می‌کند که در نتیجه منجر به حذف کامل `managedFields` از شیء می‌شود. توجه داشته باشید که تنظیم `managedFields` روی یک فهرست خالی، فیلد را بازنشانی نمی‌کند. این کار عمدی است، بنابراین `managedFields` هرگز توسط کلاینت‌هایی که از فیلد آگاه نیستند، حذف نمی‌شود.



{{< note >}}
Server-Side Apply مالکیت را در زیرمنابعی که نوع شیء منبع را دریافت نمی‌کنند، به درستی ردیابی نمی‌کند. اگر از Server-Side Apply با چنین زیرمنبعی استفاده می‌کنید، ممکن است فیلدهای تغییر یافته ردیابی نشوند.
{{< /note >}}

## {{% heading "whatsnext" %}}

می‌توانید در مورد  `managedFields` در مرجع API کوبرنتیز برای فیلد سطح بالا [`metadata`](/docs/reference/kubernetes-api/common-definitions/object-meta/) مطالعه کنید.