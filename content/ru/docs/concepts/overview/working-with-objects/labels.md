---
title: Метки и селекторы
content_type: concept
weight: 40
---

<!-- overview -->

_Метки_ — это пары ключ-значение, которые добавляются к объектам, как поды.
Метки предназначены для идентификации атрибутов объектов, которые имеют значимость и важны для пользователей, но при этом не относятся напрямую к основной системе.
Метки можно использовать для группировки и выбора подмножеств объектов. Метки могут быть добавлены к объектам во время создания и изменены в любое время после этого.
Каждый объект может иметь набор меток в виде пары ключ-значение. Каждый ключ должен быть уникальным в рамках одного и того же объекта.

```json
"metadata": {
  "labels": {
    "key1" : "value1",
    "key2" : "value2"
  }
}
```

Метки используются при получении и отслеживании объектов и в веб-панелях и CLI-инструментах. Любая неидентифицирующая информация должна быть записана в [аннотации](/ru/docs/concepts/overview/working-with-objects/annotations/).



<!-- body -->

## Причины использования

Метки позволяют пользователям гибко сопоставить их организационные структуры с системными объектами, не требуя от клиентов хранить эти соответствия.

Развертывания сервисов и процессы пакетной обработки часто являются многомерными сущностями (например, множество разделов или развертываний, несколько групп выпусков, несколько уровней приложения, несколько микросервисов на каждый уровень приложения). Для управления часто требуются сквозные операции, которые нарушают инкапсуляцию строго иерархических представлений, особенно жестких иерархий, определяемых инфраструктурой, а не пользователями.

Примеры меток:

   * `"release" : "stable"`, `"release" : "canary"`
   * `"environment" : "dev"`, `"environment" : "qa"`, `"environment" : "production"`
   * `"tier" : "frontend"`, `"tier" : "backend"`, `"tier" : "cache"`
   * `"partition" : "customerA"`, `"partition" : "customerB"`
   * `"track" : "daily"`, `"track" : "weekly"`

Это всего лишь примеры часто используемых меток; конечно, вы можете использовать свои собственные. Помните о том, что ключ метки должна быть уникальной в пределах одного объекта.

## Синтаксис и набор символов

_Метки_ представляют собой пары ключ-значение. Разрешенные ключи метки имеют два сегмента, разделённые слешем (`/`): префикс (необязательно) и имя. Сегмент имени обязателен и должен содержать не более 63 символов, среди которых могут быть буквенно-цифровые символы (`[a-z0-9A-Z]`), а также дефисы (`-`), знаки подчеркивания (`_`), точки (`.`). Префикс не обязателен, но он быть поддоменом DNS: набор меток DNS, разделенных точками (`.`), общей длиной не более 253 символов, за которыми следует слеш (`/`).

Если префикс не указан, ключ метки считается закрытым для пользователя. Компоненты автоматизированной системы (например, `kube-scheduler`, `kube-controller-manager`, `kube-apiserver`, `kubectl` или другие сторонние), которые добавляют метки к объектам пользователя, должны указывать префикс.

Префиксы  `kubernetes.io/` и `k8s.io/` зарезервированы для использования основными компонентами Kubernetes.

Например, ниже представлен конфигурационный файл объекта Pod с двумя метками `environment: production` и `app: nginx`:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: label-demo
  labels:
    environment: production
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

## Селекторы меток

В отличие от [имен и идентификаторов](/docs/user-guide/identifiers), метки не гарантируют уникальность. Поэтому мы предполагаем, что многие объекты будут иметь одинаковые метки.

С помощью _селектора меток_ клиент/пользователь может идентифицировать набор объектов. Селектор меток — основное средство группировки в Kubernetes.

В настоящее время API поддерживает два типа селекторов: _на равенстве_ и _на наборе_.
Селектор меток может состоять из нескольких _условий_, разделенных запятыми. В таком случае все условия должны быть выполнены, поэтому запятая-разделитель работает как логический оператор _И_ (`&&`).

Работа пустых или неопределённых селекторов зависит от контекста. Типы API, которые использует селекторы, должны задокументировать это поведение.

{{< note >}}
Для некоторых API-типов, например, ReplicaSets, селекторы меток двух экземпляров не должны дублироваться в пространстве имен, в противном случае контроллер может рассматривать их как конфликтующие инструкции и не сможет определить количество реплик.
{{< /note >}}

{{< caution >}}
Как для условий, основанных на равенстве, так и для условий на основе набора, не существует логического оператора _ИЛИ_ (`||`). Убедитесь, что синтаксис фильтрации правильно составлен.
{{< /caution >}}

### Условие _равенства_

Условия _равенства_ или _неравенства_ позволяют отфильтровать объекты по ключам и значениям меток. Сопоставляемые объекты должны удовлетворять всем указанным условиям меток, хотя при этом у объектов также могут быть заданы другие метки.
Доступны три оператора: `=`,`==`,`!=`. Первые два означают _равенство_ (и являются всего лишь синонимами), а последний оператор определяет _неравенство_. Например:

```
environment = production
tier != frontend
```

Первый пример выбирает все ресурсы с ключом `environment`, у которого значение указано `production`.
Последний получает все ресурсы с ключом `tier` без значения `frontend`, а также все ресурсы, в которых нет метки с ключом `tier`.
Используя оператор запятой можно совместить показанные два условия в одно, запросив ресурсы, в которых есть значение метки `production` и исключить `frontend`: `environment=production,tier!=frontend`.

С помощью условия равенства в объектах Pod можно указать, какие нужно выбрать ресурсы. Например, в примере ниже объект Pod выбирает узлы с меткой "`accelerator=nvidia-tesla-p100`".

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: cuda-test
spec:
  containers:
    - name: cuda-test
      image: "registry.k8s.io/cuda-vector-add:v0.1"
      resources:
        limits:
          nvidia.com/gpu: 1
  nodeSelector:
    accelerator: nvidia-tesla-p100
```

### Условие _набора_

Условие меток _на основе набора_ фильтрует ключи в соответствии с набором значений. Поддерживаются три вида операторов: `in`, `notin` и `exists` (только идентификатор ключа). Например:

```
environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
```

В первом примере выбираются все ресурсы с ключом `environment` и значением `production` или `qa`.
Во втором примере выбираются все ресурсы с ключом `tier` и любыми значениями, кроме `frontend` и `backend`, а также все ресурсы без меток с ключом `tier`.
Третий пример выбирает все ресурсы, включая метку с ключом `partition` (с любым значением).
В четвертом примере выбираются все ресурсы без метки с ключом `partition` (с любым значением).
Как и логический оператор _И_ работает разделитель в виде запятой. Таким образом, фильтрация ресурсов по ключу `partition` (вне зависимости от значения) и ключу `environment` с любым значением, кроме `qa`, можно получить с помощью следующего выражения: `partition,environment notin (qa)`.
Селектор меток _на основе набора_ — основная форма равенства, поскольку `environment=production` то же самое, что и `environment in (production)`; аналогично, оператор `!=` соответствует `notin`.

Условия _набора_ могут использоваться одновременно с условия _равенства_. Например, так: `partition in (customerA, customerB),environment!=qa`.

## API

### Фильтрация LIST и WATCH

Операции LIST и WATCH могут использовать параметр запроса, чтобы указать селекторы меток фильтрации наборов объектов. Есть поддержка обоих условий (строка запроса URL ниже показывается в исходном виде):

  * Условия _на основе равенства_: `?labelSelector=environment%3Dproduction,tier%3Dfrontend`
  * Условия _на основе набора_: `?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29`

Указанные выше формы селектора меток можно использовать для просмотра или отслеживания ресурсов через REST-клиент. Например, `apiserver` с `kubectl`, который использует _условие равенства_:

```shell
kubectl get pods -l environment=production,tier=frontend
```

Либо используя условия _на основе набора_:

```shell
kubectl get pods -l 'environment in (production),tier in (frontend)'
```

Как уже показывалось, _условия набора_ дают больше возможностей. Например, в них можно использовать подобие оператора _И_:

```shell
kubectl get pods -l 'environment in (production, qa)'
```

Либо можно воспользоваться исключающим сопоставлением с помощью оператора _notin_:

```shell
kubectl get pods -l 'environment,environment notin (frontend)'
```

### Установка ссылок в API-объекты

Некоторые объекты Kubernetes, такие как [`services`](/docs/user-guide/services) и [`replicationcontrollers`](/docs/user-guide/replication-controller), также используют селекторы меток для ссылки на наборы из других ресурсов, например, [подов](/docs/user-guide/pods).

#### Service и ReplicationController

Набор подов, на которые указывает `service`, определяется через селектор меток. Аналогичным образом, количество подов, которыми должен управлять `replicationcontroller`, также формируются с использованием селектора меток.

Селекторы меток для обоих объектов записываются в словарях файлов формата `json` и `yaml`, при этом поддерживаются только селекторы с условием _равенства_:

```json
"selector": {
    "component" : "redis",
}
```

Или:

```yaml
selector:
    component: redis
```

Этот селектор (как в формате `json`, так и в `yaml`) эквивалентен `component=redis` или `component in (redis)`.

#### Ресурсы, поддерживающие условия набора

Новые ресурсы, такие как [`Job`](/docs/concepts/workloads/controllers/jobs-run-to-completion/), [`Deployment`](/docs/concepts/workloads/controllers/deployment/), [`ReplicaSet`](/docs/concepts/workloads/controllers/replicaset/) и [`DaemonSet`](/docs/concepts/workloads/controllers/daemonset/), также поддерживают условия _набора_.

```yaml
selector:
  matchLabels:
    component: redis
  matchExpressions:
    - {key: tier, operator: In, values: [cache]}
    - {key: environment, operator: NotIn, values: [dev]}
```

`matchLabels` — словарь пар `{key,value}`. Каждая пара `{key,value}` в словаре `matchLabels` эквивалентна элементу `matchExpressions`, где поле `key` — "key", поле `operator` — "In", а массив `values` содержит только "value".
`matchExpressions` представляет собой список условий селектора пода. В качестве операторов могут быть In, NotIn, Exists и DoesNotExist. В случае использования In и NotIn должны заданы непустые значения. Все условия, как для `matchLabels`, так и для `matchExpressions`, объединяются с помощью логического И, поэтому при выборке объектов все они должны быть выполнены.

#### Выбор наборов узлов

Один из вариантов использования меток — возможность выбора набора узлов, в которых может быть развернут под.
Смотрите документацию про [выбор узлов](/docs/concepts/configuration/assign-pod-node/), чтобы получить дополнительную информацию.


