---
title: "Ресурсы рабочей нагрузки"
weight: 20
simple_list: true
---

Kubernetes предоставляет несколько встроенных API для декларативного управления
{{< glossary_tooltip text="рабочими нагрузками" term_id="workload" >}}
и их компонентами.

В конечном счете, приложения работают в качестве контейнеров внутри
{{< glossary_tooltip term_id="Pod" text="подов" >}}, однако управление каждым подом по отдельности требует больших усилий.
Например, если под выходит из строя, вам, вероятно, надо будет
запустить новый под, чтобы заменить его. Kubernetes может сделать это за вас.

С помощью Kubernetes API можно создавать
{{< glossary_tooltip text="объект" term_id="object" >}} рабочей нагрузки на более высоком уровне абстракции, чем под, а затем уже {{< glossary_tooltip text="слой управления" term_id="control-plane" >}} Kubernetes
будет автоматически управлять подами, руководствуясь спецификацией этого объекта.

Встроенные API для управления рабочими нагрузками: 

Деплоймент ([Deployment](/docs/concepts/workloads/controllers/deployment/)) (и, косвенно, [ReplicaSet](/docs/concepts/workloads/controllers/replicaset/)) — это наиболее распространенный способ запуска приложения в кластере.
Deployment хорошо подходит для управления неизменной (stateless) рабочей нагрузкой в кластере, где
любой под в деплойменте не содержит изменяемых данных и может быть заменен при необходимости
(Deployments — замена устаревшего ресурса
{{< glossary_tooltip text="ReplicationController" term_id="replication-controller" >}} API).

[StatefulSet](/docs/concepts/workloads/controllers/statefulset/) позволяет управлять одним или несколькими подами,
в которых работает одно и то же приложение, для случаев, когда все эти поды требуют четкой идентичности (т.е. являются stateful).
Это отличается от деплоймента, в котором предполагается, что поды могут быть взаимозаменяемыми.
Наиболее распространенное использование StatefulSet — возможность установить
связь между его подами и их постоянным хранилищем (persistent storage).
Например, можно запустить StatefulSet, который связывает каждый под с [PersistentVolume](/docs/concepts/storage/persistent-volumes/). Если один из подов в StatefulSet выходит из строя,
Kubernetes создает заменяющий под, подключенный к тому же PersistentVolume.

[DaemonSet](/docs/concepts/workloads/controllers/daemonset/) создает поды, которые предоставляют локальные инструменты для
{{< glossary_tooltip text="узлов" term_id="node" >}};
пример — драйвер, который позволяет контейнерам на узле получить доступ к системе хранения.
DaemonSet используется, когда драйвер или сервис должен быть запущен на определенном узле.
Каждый под в DaemonSet выполняет роль, аналогичную системному демону на классическом сервере Unix/POSIX.
DaemonSet может иметь основополагающее значение для работы кластера,
например, для плагина, позволяющего узлу получить доступ к
[сети кластера](/ru/docs/concepts/cluster-administration/networking/#реализация-сетевой-модели-kubernetes).
Он может помочь управлять узлом или предоставить менее важные функции,
улучшающие работу используемой контейнерной платформы. 
DaemonSet'ы (и их поды) можно запускать на каждом узле кластера или только на некоторых из них
(например, можно установить драйвер ускорителя GPU только на узлах, на которых установлен GPU).

[Job](/docs/concepts/workloads/controllers/job/) и/или
[CronJob](/docs/concepts/workloads/controllers/cron-jobs/) используются, чтобы определять задачи,
которые выполняются по отдельному запуску до их завершения, а затем останавливаются. Job представляет собой разовую задачу,
тогда как CronJob повторяется по расписанию. 

Другие темы в этом разделе:
<!-- relies on simple_list: true in the front matter -->
